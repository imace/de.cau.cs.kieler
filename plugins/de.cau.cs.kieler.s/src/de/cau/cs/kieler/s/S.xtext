//grammar de.cau.cs.kieler.s.S with org.eclipse.xtext.common.Terminals
//		 de.cau.cs.kieler.core.expressions.Expressions, 
//		 de.cau.cs.kieler.core.annotations.Annotations
grammar de.cau.cs.kieler.s.S with de.cau.cs.kieler.core.kexpressions.KExpressions
//grammar de.cau.cs.kieler.s.S with de.cau.cs.kieler.synccharts.text.actions.Actions
//grammar de.cau.cs.kieler.s.S with de.cau.cs.kieler.synccharts.text.interfaces.Interfaces

//import 'http://kieler.cs.cau.de/expressions' as expressions --> wrong
//import 'http://kieler.cs.cau.de/annotations' as annotations

import "http://kieler.cs.cau.de/kexpressions/0.1.2" as expressions
//import "platform:/resource/de.cau.cs.kieler.core.annotations/model/annotations.ecore" as annotations

generate s "http://www.cau.de/cs/kieler/s"


Program :
	'Synchronous Program' name = ID '(' priority=INT ')'
	((signals += Signal) (signals += Signal)*)?
	(states += State)+
;



//Annotation:
//	'@' key = ID ':'
//	value = STRING
//;

//TODO: Consolidate with Annotatable xtext grammar somehow... (s.a.)
//Annotatable returns annotations::Annotatable:
// 	State | Instruction;


State:
	'State' '(' name = ID ')' '{'
	((signals+=Signal)+ ';')? 
	(instructions+=Instruction';')*
	'}'
;


Thread:
	'Thread' '(' name = ID ')' '{'
	((signals+=Signal)+ ';')? 
	(states+=State';')*
	'}'
;


Signal returns expressions::Signal:
    (isInput?='input')?
	(isOutput?='output')?
	'signal'
	(name=EString)
	(':=' initialValue=EString)?
    ((':' type=ValueType)
      |
     (':' 'combine' type=ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=EString) )
    )? ";";
    

//---------------------------------------------------------------------
//----------------------- List of S-Instructions ----------------------
//---------------------------------------------------------------------
Continuation:
	 State | Thread
;

Instruction:
   Halt | Abort | Join | Pause | Term | If | Trans | Fork | Emit | Await | Prio
;

// Change priority
Prio:
	'Prio' '('priority=INT (',' continuation=[Continuation])?')'
;

// Transition to anothe Thread or State   
Trans :
	'Trans''(' continuation=[Continuation] ')'
;
  
// Forking new Threads
Fork :
	'Fork''('thread=[Continuation] ',' priority=INT (',' continuation=[Continuation])?')'
;


// Joining Threads
Join : 
	{Join}
	'Join' '('continuation=[Continuation]?')'
;
   

// Simple instructions
Pause :
	{Pause} 
	'Pause''('continuation=[Continuation]?')'
;
  
Term : 
	{Term}
	'Term''('continuation=[Continuation]?')'
;
  
Halt : 
	{Halt}
	'Halt''('continuation=[Continuation]?')'
;
  

Emit:
	'Emit''('signal= [expressions::Signal] (',' value=[expressions::Expression])? (',' continuation=[Continuation])?')'
;
  
Abort : 
	{Abort}
	'Abort''('continuation=[Continuation]?')'
;

// Conditioned execution of instructions  
If : 
	'If''('expression = Expression (',' continuation=[Continuation])?')' '{'
		(instructions += Instruction';')*
	'}'
;
  
// Complex instruction
Await:
	'Await' '('signal= [expressions::Signal] (',' continuation=[Continuation])?')'
;

