//grammar de.cau.cs.kieler.s.S with org.eclipse.xtext.common.Terminals
//		 de.cau.cs.kieler.core.expressions.Expressions, 
//		 de.cau.cs.kieler.core.annotations.Annotations
grammar de.cau.cs.kieler.s.S with de.cau.cs.kieler.core.expressions.Expressions
//grammar de.cau.cs.kieler.s.S with de.cau.cs.kieler.synccharts.text.actions.Actions
//grammar de.cau.cs.kieler.s.S with de.cau.cs.kieler.synccharts.text.interfaces.Interfaces

//import 'http://kieler.cs.cau.de/expressions' as expressions --> wrong
//import 'http://kieler.cs.cau.de/annotations' as annotations

import "platform:/resource/de.cau.cs.kieler.core.expressions/model/expressions.ecore" as expressions
//import "platform:/resource/de.cau.cs.kieler.core.annotations/model/annotations.ecore" as annotations

generate s "http://www.cau.de/cs/kieler/s"

Program :
	'Synchronous Program' name = ID '(' priority=INT ')'
	('Inputs' (signals += Signal) (',' signals += Signal)*';')?
	('Outputs' (signals += Signal) (',' signals += Signal)*';')?
	('Signals' (signals += Signal) (',' signals += Signal)*';')?
	(states += State)+
;

//Annotation:
//	'@' key = ID ':'
//	value = STRING
//;

//TODO: Consolidate with Annotatable xtext grammar somehow... (s.a.)
//Annotatable returns annotations::Annotatable:
// 	State | Instruction;


State:
	name = ID ':'
	('SIGNALS' (signals+=Signal)* ';')? 
	(instructions+=Instruction';')*
;


Signal returns expressions::Signal:
(isInput?='input')?
	(isOutput?='output')?
	'signal'
	(name=EString)
	(':=' initialValue=EString)?
    ((':' type=ValueType)
      |
     (':' 'combine' type=ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=EString) )
    )? ";";
    
//Signal returns expressions::Signal :
//	name=ID ':' 
//	type = SignalType
//	('combine' combineFunction = [CombineFunction])?
//;

//CombineFunction:
//	name=ID
//	type=[expressions::ValueType]
//	type=ValueType
//;


//SignalType:
//	PrimitiveSignalType | CustomSignalType;
  
//CustomSignalType:
//  'CUSTOM' customType = STRING;

//enum PrimitiveType:
//	Pure='PURE' | Int='INT' | Bool='BOOL' | Float='FLOAT';
	
//PrimitiveSignalType:
//	primitiveType = PrimitiveType
//	;
  
//IntValue: 
//	value=IntValue;
//FloatValue:
//    value=Float; 
//BooleanValue:
//    value=Boolean;
    
//terminal Float: 
//	((INT"."INT | INT("."INT)?("e"|"E")("+")?INT))"f"? | INT"f";
//terminal Boolean: 
//	"true" | "false";
	

//---------------------------------------------------------------------
//----------------------- List of S-Instructions ----------------------
//---------------------------------------------------------------------
Instruction:
   Halt | Abort | Join | Pause | Term | Present | Goto | Fork | Forke | Emit | Await | Prio
   ;

Pause :
	{Pause} 
	'PAUSE''('continuation=[State]?')'
  ;
  
Term : 
	{Term}
	'TERM''('continuation=[State]?')'
  ;
  
Halt : 
	{Halt}
	'Halt''('continuation=[State]?')'
  ;
  
Join : 
	{Join}
	'JOIN''('continuation=[State]?')'
  ;
  
Abort : 
	{Abort}
	'ABORT''('continuation=[State]?')'
  ;
  
Present : 
	'PRESENT''('expression = Expression (',' continuation=[State])?')' '{'
		(instructions += Instruction';')*
	'}'
  ;
  
Goto :
	'GOTO''('state=[State] (',' continuation=[State])?')'
  ;
  
Fork :
	'FORK''('state=[State] ',' priority=INT (',' continuation=[State])?')'
  ;
  
Forke :
	'FORKE''('state=[State] (',' continuation=[State])?')'
  ;
  
Emit:
	'EMIT''('signal= [expressions::Signal] (',' continuation=[State])?')'
;

Await:
	'AWAIT''('signal= [expressions::Signal] (',' continuation=[State])?')'
;

Prio:
	'PRIO''('priority=INT (',' continuation=[State])?')'
;