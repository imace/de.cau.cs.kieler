/*
* generated by Xtext
*/
package de.cau.cs.kieler.xtext.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.xtext.services.ExampleGrammarAccess;

import com.google.inject.Inject;

public class ExampleParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private ExampleGrammarAccess grammarAccess;
		
	public ExampleGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Group(this, this, 0, inst);
			case 1: return new Action_TriggersAssignment(this, this, 1, inst);
			case 2: return new Signal_NameAssignment(this, this, 2, inst);
			case 3: return new SignalReference_SignalAssignment(this, this, 3, inst);
			case 4: return new NotOperation_Group(this, this, 4, inst);
			case 5: return new NotOrNormalExpression_Alternatives(this, this, 5, inst);
			case 6: return new AndOperation_Group(this, this, 6, inst);
			case 7: return new OrOperation_Group(this, this, 7, inst);
			case 8: return new ParanthesedBooleanExpression_Alternatives(this, this, 8, inst);
			case 9: return new BooleanExpression_OrOperationParserRuleCall(this, this, 9, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   signals+=Signal+ ";" action=Action;
 *
 **/

// signals+=Signal+ ";" action=Action
protected class Model_Group extends GroupToken {
	
	public Model_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ActionAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signals+=Signal+
protected class Model_SignalsAssignment_0 extends AssignmentToken  {
	
	public Model_SignalsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getSignalsAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getSignalsSignalParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_SignalsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// ";"
protected class Model_SemicolonKeyword_1 extends KeywordToken  {
	
	public Model_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getSemicolonKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_SignalsAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// action=Action
protected class Model_ActionAssignment_2 extends AssignmentToken  {
	
	public Model_ActionAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getActionAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_TriggersAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("action",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("action");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getActionActionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_SemicolonKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Model ****************/


/************ begin Rule Action ****************
 *
 * Action:
 *   triggers+=BooleanExpression;
 *
 **/

// triggers+=BooleanExpression
protected class Action_TriggersAssignment extends AssignmentToken  {
	
	public Action_TriggersAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTriggersAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("triggers",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("triggers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getTriggersBooleanExpressionParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule Action ****************/


/************ begin Rule Signal ****************
 *
 * Signal:
 *   name=ID;
 *
 **/

// name=ID
protected class Signal_NameAssignment extends AssignmentToken  {
	
	public Signal_NameAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Signal ****************/


/************ begin Rule SignalReference ****************
 *
 * SignalReference:
 *   signal=[Signal]; 
 * 	
 * 
 * 	    
 * 	
 * //==============================================================================
 * // Expressions
 * //==============================================================================
 * 
 * // Example: not A, not false, not (A or B)
 * // at the latter we need the parans to indicate the right binding
 *
 **/

// signal=[Signal]
protected class SignalReference_SignalAssignment extends AssignmentToken  {
	
	public SignalReference_SignalAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getSignalAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceAccess().getSignalSignalCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSignalReferenceAccess().getSignalSignalCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule SignalReference ****************/


/************ begin Rule NotOperation ****************
 *
 * NotOperation returns Expression:
 *   operator="not" subExpressions+=ParanthesedBooleanExpression; 
 * 	
 * //==============================================================================
 * // Expressions
 * //==============================================================================
 * 
 * // Example: not A, not false, not (A or B)
 * // at the latter we need the parans to indicate the right binding
 *     
 * 	  
 * 
 * // Example: either negated or normal expression (with parantheses)
 *
 **/

// operator="not" subExpressions+=ParanthesedBooleanExpression
protected class NotOperation_Group extends GroupToken {
	
	public NotOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator="not"
protected class NotOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public NotOperation_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("not".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNotOperationAccess().getOperatorNotKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=ParanthesedBooleanExpression
protected class NotOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public NotOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParanthesedBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNotOperationAccess().getSubExpressionsParanthesedBooleanExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NotOperation_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NotOperation ****************/


/************ begin Rule NotOrNormalExpression ****************
 *
 * NotOrNormalExpression returns Expression:
 *   NotOperation|ParanthesedBooleanExpression; 
 * 
 * // Example: either negated or normal expression (with parantheses) 
 *     
 * 	    
 * 
 * // Example: A and B, not C and 42 <= ?D
 *
 **/

// NotOperation|ParanthesedBooleanExpression 
// 
// // Example: either negated or normal expression (with parantheses) 
//     
// 	    
// 
// // Example: A and B, not C and 42 <= ?D
protected class NotOrNormalExpression_Alternatives extends AlternativesToken {

	public NotOrNormalExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_NotOperationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new NotOrNormalExpression_ParanthesedBooleanExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOperation
protected class NotOrNormalExpression_NotOperationParserRuleCall_0 extends RuleCallToken {
	
	public NotOrNormalExpression_NotOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getNotOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParanthesedBooleanExpression
protected class NotOrNormalExpression_ParanthesedBooleanExpressionParserRuleCall_1 extends RuleCallToken {
	
	public NotOrNormalExpression_ParanthesedBooleanExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getParanthesedBooleanExpressionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParanthesedBooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParanthesedBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NotOrNormalExpression ****************/


/************ begin Rule AndOperation ****************
 *
 * AndOperation returns Expression:
 *   NotOrNormalExpression ({Operation.subExpressions+=current} operator="and"
 *   subExpressions+=NotOrNormalExpression)*; 
 * 
 * // Example: A and B, not C and 42 <= ?D
 *     
 * 	      
 * 
 * // Example: A or B, C and B or D and not E
 *
 **/

// NotOrNormalExpression ({Operation.subExpressions+=current} operator="and"
// subExpressions+=NotOrNormalExpression)*
protected class AndOperation_Group extends GroupToken {
	
	public AndOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOrNormalExpression
protected class AndOperation_NotOrNormalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndOperation_NotOrNormalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getNotOrNormalExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOrNormalExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpressions+=current} operator="and" subExpressions+=
// NotOrNormalExpression)*
protected class AndOperation_Group_1 extends GroupToken {
	
	public AndOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class AndOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public AndOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator="and"
protected class AndOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("and".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAndOperationAccess().getOperatorAndKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=NotOrNormalExpression
protected class AndOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public AndOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndOperationAccess().getSubExpressionsNotOrNormalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndOperation ****************/


/************ begin Rule OrOperation ****************
 *
 * OrOperation returns Expression:
 *   AndOperation ({Operation.subExpressions+=current} operator="or" subExpressions+=
 *   AndOperation)*; 
 * 
 * // Example: A or B, C and B or D and not E 
 *     
 * 	      
 * 
 * // Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
 *
 **/

// AndOperation ({Operation.subExpressions+=current} operator="or" subExpressions+=
// AndOperation)*
protected class OrOperation_Group extends GroupToken {
	
	public OrOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndOperation
protected class OrOperation_AndOperationParserRuleCall_0 extends RuleCallToken {
	
	public OrOperation_AndOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getAndOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpressions+=current} operator="or" subExpressions+=AndOperation)*
protected class OrOperation_Group_1 extends GroupToken {
	
	public OrOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class OrOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public OrOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator="or"
protected class OrOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("or".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOrOperationAccess().getOperatorOrKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=AndOperation
protected class OrOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public OrOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrOperationAccess().getSubExpressionsAndOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrOperation ****************/


/************ begin Rule ParanthesedBooleanExpression ****************
 *
 * ParanthesedBooleanExpression returns Expression:
 *   SignalReference|"(" OrOperation ")"; 
 * 
 * // Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
 *     
 *           
 * 
 * // Example: not D and C or ?E = 42 or not (A and (B or C))
 *
 **/

// SignalReference|"(" OrOperation ")" 
// 
// // Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
//     
//           
// 
// // Example: not D and C or ?E = 42 or not (A and (B or C))
protected class ParanthesedBooleanExpression_Alternatives extends AlternativesToken {

	public ParanthesedBooleanExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_SignalReferenceParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ParanthesedBooleanExpression_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParanthesedBooleanExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// SignalReference
protected class ParanthesedBooleanExpression_SignalReferenceParserRuleCall_0 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_SignalReferenceParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getSignalReferenceParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_SignalAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SignalReference_SignalAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "(" OrOperation ")"
protected class ParanthesedBooleanExpression_Group_1 extends GroupToken {
	
	public ParanthesedBooleanExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ParanthesedBooleanExpression_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public ParanthesedBooleanExpression_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getLeftParenthesisKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// OrOperation
protected class ParanthesedBooleanExpression_OrOperationParserRuleCall_1_1 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_OrOperationParserRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getOrOperationParserRuleCall_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_LeftParenthesisKeyword_1_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParanthesedBooleanExpression_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public ParanthesedBooleanExpression_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getRightParenthesisKeyword_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_OrOperationParserRuleCall_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule ParanthesedBooleanExpression ****************/


/************ begin Rule BooleanExpression ****************
 *
 * BooleanExpression returns Expression:
 *   OrOperation; 
 * 
 * // Example: not D and C or ?E = 42 or not (A and (B or C))
 *
 **/

// OrOperation
protected class BooleanExpression_OrOperationParserRuleCall extends RuleCallToken {
	
	public BooleanExpression_OrOperationParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getOrOperationParserRuleCall();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule BooleanExpression ****************/

}
