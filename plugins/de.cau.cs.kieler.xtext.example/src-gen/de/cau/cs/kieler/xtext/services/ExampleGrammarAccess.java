/*
* generated by Xtext
*/

package de.cau.cs.kieler.xtext.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;

import org.eclipse.xtext.service.GrammarProvider;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ExampleGrammarAccess implements IGrammarAccess {
	
	
	public class ModelElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignalsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSignalsSignalParserRuleCall_0_0 = (RuleCall)cSignalsAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActionActionParserRuleCall_2_0 = (RuleCall)cActionAssignment_2.eContents().get(0);
		
		//Model:
		//  signals+=Signal+ ";" action=Action;
		public ParserRule getRule() { return rule; }

		//signals+=Signal+ ";" action=Action
		public Group getGroup() { return cGroup; }

		//signals+=Signal+
		public Assignment getSignalsAssignment_0() { return cSignalsAssignment_0; }

		//Signal
		public RuleCall getSignalsSignalParserRuleCall_0_0() { return cSignalsSignalParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }

		//action=Action
		public Assignment getActionAssignment_2() { return cActionAssignment_2; }

		//Action
		public RuleCall getActionActionParserRuleCall_2_0() { return cActionActionParserRuleCall_2_0; }
	}

	public class ActionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Action");
		private final Assignment cTriggersAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTriggersBooleanExpressionParserRuleCall_0 = (RuleCall)cTriggersAssignment.eContents().get(0);
		
		//Action:
		//  triggers+=BooleanExpression;
		public ParserRule getRule() { return rule; }

		//triggers+=BooleanExpression
		public Assignment getTriggersAssignment() { return cTriggersAssignment; }

		//BooleanExpression
		public RuleCall getTriggersBooleanExpressionParserRuleCall_0() { return cTriggersBooleanExpressionParserRuleCall_0; }
	}

	public class SignalElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Signal");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Signal:
		//  name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class SignalReferenceElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalReference");
		private final Assignment cSignalAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cSignalSignalCrossReference_0 = (CrossReference)cSignalAssignment.eContents().get(0);
		private final RuleCall cSignalSignalIDTerminalRuleCall_0_1 = (RuleCall)cSignalSignalCrossReference_0.eContents().get(1);
		
		//SignalReference:
		//  signal=[Signal]; 
		//	
		//
		//	    
		//	
		////==============================================================================
		//// Expressions
		////==============================================================================
		//
		//// Example: not A, not false, not (A or B)
		//// at the latter we need the parans to indicate the right binding
		public ParserRule getRule() { return rule; }

		//signal=[Signal]
		public Assignment getSignalAssignment() { return cSignalAssignment; }

		//[Signal]
		public CrossReference getSignalSignalCrossReference_0() { return cSignalSignalCrossReference_0; }

		//ID
		public RuleCall getSignalSignalIDTerminalRuleCall_0_1() { return cSignalSignalIDTerminalRuleCall_0_1; }
	}

	public class NotOperationElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOperatorNotKeyword_0_0 = (Keyword)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubExpressionsParanthesedBooleanExpressionParserRuleCall_1_0 = (RuleCall)cSubExpressionsAssignment_1.eContents().get(0);
		
		//NotOperation returns Expression:
		//  operator="not" subExpressions+=ParanthesedBooleanExpression; 
		//	
		////==============================================================================
		//// Expressions
		////==============================================================================
		//
		//// Example: not A, not false, not (A or B)
		//// at the latter we need the parans to indicate the right binding
		//    
		//	  
		//
		//// Example: either negated or normal expression (with parantheses)
		public ParserRule getRule() { return rule; }

		//operator="not" subExpressions+=ParanthesedBooleanExpression
		public Group getGroup() { return cGroup; }

		//operator="not"
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//"not"
		public Keyword getOperatorNotKeyword_0_0() { return cOperatorNotKeyword_0_0; }

		//subExpressions+=ParanthesedBooleanExpression
		public Assignment getSubExpressionsAssignment_1() { return cSubExpressionsAssignment_1; }

		//ParanthesedBooleanExpression
		public RuleCall getSubExpressionsParanthesedBooleanExpressionParserRuleCall_1_0() { return cSubExpressionsParanthesedBooleanExpressionParserRuleCall_1_0; }
	}

	public class NotOrNormalExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotOrNormalExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNotOperationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParanthesedBooleanExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NotOrNormalExpression returns Expression:
		//  NotOperation|ParanthesedBooleanExpression; 
		//
		//// Example: either negated or normal expression (with parantheses) 
		//    
		//	    
		//
		//// Example: A and B, not C and 42 <= ?D
		public ParserRule getRule() { return rule; }

		//NotOperation|ParanthesedBooleanExpression 
		//
		//// Example: either negated or normal expression (with parantheses) 
		//    
		//	    
		//
		//// Example: A and B, not C and 42 <= ?D
		public Alternatives getAlternatives() { return cAlternatives; }

		//NotOperation
		public RuleCall getNotOperationParserRuleCall_0() { return cNotOperationParserRuleCall_0; }

		//ParanthesedBooleanExpression
		public RuleCall getParanthesedBooleanExpressionParserRuleCall_1() { return cParanthesedBooleanExpressionParserRuleCall_1; }
	}

	public class AndOperationElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotOrNormalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperationSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorAndKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsNotOrNormalExpressionParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//AndOperation returns Expression:
		//  NotOrNormalExpression ({Operation.subExpressions+=current} operator="and"
		//  subExpressions+=NotOrNormalExpression)*; 
		//
		//// Example: A and B, not C and 42 <= ?D
		//    
		//	      
		//
		//// Example: A or B, C and B or D and not E
		public ParserRule getRule() { return rule; }

		//NotOrNormalExpression ({Operation.subExpressions+=current} operator="and"
		//subExpressions+=NotOrNormalExpression)*
		public Group getGroup() { return cGroup; }

		//NotOrNormalExpression
		public RuleCall getNotOrNormalExpressionParserRuleCall_0() { return cNotOrNormalExpressionParserRuleCall_0; }

		//({Operation.subExpressions+=current} operator="and" subExpressions+=
		//NotOrNormalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Operation.subExpressions+=current}
		public Action getOperationSubExpressionsAction_1_0() { return cOperationSubExpressionsAction_1_0; }

		//operator="and"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"and"
		public Keyword getOperatorAndKeyword_1_1_0() { return cOperatorAndKeyword_1_1_0; }

		//subExpressions+=NotOrNormalExpression
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }

		//NotOrNormalExpression
		public RuleCall getSubExpressionsNotOrNormalExpressionParserRuleCall_1_2_0() { return cSubExpressionsNotOrNormalExpressionParserRuleCall_1_2_0; }
	}

	public class OrOperationElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperationSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorOrKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsAndOperationParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//OrOperation returns Expression:
		//  AndOperation ({Operation.subExpressions+=current} operator="or" subExpressions+=
		//  AndOperation)*; 
		//
		//// Example: A or B, C and B or D and not E 
		//    
		//	      
		//
		//// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
		public ParserRule getRule() { return rule; }

		//AndOperation ({Operation.subExpressions+=current} operator="or" subExpressions+=
		//AndOperation)*
		public Group getGroup() { return cGroup; }

		//AndOperation
		public RuleCall getAndOperationParserRuleCall_0() { return cAndOperationParserRuleCall_0; }

		//({Operation.subExpressions+=current} operator="or" subExpressions+=AndOperation)*
		public Group getGroup_1() { return cGroup_1; }

		//{Operation.subExpressions+=current}
		public Action getOperationSubExpressionsAction_1_0() { return cOperationSubExpressionsAction_1_0; }

		//operator="or"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"or"
		public Keyword getOperatorOrKeyword_1_1_0() { return cOperatorOrKeyword_1_1_0; }

		//subExpressions+=AndOperation
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }

		//AndOperation
		public RuleCall getSubExpressionsAndOperationParserRuleCall_1_2_0() { return cSubExpressionsAndOperationParserRuleCall_1_2_0; }
	}

	public class ParanthesedBooleanExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParanthesedBooleanExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSignalReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOrOperationParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//ParanthesedBooleanExpression returns Expression:
		//  SignalReference|"(" OrOperation ")"; 
		//
		//// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
		//    
		//          
		//
		//// Example: not D and C or ?E = 42 or not (A and (B or C))
		public ParserRule getRule() { return rule; }

		//SignalReference|"(" OrOperation ")" 
		//
		//// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
		//    
		//          
		//
		//// Example: not D and C or ?E = 42 or not (A and (B or C))
		public Alternatives getAlternatives() { return cAlternatives; }

		//SignalReference
		public RuleCall getSignalReferenceParserRuleCall_0() { return cSignalReferenceParserRuleCall_0; }

		//"(" OrOperation ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//OrOperation
		public RuleCall getOrOperationParserRuleCall_1_1() { return cOrOperationParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class BooleanExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanExpression");
		private final RuleCall cOrOperationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BooleanExpression returns Expression:
		//  OrOperation; 
		//
		//// Example: not D and C or ?E = 42 or not (A and (B or C))
		public ParserRule getRule() { return rule; }

		//OrOperation
		public RuleCall getOrOperationParserRuleCall() { return cOrOperationParserRuleCall; }
	}
	
	
	private ModelElements pModel;
	private ActionElements pAction;
	private SignalElements pSignal;
	private SignalReferenceElements pSignalReference;
	private NotOperationElements pNotOperation;
	private NotOrNormalExpressionElements pNotOrNormalExpression;
	private AndOperationElements pAndOperation;
	private OrOperationElements pOrOperation;
	private ParanthesedBooleanExpressionElements pParanthesedBooleanExpression;
	private BooleanExpressionElements pBooleanExpression;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public ExampleGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//  signals+=Signal+ ";" action=Action;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Action:
	//  triggers+=BooleanExpression;
	public ActionElements getActionAccess() {
		return (pAction != null) ? pAction : (pAction = new ActionElements());
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}

	//Signal:
	//  name=ID;
	public SignalElements getSignalAccess() {
		return (pSignal != null) ? pSignal : (pSignal = new SignalElements());
	}
	
	public ParserRule getSignalRule() {
		return getSignalAccess().getRule();
	}

	//SignalReference:
	//  signal=[Signal]; 
	//	
	//
	//	    
	//	
	////==============================================================================
	//// Expressions
	////==============================================================================
	//
	//// Example: not A, not false, not (A or B)
	//// at the latter we need the parans to indicate the right binding
	public SignalReferenceElements getSignalReferenceAccess() {
		return (pSignalReference != null) ? pSignalReference : (pSignalReference = new SignalReferenceElements());
	}
	
	public ParserRule getSignalReferenceRule() {
		return getSignalReferenceAccess().getRule();
	}

	//NotOperation returns Expression:
	//  operator="not" subExpressions+=ParanthesedBooleanExpression; 
	//	
	////==============================================================================
	//// Expressions
	////==============================================================================
	//
	//// Example: not A, not false, not (A or B)
	//// at the latter we need the parans to indicate the right binding
	//    
	//	  
	//
	//// Example: either negated or normal expression (with parantheses)
	public NotOperationElements getNotOperationAccess() {
		return (pNotOperation != null) ? pNotOperation : (pNotOperation = new NotOperationElements());
	}
	
	public ParserRule getNotOperationRule() {
		return getNotOperationAccess().getRule();
	}

	//NotOrNormalExpression returns Expression:
	//  NotOperation|ParanthesedBooleanExpression; 
	//
	//// Example: either negated or normal expression (with parantheses) 
	//    
	//	    
	//
	//// Example: A and B, not C and 42 <= ?D
	public NotOrNormalExpressionElements getNotOrNormalExpressionAccess() {
		return (pNotOrNormalExpression != null) ? pNotOrNormalExpression : (pNotOrNormalExpression = new NotOrNormalExpressionElements());
	}
	
	public ParserRule getNotOrNormalExpressionRule() {
		return getNotOrNormalExpressionAccess().getRule();
	}

	//AndOperation returns Expression:
	//  NotOrNormalExpression ({Operation.subExpressions+=current} operator="and"
	//  subExpressions+=NotOrNormalExpression)*; 
	//
	//// Example: A and B, not C and 42 <= ?D
	//    
	//	      
	//
	//// Example: A or B, C and B or D and not E
	public AndOperationElements getAndOperationAccess() {
		return (pAndOperation != null) ? pAndOperation : (pAndOperation = new AndOperationElements());
	}
	
	public ParserRule getAndOperationRule() {
		return getAndOperationAccess().getRule();
	}

	//OrOperation returns Expression:
	//  AndOperation ({Operation.subExpressions+=current} operator="or" subExpressions+=
	//  AndOperation)*; 
	//
	//// Example: A or B, C and B or D and not E 
	//    
	//	      
	//
	//// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
	public OrOperationElements getOrOperationAccess() {
		return (pOrOperation != null) ? pOrOperation : (pOrOperation = new OrOperationElements());
	}
	
	public ParserRule getOrOperationRule() {
		return getOrOperationAccess().getRule();
	}

	//ParanthesedBooleanExpression returns Expression:
	//  SignalReference|"(" OrOperation ")"; 
	//
	//// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
	//    
	//          
	//
	//// Example: not D and C or ?E = 42 or not (A and (B or C))
	public ParanthesedBooleanExpressionElements getParanthesedBooleanExpressionAccess() {
		return (pParanthesedBooleanExpression != null) ? pParanthesedBooleanExpression : (pParanthesedBooleanExpression = new ParanthesedBooleanExpressionElements());
	}
	
	public ParserRule getParanthesedBooleanExpressionRule() {
		return getParanthesedBooleanExpressionAccess().getRule();
	}

	//BooleanExpression returns Expression:
	//  OrOperation; 
	//
	//// Example: not D and C or ?E = 42 or not (A and (B or C))
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return (pBooleanExpression != null) ? pBooleanExpression : (pBooleanExpression = new BooleanExpressionElements());
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}

	//terminal ID:
	//  "^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//  "0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//  "\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" |
	//  "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//  "/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//  "//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//  (" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//  .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
