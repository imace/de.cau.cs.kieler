grammar de.cau.cs.kieler.synccharts.dsl.Kits with org.eclipse.xtext.common.Terminals
//generate kits "http://www.cau.de/cs/kieler/synccharts/dsl/Kits"
import "platform:/resource/de.cau.cs.kieler.synccharts/model/synccharts.ecore" as sync
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
Region returns sync::Region :
	('region' id=ID)?
	
	(	variables+=Variable
	|	signals+=Signal
	|	innerStates+=State
	)+
;
State returns sync::State:
	
(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
  	| ((isInitial?='init')(isFinal?='final')) 'state'
  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
  	| ((isInitial?='init')(isFinal?='final'))
  	
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
  	| ((isFinal?='final')(isInitial?='init')) 'state'
  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
  	| ((isFinal?='final')(isInitial?='init'))
  	
  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
  	| (isInitial?='init') (type=StateType) 'state'
  	| (isInitial?='init') (type=StateType) id=FullStateID  
  	| (isInitial?='init') 'state' id=FullStateID
  	| (isInitial?='init') (type=StateType) 
  	| (isInitial?='init') 'state'
  	| (isInitial?='init') id=FullStateID
  	| (isInitial?='init')
  	
  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
  	| (isFinal?='final')  (type=StateType) 'state' 
  	| (isFinal?='final')  (type=StateType) id=FullStateID
  	| (isFinal?='final')  'state' id=FullStateID
  	| (isFinal?='final')  (type=StateType)
  	| (isFinal?='final')  'state' id=FullStateID
  	| (isFinal?='final')  id=FullStateID
  	| (isFinal?='final')
  	
  	| (type=StateType) 'state' id=FullStateID
  	| (type=StateType) 'state'
  	| (type=StateType) id=FullStateID
  	| (type=StateType)
  	
  	| 'state' id=FullStateID
  	| 'state'
  		
  	| id=FullStateID
  )

  (label=FullStateID)? //	('['(signalRenamings+=Renaming ',')* signalRenamings+=Renaming']')?
  (bodyText=STRING)? 
  
   ('{' 
	    (	 	('onentry' entryActions+=Action) 
	  		| 	('oninner' innerActions+=Action) 
	  		|   ('onexit' exitActions+=Action ) 
	  		| 	('suspension' suspensionTrigger=Action) // kein effect, kein delay, kein immediate
	  		| 	(signals+=Signal) 
	  		|   (regions+=Region ('||' regions+=Region)*)
	  	)+
   	'}')?
   	(outgoingTransitions+=Transition)* 
;
Renaming returns sync::Renaming: oldID=STRING'/'newID=STRING;
FullStateID : ((ID'@')?ID);
	//========================================================================================
	//===  									    ACTIONS  					               ===
	//========================================================================================
//Action returns sync::Action:
//	((isImmediate?='#')? (delay=INT ';')? (triggersAndEffects=STRING))
//| 
//	Transition
//	
//;

	//========================================================================================
	//===  									    TRANSITION 					               ===
	//========================================================================================
	
Transition returns sync::Transition:

	(sourceState=[sync::State|FullStateID])? //either reference existing state or create a new one or leave it blank (in that case, the transition belongs to the containing state)
	//|({sync::State} name=FullStateID)
	type=TransitionType
	(targetState=[sync::State|FullStateID])
	//|newTargetState=TransitionState )
	( 'with' (isImmediate?='#')? (delay=INT)?
		     (trigger=BooleanExpression)?
		     ("/" (effects+=Effect (',')?)* )?
			 
	)?
	(isHistory?=' history')?
	';'
;
TransitionState returns sync::State:
	(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
  	| ((isInitial?='init')(isFinal?='final')) 'state'
  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
  	| ((isInitial?='init')(isFinal?='final'))
  	
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
  	| ((isFinal?='final')(isInitial?='init')) 'state'
  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
  	| ((isFinal?='final')(isInitial?='init'))
  	
  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
  	| (isInitial?='init') (type=StateType) 'state'
  	| (isInitial?='init') (type=StateType) id=FullStateID  
  	| (isInitial?='init') 'state' id=FullStateID
  	| (isInitial?='init') (type=StateType) 
  	| (isInitial?='init') 'state'
  	| (isInitial?='init') id=FullStateID
  	| (isInitial?='init')
  	
  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
  	| (isFinal?='final')  (type=StateType) 'state' 
  	| (isFinal?='final')  (type=StateType) id=FullStateID
  	| (isFinal?='final')  'state' id=FullStateID
  	| (isFinal?='final')  (type=StateType)
  	| (isFinal?='final')  'state' id=FullStateID
  	| (isFinal?='final')  id=FullStateID
  	| (isFinal?='final')
  	
  	| (type=StateType) 'state' id=FullStateID
  	| (type=StateType) 'state'
  	| (type=StateType) id=FullStateID
  	| (type=StateType)
  	
  	| 'state' id=FullStateID
  	| 'state'
  		
  	| id=FullStateID
  )
	
;
 	//========================================================================================
	//===  									    VAR,SIG  					               ===
	//========================================================================================

ValuedObject returns sync::ValuedObject:
	Signal | Variable
;
Variable returns sync::Variable:
	'var' name=ID 
	( 
	  (': ' type=ValueType)//or type only, type being either pre-defined or hostcode
	| (':=' initialValue=ID ': ' type=ValueType) // either initial value and type 
	)  
;
Signal returns sync::Signal:
 	//a signal is EITHER local OR (input or output or both)
	//(	(isLocal?='local')
	//| 
		(	(isInput?='input')
		|
		 	(isOutput?='output')
		|
		 	((isInput?='input')(isOutput?='output'))                                   
		 )		
	//)
	name=ID 
	
	(':=' initialValue=ID)? 
	
	( 
		(': ' type=ValueType) // either initial value and type
	| 	(': combine' type=ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=STRING)) //or initial value and combine type
	) 
;
//==============================================================================
// Basic Actions
//==============================================================================

Action returns sync::Action:
	(isImmediate?='#')? (delay=INT)? (trigger=BooleanExpression)? ("/" (effects+=Effect (',')? )*)?; 		

Effect returns sync::Effect: 
	Emission | Assignment | HostCode;
		
Emission returns sync::Emission:
	signal=[sync::Signal] ("(" newValue=ValueExpression ")")?;

Assignment returns sync::Assignment:
	variable=[sync::Variable] ":=" expression=ValueExpression;

SignalReference returns sync::SignalReference:
	signal = [sync::Signal];

VariableReference returns sync::VariableReference:
	variable = [sync::Variable];
//
//Signal returns sync::Signal:
//	name=ID;
//	
//Variable returns sync::Variable:
//	name=ID;

//==============================================================================
// Values
//==============================================================================

IntValue returns sync::IntValue: 
	value=INT;
FloatValue returns sync::FloatValue:
    value=Float ; 
BooleanValue returns sync::BooleanValue :
    value=Boolean;
Value returns sync::Value:
	IntValue | FloatValue | BooleanValue;

// make sure the Float rule does not shadow the built-in INT rule
terminal Float returns ecore::EFloatObject : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
terminal Boolean returns ecore::EBooleanObject : "true" | "false";

//==============================================================================
// Expressions
//==============================================================================

// Example: ?A	
ValOperation returns sync::ComplexExpression:
	operator=ValOperator subExpressions+=SignalReference;

// Example: 42, ?A, var1
ValueExpression returns sync::Expression:
	IntValue | FloatValue | ValOperation | VariableReference;

// Example: 42 <= ?A
CompareOperation returns sync::Expression:
	ValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	

// Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding
NotOperation returns sync::ComplexExpression:
	operator=NotOperator subExpressions+=ParanthesedBooleanExpression;

// Example: either negated or normal expression (with parantheses) 
NotOrNormalExpression returns sync::Expression:
	NotOperation | ParanthesedBooleanExpression;

// Example: A and B, not C and 42 <= ?D
AndOperation returns sync::Expression:
	NotOrNormalExpression ({sync::ComplexExpression.subExpressions+=current} operator=OperatorAnd subExpressions+=NotOrNormalExpression)*;

// Example: A or B, C and B or D and not E 
OrOperation returns sync::Expression:
	AndOperation ({sync::ComplexExpression.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;

// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
ParanthesedBooleanExpression returns sync::Expression:
    BooleanValue | SignalReference | CompareOperation | '('OrOperation')' ;

// Example: not D and C or ?E = 42 or not (A and (B or C))
BooleanExpression returns sync::Expression:
	OrOperation ;

//==============================================================================
// Operators
//==============================================================================
	
enum OperatorType returns sync::OperatorType:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";

enum ValOperator returns sync::OperatorType:
	VAL="?";

enum CompareOperator returns sync::OperatorType:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
	
enum NotOperator returns sync::OperatorType:
	NOT="not";

enum OperatorOr returns sync::OperatorType:
	OR="or";

enum OperatorAnd returns sync::OperatorType:
	AND="and";

//==============================================================================
// Misc
//==============================================================================
	
HostCode returns sync::HostCode:
	//"'"code=STRING"'";
	code=STRING ("(" type=ID ")")?; 	
enum StateType	returns sync::StateType	: NORMAL='state' | CONDITIONAL='cond' | REFERENCE='ref' | TEXTUAL='textual'; 
enum CombineOperator returns sync::CombineOperator: NONE | ADD='+' | MULT='*' | AND='AND'| OR='OR' |HOST='hostCombineOperator';
enum ValueType returns sync::ValueType: PURE | BOOL='boolean' | UNSIGNED='unsigned' | INTEGER='integer' | FLOAT='float' | HOST='hostType';	
enum TransitionType returns sync::TransitionType: WEAKABORT='-->' |  STRONGABORT='o->' | NORMALTERMINATION='>->'; 
