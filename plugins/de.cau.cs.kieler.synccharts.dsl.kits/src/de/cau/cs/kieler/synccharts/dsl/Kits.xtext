grammar de.cau.cs.kieler.synccharts.dsl.Kits with org.eclipse.xtext.common.Terminals
import "platform:/resource/de.cau.cs.kieler.synccharts/model/synccharts.ecore" as sync
import "platform:/resource/de.cau.cs.kieler.synccharts.textual/model/textualsynccharts.ecore" as textualsync
import "http://www.eclipse.org/emf/2002/Ecore" as ecore 

// IO Declarations --- come before state declarations #2009-11-26
// There are no region signals as in thinkccharts --- outtake: (variables+=Variable|signals+=Signal)#2009-11-26 
// Inner states --- a region has to have at least one state#2009-11-26
Region returns sync::Region:
// GMF does not like empty models so avoid them by forcing Xtext to create a region object even if the model is empty:
  {sync::Region} 
  ('region')? (id=ID)? 
  (variables+=Variable|signals+=Signal)* 
  (innerStates+=State)+;
  
State returns sync::State:
  {sync::State} // order of state modifiers and type has been fixed --- could be relaxed in future by uncommenting the following lines #2009-11-26 
  (isInitial?='init')? (isFinal?='final')? (type=StateType)? 
  ('state')? (label=FullStateID)(id=STRING)? (bodyText=STRING)? 
  // State_Group_1_1
  //    |((isInitial?='init') (isFinal?='final')) (type=StateType) 'state' // State_Group_1_2
  //    |((isInitial?='init') (isFinal?='final')) (type=StateType) id=FullStateID // State_Group_1_3
  //    |((isInitial?='init') (isFinal?='final')) 'state' id=FullStateID // State_Group_1_4
  //    |((isInitial?='init') (isFinal?='final')) (type=StateType) // State_Group_1_5
  //    |((isInitial?='init') (isFinal?='final')) 'state'|((isInitial?='init') (isFinal?='final')) id=FullStateID// State_Group_1_6
  //    |((isInitial?='init') (isFinal?='final'))
  //    |((isFinal?='final') (isInitial?='init')) (type=StateType) 'state' id=FullStateID// State_Group_1_8
  //    |((isFinal?='final') (isInitial?='init')) (type=StateType) 'state'
  //    |((isFinal?='final') (isInitial?='init')) (type=StateType) id=FullStateID
  //    |((isFinal?='final') (isInitial?='init')) 'state' id=FullStateID// State_Group_1_11
  //    |((isFinal?='final') (isInitial?='init')) (type=StateType)
  //    |((isFinal?='final') (isInitial?='init')) 'state'
  //    |((isFinal?='final') (isInitial?='init')) id=FullStateID
  //    |((isFinal?='final') (isInitial?='init'))
  //    |(isInitial?='init') (type=StateType) 'state' id=FullStateID // // State_Group_1_16
  //    |(isInitial?='init') (type=StateType) 'state'
  //    |(isInitial?='init') (type=StateType) id=FullStateID
  //    |(isInitial?='init') 'state' id=FullStateID
  //    |(isInitial?='init') (type=StateType)
  //    |(isInitial?='init') 'state'// State_Group_1_21
  //    |(isInitial?='init') id=FullStateID
  //    |(isInitial?='init')
  //    |(isFinal?='final') (type=StateType) 'state' id=FullStateID
  //    |(isFinal?='final') (type=StateType) 'state'
  //    |(isFinal?='final') (type=StateType) id=FullStateID// State_Group_1_26
  //    |(isFinal?='final') 'state' id=FullStateID
  //    |(isFinal?='final') (type=StateType)
  //    |(isFinal?='final') 'state' id=FullStateID
  //    |(isFinal?='final') id=FullStateID
  //    |(isFinal?='final')// State_Group_1_31
  //    |(type=StateType) 'state' id=FullStateID
  //    |(type=StateType) 'state'
  //    |(type=StateType) id=FullStateID
  //    |(type=StateType)
  //    |'state' id=FullStateID// State_Group_1_36
  //    |'state'
  //    |id=FullStateID)// State_Group_1_38 
  
  //change the datatype of label (from FullStateID) to STRING 
  //to prevent wrong parsing in this case: 
  //init A
  //final B
  //A --> B;
  //	('['(signalRenamings+=Renaming ',')* signalRenamings+=Renaming']')?
  
  // order of actions has been fixed ---conform to thinkccharts#2009-11-26
  (signals+=Signal)* 
  ('onentry' entryActions+=Action)* 
  ('oninner' innerActions+=Action)* 
  ('onexit' exitActions+=Action)* 
  ('suspension' suspensionTrigger=Action)? // kein effect, kein delay, kein immediate
  ('{' regions+=Region ('||' regions+=Region)* '}')? 
  (outgoingTransitions+=TextualTransition)*;

Renaming returns sync::Renaming:
  oldID=STRING '/' newID=STRING;

FullStateID:
  ((ID '@')? ID); 
  
//========================================================================================
//===  									    ACTIONS  					               ===
//========================================================================================
//Action returns sync::Action:
//  ((isImmediate?='#')? (delay=INT ';')? (triggersAndEffects=STRING))|Transition; 
//========================================================================================
//===  									    TRANSITION 					               ===
//========================================================================================


Transition returns sync::Transition:

  type=TransitionType 
  targetState=[sync::State|FullStateID] 
  //targetStateProxy=STRING
  ('with' (isImmediate?='#')? (delay=INT)? (((trigger=BooleanExpression)? 
  ('/' (effects+=Effect (',')?)*)?)))? (isHistory?=' history')? ';'
  ; 
  
 //TextualTransition extends Transition
 TextualTransition returns textualsync::TextualTransition :
 type=TransitionType 
 //targetState=[sync::State|FullStateID] 
 targetStateProxy=STRING
 ('with' (isImmediate?='#')? (delay=INT)? (((trigger=BooleanExpression)? 
 ('/' (effects+=Effect (',')?)*)?)))? (isHistory?=' history')? ';'
 ;
  
  
//  (sourceState=[State|FullStateID])// sync::State//|FullStateID]) //either reference existing state or create a new one or leave it blank (in that case, the transition belongs to the containing state)
//|({sync::State} name=FullStateID)
//  |
//  (TransitionState))
//TargetState returns sync::Transition:
//	{sync::Transition}
//	//(isInitial?='init')? (isFinal?='final')
//;


TransitionState returns sync::State:
  {sync::State} (isInitial?='init') (isFinal?='final') (type=StateType) 'state' id=
  FullStateID; //  |((isInitial?='init') (isFinal?='final')) (type=StateType) 'state'|((
//  isInitial?='init') (isFinal?='final')) (type=StateType) id=FullStateID|((isInitial
//  ?='init') (isFinal?='final')) 'state' id=FullStateID|((isInitial?='init') (isFinal?=
//  'final')) (type=StateType)|((isInitial?='init') (isFinal?='final')) 'state'|((
//  isInitial?='init') (isFinal?='final')) id=FullStateID|((isInitial?='init') (isFinal
//  ?='final'))|((isFinal?='final') (isInitial?='init')) (type=StateType) 'state' id=
//  FullStateID|((isFinal?='final') (isInitial?='init')) (type=StateType) 'state'|((
//  isFinal?='final') (isInitial?='init')) (type=StateType) id=FullStateID|((isFinal?=
//  'final') (isInitial?='init')) 'state' id=FullStateID|((isFinal?='final') (isInitial
//  ?='init')) (type=StateType)|((isFinal?='final') (isInitial?='init')) 'state'|((
//  isFinal?='final') (isInitial?='init')) id=FullStateID|((isFinal?='final') (
//  isInitial?='init'))|(isInitial?='init') (type=StateType) 'state' id=FullStateID|(
//  isInitial?='init') (type=StateType) 'state'|(isInitial?='init') (type=StateType) id=
//  FullStateID|(isInitial?='init') 'state' id=FullStateID|(isInitial?='init') (type=
//  StateType)|(isInitial?='init') 'state'|(isInitial?='init') id=FullStateID|(
//  isInitial?='init')|(isFinal?='final') (type=StateType) 'state' id=FullStateID|(
//  isFinal?='final') (type=StateType) 'state'|(isFinal?='final') (type=StateType) id=
//  FullStateID|(isFinal?='final') 'state' id=FullStateID|(isFinal?='final') (type=
//  StateType)|(isFinal?='final') 'state' id=FullStateID|(isFinal?='final') id=
//  FullStateID|(isFinal?='final')|(type=StateType) 'state' id=FullStateID|(type=
//  StateType) 'state'|(type=StateType) id=FullStateID|(type=StateType)|'state' id=
//  FullStateID|'state'|id=FullStateID); 
//========================================================================================
//===  									    VAR,SIG  					               ===
//========================================================================================
//


ValuedObject returns sync::ValuedObject:
  Signal|Variable;

Variable returns sync::Variable:
  'var' name=ID ((':=' initialValue=VariableSignalValue)? ': ' type=ValueType);

Signal returns sync::Signal:
  (isInput?='input')? (isOutput?='output')? // Signal names are of type QualifiedName because signals could have names like "main.fork", c.f. rvh_Program.kit
  name=QualifiedName //default signal type is PURE
  // after the initial value, either the type or the combine type has to come
  ((':=' initialValue=VariableSignalValue) ((': ' type=ValueType)|(': combine' type=
  ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=STRING))))?;

VariableSignalValue returns ecore::EString:
  (INT|ID|Boolean|STRING)+;

QualifiedName:
  (ID ".")* ID;

enum StateType returns sync::StateType:
  NORMAL | CONDITIONAL='cond' | REFERENCE='ref' | TEXTUAL='textual';

enum CombineOperator returns sync::CombineOperator:
  NONE | ADD='+' | MULT='*' | AND='AND' | OR='OR' | HOST='hostCombineOperator';

enum ValueType returns sync::ValueType:
  PURE | BOOL='boolean' | UNSIGNED='unsigned' | INTEGER='integer' | FLOAT='float' | HOST=
  'hostType';

enum TransitionType returns sync::TransitionType:
  WEAKABORT='-->' | STRONGABORT='o->' | NORMALTERMINATION='>->'; ////==============================================================================
//// THE REST IS COPY/PASTE 'd from 
////{@link de.cau.cs.kieler.synccharts..labelparser.ActionLabel.xtext}
////==============================================================================
////==============================================================================
//// Basic Actions
////==============================================================================


Action returns sync::Action:
// (parentStateExitAction=[sync::State])
  {sync::Action} (isImmediate?='#')? (delay=INT)? (trigger=BooleanExpression)? ("/" (
  effects+=Effect (',')?)*)?;

Effect returns sync::Effect:
  Emission|Assignment|HostCode;

Emission returns sync::Emission:
  signal=[sync::Signal] (("(" newValue=ValueExpression ")")|("(" newValue=
  BooleanExpression ")"))?;

Assignment returns sync::Assignment:
  variable=[sync::Variable] ":=" (expression=ValueExpression|expression=
  BooleanExpression);

SignalReference returns sync::SignalReference:
  signal=[sync::Signal|QualifiedName];

VariableReference returns sync::VariableReference:
  variable=[sync::Variable]; ////Signal returns sync::Signal:
////    name=ID;
////    
////Variable returns sync::Variable:
////    name=ID;
//==============================================================================
// Values
//==============================================================================
// redefine INT terminal to allow negative numbers


terminal INT returns ecore::EInt:
  '-'? ('0'..'9')+;

IntValue returns sync::IntValue:
  value=INT;

FloatValue returns sync::FloatValue:
  value=Float;

BooleanValue returns sync::BooleanValue:
  value=Boolean;

Value returns sync::Value:
  IntValue|FloatValue|BooleanValue; //// make sure the Float rule does not shadow the INT rule


terminal Float returns ecore::EFloatObject:
  ((INT "." INT | INT ("." INT)? ("e" | "E") ("+")? INT)) "f"? | INT "f";

terminal Boolean returns ecore::EBooleanObject:
  "true" | "false"; //
//==============================================================================
// Arithmetic Expressions
//==============================================================================
// Example: ?A  


ValOperation returns sync::ComplexExpression:
  operator=ValOperator subExpressions+=SignalReference; //
// everything that evaluates to a primitive number value


ValueExpression returns sync::Expression:
  PlusOperation; // Example: 42, 42.2, ?A, var1, (1+2*3)


ParanthesedValueExpression returns sync::Expression:
  IntValue|FloatValue|ValOperation|VariableReference|HostCode|'(' PlusOperation ')'|
  '(' DivOperation ')'; // Example: 1 + 2, varA - ?B


PlusOperation returns sync::Expression:
  MultOrDivOperation ({sync::ComplexExpression.subExpressions+=current} operator=
  PlusOperator subExpressions+=MultOrDivOperation)*;

MultOrDivOperation returns sync::Expression:
  MultOperation|'(' DivOperation ')'; // Example: 2 * 4, varA mod ?B


MultOperation returns sync::Expression:
  PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current}
  operator=MultOperator subExpressions+=PreOrNormalValueExpression)*; // Example: (2 / 4)
// note: division has to have always parantheses because the '/' sign is also used for trigger/effect delimiter


DivOperation returns sync::Expression:
  PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current}
  operator=DivOperator subExpressions+=PreOrNormalValueExpression)*; // Example: pre (? A)


PreArithmOperation returns sync::ComplexExpression:
  operator=UnaryParanthesedOperator '(' subExpressions+=ValOperation ')';

PreOrNormalValueExpression returns sync::Expression:
  PreArithmOperation|ParanthesedValueExpression; //==============================================================================
// Boolean Expressions
//==============================================================================
// Example: 42 <= ?A


CompareOperation returns sync::Expression:
  ValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=
  CompareOperator subExpressions+=ValueExpression); // Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding


UnaryOperation returns sync::ComplexExpression:
  operator=UnaryOperator subExpressions+=ParanthesedBooleanExpression;

UnaryParanthesedOperation returns sync::ComplexExpression:
  operator=UnaryParanthesedOperator '(' subExpressions+=BooleanExpression ')'; // Example: either negated or normal expression (with parantheses) 


UnaryOrNormalExpression returns sync::Expression:
  UnaryOperation|UnaryParanthesedOperation|ParanthesedBooleanExpression; // Example: A and B, not C and 42 <= ?D


AndOperation returns sync::Expression:
  UnaryOrNormalExpression ({sync::ComplexExpression.subExpressions+=current}
  operator=OperatorAnd subExpressions+=UnaryOrNormalExpression)*; // Example: A or B, C and B or D and not E 


OrOperation returns sync::Expression:
  AndOperation ({sync::ComplexExpression.subExpressions+=current} operator=
  OperatorOr subExpressions+=AndOperation)*; // Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
// note that the order of CompareOperation and SignalReference is important. This might be an Xtext bug...


ParanthesedBooleanExpression returns sync::Expression:
  BooleanValue|CompareOperation|SignalReference|HostCode|'(' OrOperation ')'; // Example: not D and C or ?E = 42 or not (A and (B or C))


BooleanExpression returns sync::Expression:
  OrOperation; //==============================================================================
// Operators
//==============================================================================


enum OperatorType returns sync::OperatorType:
  EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not" | AND="and" | OR="or" | ADD="+" | SUB=
  "-" | MULT="*" | DIV="/" | MOD="mod" | VAL="?" | PRE="pre";

enum ValOperator returns sync::OperatorType:
  VAL="?";

enum CompareOperator returns sync::OperatorType:
  EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">="; // not A    


enum UnaryOperator returns sync::OperatorType:
  NOT="not"; // pre(A)


enum UnaryParanthesedOperator returns sync::OperatorType:
  PRE="pre";

enum OperatorOr returns sync::OperatorType:
  OR="or";

enum OperatorAnd returns sync::OperatorType:
  AND="and";

enum OperatorPre returns sync::OperatorType:
  PRE="pre";

enum PlusOperator returns sync::OperatorType:
  ADD="+" | SUB="-";

enum MultOperator returns sync::OperatorType:
  MULT="*" | MOD="mod";

enum DivOperator returns sync::OperatorType:
  DIV="/"; //==============================================================================
// Misc
//==============================================================================


HostCode returns sync::HostCode:
//"'"code=STRING"'";
  code=STRING ("(" type=ID ")")?;     
