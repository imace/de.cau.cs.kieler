/*
* generated by Xtext
*/
package de.cau.cs.kieler.synccharts.dsl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.synccharts.dsl.services.KitsGrammarAccess;

import com.google.inject.Inject;

public class KitsParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private KitsGrammarAccess grammarAccess;
	
	@Override	
	public KitsGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Region_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Region ****************
 *
 * Region returns sync::Region:
 *   "region"? id=ID?; 
 *       
 * 	  
 * 	
 * //	(	//variables+=Variable
 * //	|	signals+=Signal
 * 	 //|
 * //		(innerStates+=State)?
 * //	)+
 * 
 * //State returns sync::State:
 * //{sync::State}
 * //	
 * //(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
 * //  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
 * //  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
 * //  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
 * //  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
 * //  	| ((isInitial?='init')(isFinal?='final')) 'state'
 * //  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
 * //  	| ((isInitial?='init')(isFinal?='final'))
 * //  	
 * //  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
 * //  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
 * //  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
 * //  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
 * //  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
 * //  	| ((isFinal?='final')(isInitial?='init')) 'state'
 * //  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
 * //  	| ((isFinal?='final')(isInitial?='init'))
 * //  	
 * //  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
 * //  	| (isInitial?='init') (type=StateType) 'state'
 * //  	| (isInitial?='init') (type=StateType) id=FullStateID  
 * //  	| (isInitial?='init') 'state' id=FullStateID
 * //  	| (isInitial?='init') (type=StateType) 
 * //  	| (isInitial?='init') 'state'
 * //  	| (isInitial?='init') id=FullStateID
 * //  	| (isInitial?='init')
 * //  	
 * //  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
 * //  	| (isFinal?='final')  (type=StateType) 'state' 
 * //  	| (isFinal?='final')  (type=StateType) id=FullStateID
 * //  	| (isFinal?='final')  'state' id=FullStateID
 * //  	| (isFinal?='final')  (type=StateType)
 * //  	| (isFinal?='final')  'state' id=FullStateID
 * //  	| (isFinal?='final')  id=FullStateID
 * //  	| (isFinal?='final')
 * //  	
 * //  	| (type=StateType) 'state' id=FullStateID
 * //  	| (type=StateType) 'state'
 * //  	| (type=StateType) id=FullStateID
 * //  	| (type=StateType)
 * //  	
 * //  	| 'state' id=FullStateID
 * //  	| 'state'
 * //  		
 * //  	| id=FullStateID
 * //  )
 * ////change the datatype of label (from FullStateID) to STRING 
 * ////to prevent wrong parsing in this case: 
 * ////init A
 * ////final B
 * ////A --> B;
 * //  (label=STRING)? //	('['(signalRenamings+=Renaming ',')* signalRenamings+=Renaming']')?
 * //  (bodyText=STRING)? 
 *   
 * //   ('{' 
 * //	    (	 	('onentry' entryActions+=Action) 
 * //	  		| 	('oninner' innerActions+=Action) 
 * //	  		|   ('onexit' exitActions+= Action) 
 * //	  		| 	('suspension' suspensionTrigger=Action) // kein effect, kein delay, kein immediate
 * //	  		| 	(signals+=Signal) 
 * //	  		|   
 * //(regions+=Region ('||' regions+=Region)*)
 * 	  	 //)+
 * //   	'}')?
 * //   	(outgoingTransitions+=Transition)* 
 * //;
 * //Renaming returns sync::Renaming: oldID=STRING'/'newID=STRING;
 * //FullStateID : ((ID'@')?ID);
 * 	 //========================================================================================
 * 	 //===  									    ACTIONS  					               ===
 * 	 //========================================================================================
 * //Action returns sync::Action:
 * //	((isImmediate?='#')? (delay=INT ';')? (triggersAndEffects=STRING))
 * //| 
 * //	Transition
 * //	
 * //;
 * 
 * 	//========================================================================================
 * 	 //===  									    TRANSITION 					               ===
 * 	 //========================================================================================
 * 	
 * //Transition returns sync::Transition:
 * //
 * //	(sourceState=[sync::State|FullStateID])? 
 * //	//either reference existing state or create a new one or leave it blank (in that case, the transition belongs to the containing state)
 * //	//|({sync::State} name=FullStateID)
 * //	type=TransitionType
 * //	(targetState=[sync::State|FullStateID])
 * //	//|newTargetState=TransitionState )
 * //	( 'with' (isImmediate?='#')? (delay=INT)?
 * //		     (trigger=BooleanExpression)?
 * //		     ("/" (effects+=Effect (',')?)* )?
 * //			 
 * //	)?
 * //	(isHistory?=' history')?
 * //	';'
 * //;
 * ////TransitionState returns sync::State:
 * ////{sync::State}
 * ////	(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
 * ////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
 * ////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
 * ////  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
 * ////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
 * ////  	| ((isInitial?='init')(isFinal?='final')) 'state'
 * ////  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
 * ////  	| ((isInitial?='init')(isFinal?='final'))
 * ////  	
 * ////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
 * ////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
 * ////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
 * ////  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
 * ////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
 * ////  	| ((isFinal?='final')(isInitial?='init')) 'state'
 * ////  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
 * ////  	| ((isFinal?='final')(isInitial?='init'))
 * ////  	
 * ////  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
 * ////  	| (isInitial?='init') (type=StateType) 'state'
 * ////  	| (isInitial?='init') (type=StateType) id=FullStateID  
 * ////  	| (isInitial?='init') 'state' id=FullStateID
 * ////  	| (isInitial?='init') (type=StateType) 
 * ////  	| (isInitial?='init') 'state'
 * ////  	| (isInitial?='init') id=FullStateID
 * ////  	| (isInitial?='init')
 * ////  	
 * ////  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
 * ////  	| (isFinal?='final')  (type=StateType) 'state' 
 * ////  	| (isFinal?='final')  (type=StateType) id=FullStateID
 * ////  	| (isFinal?='final')  'state' id=FullStateID
 * ////  	| (isFinal?='final')  (type=StateType)
 * ////  	| (isFinal?='final')  'state' id=FullStateID
 * ////  	| (isFinal?='final')  id=FullStateID
 * ////  	| (isFinal?='final')
 * ////  	
 * ////  	| (type=StateType) 'state' id=FullStateID
 * ////  	| (type=StateType) 'state'
 * ////  	| (type=StateType) id=FullStateID
 * ////  	| (type=StateType)
 * ////  	
 * ////  	| 'state' id=FullStateID
 * ////  	| 'state'
 * ////  		
 * ////  	| id=FullStateID
 * ////  )
 * ////;
 * //	//========================================================================================
 * //	//===  									    VAR,SIG  					               ===
 * //	//========================================================================================
 * //
 * //ValuedObject returns sync::ValuedObject:
 * //	Signal | Variable
 * //;
 * //Variable returns sync::Variable:
 * //	'var' name=ID 
 * //	( 
 * //	  (': ' type=ValueType)//or type only, type being either pre-defined or hostcode
 * //	| (':=' initialValue=ID ': ' type=ValueType) // either initial value and type 
 * //	)  
 * //;
 * //Signal returns sync::Signal:
 * //		(	(isInput?='input')
 * //		|
 * //		 	(isOutput?='output')
 * //		|
 * //		 	((isInput?='input')(isOutput?='output')))
 * //	
 * //	// Signal names are of type QualifiedName because signals could have names like "main.fork", c.f. rvh_Program.kit
 * //	name=QualifiedName 
 * //	(':=' initialValue=SignalValue)? 
 * //	// after the initial value, either the type or the combine type has to come
 * //	// if it is not set, the default type PURE
 * //	( 
 * //		(': ' type=ValueType)
 * //	| 	(': combine' type=ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=STRING))
 * //	)?
 * //;
 * //SignalValue returns ecore::EString :(INT | ID | Boolean)+;
 * //QualifiedName :(ID".")*ID;
 * //enum StateType	returns sync::StateType	: NORMAL | CONDITIONAL='cond' | REFERENCE='ref' | TEXTUAL='textual'; 
 * //enum CombineOperator returns sync::CombineOperator: NONE | ADD='+' | MULT='*' | AND='AND'| OR='OR' |HOST='hostCombineOperator';
 * //enum ValueType returns sync::ValueType: PURE | BOOL='boolean' | UNSIGNED='unsigned' | INTEGER='integer' | FLOAT='float' | HOST='hostType';	
 * //enum TransitionType returns sync::TransitionType: WEAKABORT='-->' |  STRONGABORT='o->' | NORMALTERMINATION='>->'; 
 * ////==============================================================================
 * //// THE REST IS COPY/PASTE 'd from 
 * ////{@link de.cau.cs.kieler.synccharts..labelparser.ActionLabel.xtext}
 * ////==============================================================================
 * ////==============================================================================
 * //// Basic Actions
 * ////==============================================================================
 * //
 * //Action returns sync::Action:
 * //{sync::Action}
 * //    (isImmediate?='#')? (delay=INT)? ({sync::Action.triggersAndEffects+=current}(trigger=BooleanExpression)? ("/" (effects+=Effect (',')? )*)?)
 * //;        
 * //
 * //Effect returns sync::Effect: 
 * //    Emission | Assignment | HostCode;
 * //        
 * //Emission returns sync::Emission:
 * //    signal=[sync::Signal] 
 * //    (("(" newValue=ValueExpression ")")
 * //   |("(" newValue=BooleanExpression ")") )?;
 * //
 * //Assignment returns sync::Assignment:
 * //    variable=[sync::Variable] ":=" 
 * //     ( expression=ValueExpression
 * //     | expression=BooleanExpression);
 * //
 * //SignalReference returns sync::SignalReference:
 * //    signal = [sync::Signal|QualifiedName];
 * //
 * //VariableReference returns sync::VariableReference:
 * //    variable = [sync::Variable];
 * //
 * ////Signal returns sync::Signal:
 * ////    name=ID;
 * ////    
 * ////Variable returns sync::Variable:
 * ////    name=ID;
 * //
 * ////==============================================================================
 * //// Values
 * ////==============================================================================
 * //
 * //// redefine INT terminal to allow negative numbers
 * //terminal INT returns ecore::EInt:
 * // '-'?('0'..'9')+;
 * //
 * //IntValue returns sync::IntValue: 
 * //    value=INT;
 * //FloatValue returns sync::FloatValue:
 * //    value=Float ; 
 * //BooleanValue returns sync::BooleanValue :
 * //    value=Boolean;
 * //Value returns sync::Value:
 * //    IntValue | FloatValue | BooleanValue;
 * //
 * //// make sure the Float rule does not shadow the INT rule
 * //terminal Float returns ecore::EFloatObject : ((INT"."INT | INT("."INT)?("e"|"E")("+")?INT))"f"? | INT"f";
 * //terminal Boolean returns ecore::EBooleanObject : "true" | "false";
 * //
 * ////==============================================================================
 * //// Arithmetic Expressions
 * ////==============================================================================
 * //
 * //// Example: ?A  
 * //ValOperation returns sync::ComplexExpression:
 * //    operator=ValOperator subExpressions+=SignalReference;
 * //
 * //// everything that evaluates to a primitive number value
 * //ValueExpression returns sync::Expression:
 * //    PlusOperation;
 * //
 * //// Example: 42, 42.2, ?A, var1, (1+2*3)
 * //ParanthesedValueExpression returns sync::Expression:
 * //    IntValue | FloatValue | ValOperation | VariableReference | HostCode | '('PlusOperation')' | '('DivOperation')';
 * //
 * //// Example: 1 + 2, varA - ?B
 * //PlusOperation returns sync::Expression:
 * //    MultOrDivOperation ({sync::ComplexExpression.subExpressions+=current} operator=PlusOperator subExpressions+=MultOrDivOperation)*;
 * //
 * //MultOrDivOperation returns sync::Expression:
 * //    MultOperation | '('DivOperation')';
 * //
 * //// Example: 2 * 4, varA mod ?B
 * //MultOperation returns sync::Expression:
 * //    PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=MultOperator subExpressions+=PreOrNormalValueExpression)*;
 * //
 * //// Example: (2 / 4)
 * //// note: division has to have always parantheses because the '/' sign is also used for trigger/effect delimiter
 * //DivOperation returns sync::Expression:
 * //    PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=DivOperator subExpressions+=PreOrNormalValueExpression)*;
 * //
 * //// Example: pre (? A)
 * //PreArithmOperation returns sync::ComplexExpression:
 * //    operator=UnaryParanthesedOperator '('subExpressions+=ValOperation')';
 * //    
 * //PreOrNormalValueExpression returns sync::Expression:
 * //    PreArithmOperation | ParanthesedValueExpression;
 * //
 * ////==============================================================================
 * //// Boolean Expressions
 * ////==============================================================================
 * //
 * //// Example: 42 <= ?A
 * //CompareOperation returns sync::Expression:
 * //    ValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);     
 * //
 * //// Example: not A, not false, not (A or B)
 * //// at the latter we need the parans to indicate the right binding
 * //UnaryOperation returns sync::ComplexExpression:
 * //    operator=UnaryOperator subExpressions+=ParanthesedBooleanExpression;
 * //
 * //UnaryParanthesedOperation returns sync::ComplexExpression:
 * //    operator=UnaryParanthesedOperator '('subExpressions+=BooleanExpression ')';
 * //
 * //// Example: either negated or normal expression (with parantheses) 
 * //UnaryOrNormalExpression returns sync::Expression:
 * //    UnaryOperation | UnaryParanthesedOperation | ParanthesedBooleanExpression;
 * //
 * //// Example: A and B, not C and 42 <= ?D
 * //AndOperation returns sync::Expression:
 * //    UnaryOrNormalExpression ({sync::ComplexExpression.subExpressions+=current} operator=OperatorAnd subExpressions+=UnaryOrNormalExpression)*;
 * //
 * //// Example: A or B, C and B or D and not E 
 * //OrOperation returns sync::Expression:
 * //    AndOperation ({sync::ComplexExpression.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
 * //
 * //// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
 * //// note that the order of CompareOperation and SignalReference is important. This might be an Xtext bug...
 * //ParanthesedBooleanExpression returns sync::Expression:
 * //    BooleanValue | CompareOperation | SignalReference | HostCode | '('OrOperation')' ;
 * //
 * //// Example: not D and C or ?E = 42 or not (A and (B or C))
 * //BooleanExpression returns sync::Expression:
 * //    OrOperation;
 * //
 * ////==============================================================================
 * //// Operators
 * ////==============================================================================
 * //    
 * //enum OperatorType returns sync::OperatorType:
 * //    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="/" | MOD="mod" | VAL="?" | PRE="pre";
 * //
 * //enum ValOperator returns sync::OperatorType:
 * //    VAL="?";
 * //
 * //enum CompareOperator returns sync::OperatorType:
 * //    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
 * //
 * //// not A    
 * //enum UnaryOperator returns sync::OperatorType:
 * //    NOT="not";
 * //
 * //// pre(A)
 * //enum UnaryParanthesedOperator returns sync::OperatorType:
 * //    PRE="pre";
 * //
 * //enum OperatorOr returns sync::OperatorType:
 * //    OR="or";
 * //
 * //enum OperatorAnd returns sync::OperatorType:
 * //    AND="and";
 * //
 * //enum OperatorPre returns sync::OperatorType:
 * //    PRE="pre";
 * //
 * //enum PlusOperator returns sync::OperatorType:
 * //    ADD="+" | SUB="-";
 * //    
 * //enum MultOperator returns sync::OperatorType: 
 * //    MULT="*" | MOD="mod";
 * //
 * //enum DivOperator returns sync::OperatorType:  
 * //    DIV="/";
 * 
 * 
 * //==============================================================================
 * // Misc
 * ////==============================================================================
 * //    
 * //HostCode returns sync::HostCode:
 * //    //"'"code=STRING"'";
 * //    code=STRING ("(" type=ID ")")?;
 *
 **/

// "region"? id=ID? 
// 	  
// 	
// //	(	//variables+=Variable
// //	|	signals+=Signal
// 	 //|
// //		(innerStates+=State)?
// //	)+
protected class Region_Group extends GroupToken {
	
	public Region_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Region_IdAssignment_1(parent, this, 0, inst);
			case 1: return new Region_RegionKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRegionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "region"?
protected class Region_RegionKeyword_0 extends KeywordToken  {
	
	public Region_RegionKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionAccess().getRegionKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// id=ID?
protected class Region_IdAssignment_1 extends AssignmentToken  {
	
	public Region_IdAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Region_RegionKeyword_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRegionAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Region ****************/

}
