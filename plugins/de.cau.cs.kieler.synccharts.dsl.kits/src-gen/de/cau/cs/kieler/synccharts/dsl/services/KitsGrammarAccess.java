/*
* generated by Xtext
*/

package de.cau.cs.kieler.synccharts.dsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class KitsGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class RegionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Region");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRegionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		
		//Region returns sync::Region:
		//  "region"? id=ID?; 
		//      
		//	  
		//	
		////	(	//variables+=Variable
		////	|	signals+=Signal
		//	 //|
		////		(innerStates+=State)?
		////	)+
		//
		////State returns sync::State:
		////{sync::State}
		////	
		////(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
		////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
		////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
		////  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
		////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
		////  	| ((isInitial?='init')(isFinal?='final')) 'state'
		////  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
		////  	| ((isInitial?='init')(isFinal?='final'))
		////  	
		////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
		////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
		////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
		////  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
		////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
		////  	| ((isFinal?='final')(isInitial?='init')) 'state'
		////  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
		////  	| ((isFinal?='final')(isInitial?='init'))
		////  	
		////  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
		////  	| (isInitial?='init') (type=StateType) 'state'
		////  	| (isInitial?='init') (type=StateType) id=FullStateID  
		////  	| (isInitial?='init') 'state' id=FullStateID
		////  	| (isInitial?='init') (type=StateType) 
		////  	| (isInitial?='init') 'state'
		////  	| (isInitial?='init') id=FullStateID
		////  	| (isInitial?='init')
		////  	
		////  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
		////  	| (isFinal?='final')  (type=StateType) 'state' 
		////  	| (isFinal?='final')  (type=StateType) id=FullStateID
		////  	| (isFinal?='final')  'state' id=FullStateID
		////  	| (isFinal?='final')  (type=StateType)
		////  	| (isFinal?='final')  'state' id=FullStateID
		////  	| (isFinal?='final')  id=FullStateID
		////  	| (isFinal?='final')
		////  	
		////  	| (type=StateType) 'state' id=FullStateID
		////  	| (type=StateType) 'state'
		////  	| (type=StateType) id=FullStateID
		////  	| (type=StateType)
		////  	
		////  	| 'state' id=FullStateID
		////  	| 'state'
		////  		
		////  	| id=FullStateID
		////  )
		//////change the datatype of label (from FullStateID) to STRING 
		//////to prevent wrong parsing in this case: 
		//////init A
		//////final B
		//////A --> B;
		////  (label=STRING)? //	('['(signalRenamings+=Renaming ',')* signalRenamings+=Renaming']')?
		////  (bodyText=STRING)? 
		//  
		////   ('{' 
		////	    (	 	('onentry' entryActions+=Action) 
		////	  		| 	('oninner' innerActions+=Action) 
		////	  		|   ('onexit' exitActions+= Action) 
		////	  		| 	('suspension' suspensionTrigger=Action) // kein effect, kein delay, kein immediate
		////	  		| 	(signals+=Signal) 
		////	  		|   
		////(regions+=Region ('||' regions+=Region)*)
		//	  	 //)+
		////   	'}')?
		////   	(outgoingTransitions+=Transition)* 
		////;
		////Renaming returns sync::Renaming: oldID=STRING'/'newID=STRING;
		////FullStateID : ((ID'@')?ID);
		//	 //========================================================================================
		//	 //===  									    ACTIONS  					               ===
		//	 //========================================================================================
		////Action returns sync::Action:
		////	((isImmediate?='#')? (delay=INT ';')? (triggersAndEffects=STRING))
		////| 
		////	Transition
		////	
		////;
		//
		//	//========================================================================================
		//	 //===  									    TRANSITION 					               ===
		//	 //========================================================================================
		//	
		////Transition returns sync::Transition:
		////
		////	(sourceState=[sync::State|FullStateID])? 
		////	//either reference existing state or create a new one or leave it blank (in that case, the transition belongs to the containing state)
		////	//|({sync::State} name=FullStateID)
		////	type=TransitionType
		////	(targetState=[sync::State|FullStateID])
		////	//|newTargetState=TransitionState )
		////	( 'with' (isImmediate?='#')? (delay=INT)?
		////		     (trigger=BooleanExpression)?
		////		     ("/" (effects+=Effect (',')?)* )?
		////			 
		////	)?
		////	(isHistory?=' history')?
		////	';'
		////;
		//////TransitionState returns sync::State:
		//////{sync::State}
		//////	(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
		//////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
		//////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
		//////  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
		//////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
		//////  	| ((isInitial?='init')(isFinal?='final')) 'state'
		//////  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
		//////  	| ((isInitial?='init')(isFinal?='final'))
		//////  	
		//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
		//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
		//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
		//////  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
		//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
		//////  	| ((isFinal?='final')(isInitial?='init')) 'state'
		//////  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
		//////  	| ((isFinal?='final')(isInitial?='init'))
		//////  	
		//////  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
		//////  	| (isInitial?='init') (type=StateType) 'state'
		//////  	| (isInitial?='init') (type=StateType) id=FullStateID  
		//////  	| (isInitial?='init') 'state' id=FullStateID
		//////  	| (isInitial?='init') (type=StateType) 
		//////  	| (isInitial?='init') 'state'
		//////  	| (isInitial?='init') id=FullStateID
		//////  	| (isInitial?='init')
		//////  	
		//////  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
		//////  	| (isFinal?='final')  (type=StateType) 'state' 
		//////  	| (isFinal?='final')  (type=StateType) id=FullStateID
		//////  	| (isFinal?='final')  'state' id=FullStateID
		//////  	| (isFinal?='final')  (type=StateType)
		//////  	| (isFinal?='final')  'state' id=FullStateID
		//////  	| (isFinal?='final')  id=FullStateID
		//////  	| (isFinal?='final')
		//////  	
		//////  	| (type=StateType) 'state' id=FullStateID
		//////  	| (type=StateType) 'state'
		//////  	| (type=StateType) id=FullStateID
		//////  	| (type=StateType)
		//////  	
		//////  	| 'state' id=FullStateID
		//////  	| 'state'
		//////  		
		//////  	| id=FullStateID
		//////  )
		//////;
		////	//========================================================================================
		////	//===  									    VAR,SIG  					               ===
		////	//========================================================================================
		////
		////ValuedObject returns sync::ValuedObject:
		////	Signal | Variable
		////;
		////Variable returns sync::Variable:
		////	'var' name=ID 
		////	( 
		////	  (': ' type=ValueType)//or type only, type being either pre-defined or hostcode
		////	| (':=' initialValue=ID ': ' type=ValueType) // either initial value and type 
		////	)  
		////;
		////Signal returns sync::Signal:
		////		(	(isInput?='input')
		////		|
		////		 	(isOutput?='output')
		////		|
		////		 	((isInput?='input')(isOutput?='output')))
		////	
		////	// Signal names are of type QualifiedName because signals could have names like "main.fork", c.f. rvh_Program.kit
		////	name=QualifiedName 
		////	(':=' initialValue=SignalValue)? 
		////	// after the initial value, either the type or the combine type has to come
		////	// if it is not set, the default type PURE
		////	( 
		////		(': ' type=ValueType)
		////	| 	(': combine' type=ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=STRING))
		////	)?
		////;
		////SignalValue returns ecore::EString :(INT | ID | Boolean)+;
		////QualifiedName :(ID".")*ID;
		////enum StateType	returns sync::StateType	: NORMAL | CONDITIONAL='cond' | REFERENCE='ref' | TEXTUAL='textual'; 
		////enum CombineOperator returns sync::CombineOperator: NONE | ADD='+' | MULT='*' | AND='AND'| OR='OR' |HOST='hostCombineOperator';
		////enum ValueType returns sync::ValueType: PURE | BOOL='boolean' | UNSIGNED='unsigned' | INTEGER='integer' | FLOAT='float' | HOST='hostType';	
		////enum TransitionType returns sync::TransitionType: WEAKABORT='-->' |  STRONGABORT='o->' | NORMALTERMINATION='>->'; 
		//////==============================================================================
		////// THE REST IS COPY/PASTE 'd from 
		//////{@link de.cau.cs.kieler.synccharts..labelparser.ActionLabel.xtext}
		//////==============================================================================
		//////==============================================================================
		////// Basic Actions
		//////==============================================================================
		////
		////Action returns sync::Action:
		////{sync::Action}
		////    (isImmediate?='#')? (delay=INT)? ({sync::Action.triggersAndEffects+=current}(trigger=BooleanExpression)? ("/" (effects+=Effect (',')? )*)?)
		////;        
		////
		////Effect returns sync::Effect: 
		////    Emission | Assignment | HostCode;
		////        
		////Emission returns sync::Emission:
		////    signal=[sync::Signal] 
		////    (("(" newValue=ValueExpression ")")
		////   |("(" newValue=BooleanExpression ")") )?;
		////
		////Assignment returns sync::Assignment:
		////    variable=[sync::Variable] ":=" 
		////     ( expression=ValueExpression
		////     | expression=BooleanExpression);
		////
		////SignalReference returns sync::SignalReference:
		////    signal = [sync::Signal|QualifiedName];
		////
		////VariableReference returns sync::VariableReference:
		////    variable = [sync::Variable];
		////
		//////Signal returns sync::Signal:
		//////    name=ID;
		//////    
		//////Variable returns sync::Variable:
		//////    name=ID;
		////
		//////==============================================================================
		////// Values
		//////==============================================================================
		////
		////// redefine INT terminal to allow negative numbers
		////terminal INT returns ecore::EInt:
		//// '-'?('0'..'9')+;
		////
		////IntValue returns sync::IntValue: 
		////    value=INT;
		////FloatValue returns sync::FloatValue:
		////    value=Float ; 
		////BooleanValue returns sync::BooleanValue :
		////    value=Boolean;
		////Value returns sync::Value:
		////    IntValue | FloatValue | BooleanValue;
		////
		////// make sure the Float rule does not shadow the INT rule
		////terminal Float returns ecore::EFloatObject : ((INT"."INT | INT("."INT)?("e"|"E")("+")?INT))"f"? | INT"f";
		////terminal Boolean returns ecore::EBooleanObject : "true" | "false";
		////
		//////==============================================================================
		////// Arithmetic Expressions
		//////==============================================================================
		////
		////// Example: ?A  
		////ValOperation returns sync::ComplexExpression:
		////    operator=ValOperator subExpressions+=SignalReference;
		////
		////// everything that evaluates to a primitive number value
		////ValueExpression returns sync::Expression:
		////    PlusOperation;
		////
		////// Example: 42, 42.2, ?A, var1, (1+2*3)
		////ParanthesedValueExpression returns sync::Expression:
		////    IntValue | FloatValue | ValOperation | VariableReference | HostCode | '('PlusOperation')' | '('DivOperation')';
		////
		////// Example: 1 + 2, varA - ?B
		////PlusOperation returns sync::Expression:
		////    MultOrDivOperation ({sync::ComplexExpression.subExpressions+=current} operator=PlusOperator subExpressions+=MultOrDivOperation)*;
		////
		////MultOrDivOperation returns sync::Expression:
		////    MultOperation | '('DivOperation')';
		////
		////// Example: 2 * 4, varA mod ?B
		////MultOperation returns sync::Expression:
		////    PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=MultOperator subExpressions+=PreOrNormalValueExpression)*;
		////
		////// Example: (2 / 4)
		////// note: division has to have always parantheses because the '/' sign is also used for trigger/effect delimiter
		////DivOperation returns sync::Expression:
		////    PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=DivOperator subExpressions+=PreOrNormalValueExpression)*;
		////
		////// Example: pre (? A)
		////PreArithmOperation returns sync::ComplexExpression:
		////    operator=UnaryParanthesedOperator '('subExpressions+=ValOperation')';
		////    
		////PreOrNormalValueExpression returns sync::Expression:
		////    PreArithmOperation | ParanthesedValueExpression;
		////
		//////==============================================================================
		////// Boolean Expressions
		//////==============================================================================
		////
		////// Example: 42 <= ?A
		////CompareOperation returns sync::Expression:
		////    ValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);     
		////
		////// Example: not A, not false, not (A or B)
		////// at the latter we need the parans to indicate the right binding
		////UnaryOperation returns sync::ComplexExpression:
		////    operator=UnaryOperator subExpressions+=ParanthesedBooleanExpression;
		////
		////UnaryParanthesedOperation returns sync::ComplexExpression:
		////    operator=UnaryParanthesedOperator '('subExpressions+=BooleanExpression ')';
		////
		////// Example: either negated or normal expression (with parantheses) 
		////UnaryOrNormalExpression returns sync::Expression:
		////    UnaryOperation | UnaryParanthesedOperation | ParanthesedBooleanExpression;
		////
		////// Example: A and B, not C and 42 <= ?D
		////AndOperation returns sync::Expression:
		////    UnaryOrNormalExpression ({sync::ComplexExpression.subExpressions+=current} operator=OperatorAnd subExpressions+=UnaryOrNormalExpression)*;
		////
		////// Example: A or B, C and B or D and not E 
		////OrOperation returns sync::Expression:
		////    AndOperation ({sync::ComplexExpression.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
		////
		////// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
		////// note that the order of CompareOperation and SignalReference is important. This might be an Xtext bug...
		////ParanthesedBooleanExpression returns sync::Expression:
		////    BooleanValue | CompareOperation | SignalReference | HostCode | '('OrOperation')' ;
		////
		////// Example: not D and C or ?E = 42 or not (A and (B or C))
		////BooleanExpression returns sync::Expression:
		////    OrOperation;
		////
		//////==============================================================================
		////// Operators
		//////==============================================================================
		////    
		////enum OperatorType returns sync::OperatorType:
		////    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="/" | MOD="mod" | VAL="?" | PRE="pre";
		////
		////enum ValOperator returns sync::OperatorType:
		////    VAL="?";
		////
		////enum CompareOperator returns sync::OperatorType:
		////    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
		////
		////// not A    
		////enum UnaryOperator returns sync::OperatorType:
		////    NOT="not";
		////
		////// pre(A)
		////enum UnaryParanthesedOperator returns sync::OperatorType:
		////    PRE="pre";
		////
		////enum OperatorOr returns sync::OperatorType:
		////    OR="or";
		////
		////enum OperatorAnd returns sync::OperatorType:
		////    AND="and";
		////
		////enum OperatorPre returns sync::OperatorType:
		////    PRE="pre";
		////
		////enum PlusOperator returns sync::OperatorType:
		////    ADD="+" | SUB="-";
		////    
		////enum MultOperator returns sync::OperatorType: 
		////    MULT="*" | MOD="mod";
		////
		////enum DivOperator returns sync::OperatorType:  
		////    DIV="/";
		//
		//
		////==============================================================================
		//// Misc
		//////==============================================================================
		////    
		////HostCode returns sync::HostCode:
		////    //"'"code=STRING"'";
		////    code=STRING ("(" type=ID ")")?;
		public ParserRule getRule() { return rule; }

		//"region"? id=ID? 
		//	  
		//	
		////	(	//variables+=Variable
		////	|	signals+=Signal
		//	 //|
		////		(innerStates+=State)?
		////	)+
		public Group getGroup() { return cGroup; }

		//"region"?
		public Keyword getRegionKeyword_0() { return cRegionKeyword_0; }

		//id=ID?
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_1_0() { return cIdIDTerminalRuleCall_1_0; }
	}
	
	
	private RegionElements pRegion;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public KitsGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Region returns sync::Region:
	//  "region"? id=ID?; 
	//      
	//	  
	//	
	////	(	//variables+=Variable
	////	|	signals+=Signal
	//	 //|
	////		(innerStates+=State)?
	////	)+
	//
	////State returns sync::State:
	////{sync::State}
	////	
	////(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
	////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
	////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
	////  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
	////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
	////  	| ((isInitial?='init')(isFinal?='final')) 'state'
	////  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
	////  	| ((isInitial?='init')(isFinal?='final'))
	////  	
	////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
	////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
	////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
	////  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
	////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
	////  	| ((isFinal?='final')(isInitial?='init')) 'state'
	////  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
	////  	| ((isFinal?='final')(isInitial?='init'))
	////  	
	////  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
	////  	| (isInitial?='init') (type=StateType) 'state'
	////  	| (isInitial?='init') (type=StateType) id=FullStateID  
	////  	| (isInitial?='init') 'state' id=FullStateID
	////  	| (isInitial?='init') (type=StateType) 
	////  	| (isInitial?='init') 'state'
	////  	| (isInitial?='init') id=FullStateID
	////  	| (isInitial?='init')
	////  	
	////  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
	////  	| (isFinal?='final')  (type=StateType) 'state' 
	////  	| (isFinal?='final')  (type=StateType) id=FullStateID
	////  	| (isFinal?='final')  'state' id=FullStateID
	////  	| (isFinal?='final')  (type=StateType)
	////  	| (isFinal?='final')  'state' id=FullStateID
	////  	| (isFinal?='final')  id=FullStateID
	////  	| (isFinal?='final')
	////  	
	////  	| (type=StateType) 'state' id=FullStateID
	////  	| (type=StateType) 'state'
	////  	| (type=StateType) id=FullStateID
	////  	| (type=StateType)
	////  	
	////  	| 'state' id=FullStateID
	////  	| 'state'
	////  		
	////  	| id=FullStateID
	////  )
	//////change the datatype of label (from FullStateID) to STRING 
	//////to prevent wrong parsing in this case: 
	//////init A
	//////final B
	//////A --> B;
	////  (label=STRING)? //	('['(signalRenamings+=Renaming ',')* signalRenamings+=Renaming']')?
	////  (bodyText=STRING)? 
	//  
	////   ('{' 
	////	    (	 	('onentry' entryActions+=Action) 
	////	  		| 	('oninner' innerActions+=Action) 
	////	  		|   ('onexit' exitActions+= Action) 
	////	  		| 	('suspension' suspensionTrigger=Action) // kein effect, kein delay, kein immediate
	////	  		| 	(signals+=Signal) 
	////	  		|   
	////(regions+=Region ('||' regions+=Region)*)
	//	  	 //)+
	////   	'}')?
	////   	(outgoingTransitions+=Transition)* 
	////;
	////Renaming returns sync::Renaming: oldID=STRING'/'newID=STRING;
	////FullStateID : ((ID'@')?ID);
	//	 //========================================================================================
	//	 //===  									    ACTIONS  					               ===
	//	 //========================================================================================
	////Action returns sync::Action:
	////	((isImmediate?='#')? (delay=INT ';')? (triggersAndEffects=STRING))
	////| 
	////	Transition
	////	
	////;
	//
	//	//========================================================================================
	//	 //===  									    TRANSITION 					               ===
	//	 //========================================================================================
	//	
	////Transition returns sync::Transition:
	////
	////	(sourceState=[sync::State|FullStateID])? 
	////	//either reference existing state or create a new one or leave it blank (in that case, the transition belongs to the containing state)
	////	//|({sync::State} name=FullStateID)
	////	type=TransitionType
	////	(targetState=[sync::State|FullStateID])
	////	//|newTargetState=TransitionState )
	////	( 'with' (isImmediate?='#')? (delay=INT)?
	////		     (trigger=BooleanExpression)?
	////		     ("/" (effects+=Effect (',')?)* )?
	////			 
	////	)?
	////	(isHistory?=' history')?
	////	';'
	////;
	//////TransitionState returns sync::State:
	//////{sync::State}
	//////	(	  ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state' id=FullStateID
	//////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) 'state'
	//////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType) id=FullStateID
	//////  	| ((isInitial?='init')(isFinal?='final')) 'state' id=FullStateID
	//////  	| ((isInitial?='init')(isFinal?='final')) (type=StateType)
	//////  	| ((isInitial?='init')(isFinal?='final')) 'state'
	//////  	| ((isInitial?='init')(isFinal?='final')) id=FullStateID
	//////  	| ((isInitial?='init')(isFinal?='final'))
	//////  	
	//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state' id=FullStateID
	//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) 'state'
	//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType) id=FullStateID
	//////  	| ((isFinal?='final')(isInitial?='init')) 'state' id=FullStateID
	//////  	| ((isFinal?='final')(isInitial?='init')) (type=StateType)
	//////  	| ((isFinal?='final')(isInitial?='init')) 'state'
	//////  	| ((isFinal?='final')(isInitial?='init')) id=FullStateID
	//////  	| ((isFinal?='final')(isInitial?='init'))
	//////  	
	//////  	| (isInitial?='init') (type=StateType) 'state' id=FullStateID
	//////  	| (isInitial?='init') (type=StateType) 'state'
	//////  	| (isInitial?='init') (type=StateType) id=FullStateID  
	//////  	| (isInitial?='init') 'state' id=FullStateID
	//////  	| (isInitial?='init') (type=StateType) 
	//////  	| (isInitial?='init') 'state'
	//////  	| (isInitial?='init') id=FullStateID
	//////  	| (isInitial?='init')
	//////  	
	//////  	| (isFinal?='final')  (type=StateType) 'state' id=FullStateID
	//////  	| (isFinal?='final')  (type=StateType) 'state' 
	//////  	| (isFinal?='final')  (type=StateType) id=FullStateID
	//////  	| (isFinal?='final')  'state' id=FullStateID
	//////  	| (isFinal?='final')  (type=StateType)
	//////  	| (isFinal?='final')  'state' id=FullStateID
	//////  	| (isFinal?='final')  id=FullStateID
	//////  	| (isFinal?='final')
	//////  	
	//////  	| (type=StateType) 'state' id=FullStateID
	//////  	| (type=StateType) 'state'
	//////  	| (type=StateType) id=FullStateID
	//////  	| (type=StateType)
	//////  	
	//////  	| 'state' id=FullStateID
	//////  	| 'state'
	//////  		
	//////  	| id=FullStateID
	//////  )
	//////;
	////	//========================================================================================
	////	//===  									    VAR,SIG  					               ===
	////	//========================================================================================
	////
	////ValuedObject returns sync::ValuedObject:
	////	Signal | Variable
	////;
	////Variable returns sync::Variable:
	////	'var' name=ID 
	////	( 
	////	  (': ' type=ValueType)//or type only, type being either pre-defined or hostcode
	////	| (':=' initialValue=ID ': ' type=ValueType) // either initial value and type 
	////	)  
	////;
	////Signal returns sync::Signal:
	////		(	(isInput?='input')
	////		|
	////		 	(isOutput?='output')
	////		|
	////		 	((isInput?='input')(isOutput?='output')))
	////	
	////	// Signal names are of type QualifiedName because signals could have names like "main.fork", c.f. rvh_Program.kit
	////	name=QualifiedName 
	////	(':=' initialValue=SignalValue)? 
	////	// after the initial value, either the type or the combine type has to come
	////	// if it is not set, the default type PURE
	////	( 
	////		(': ' type=ValueType)
	////	| 	(': combine' type=ValueType 'with' (combineOperator=CombineOperator|hostCombineOperator=STRING))
	////	)?
	////;
	////SignalValue returns ecore::EString :(INT | ID | Boolean)+;
	////QualifiedName :(ID".")*ID;
	////enum StateType	returns sync::StateType	: NORMAL | CONDITIONAL='cond' | REFERENCE='ref' | TEXTUAL='textual'; 
	////enum CombineOperator returns sync::CombineOperator: NONE | ADD='+' | MULT='*' | AND='AND'| OR='OR' |HOST='hostCombineOperator';
	////enum ValueType returns sync::ValueType: PURE | BOOL='boolean' | UNSIGNED='unsigned' | INTEGER='integer' | FLOAT='float' | HOST='hostType';	
	////enum TransitionType returns sync::TransitionType: WEAKABORT='-->' |  STRONGABORT='o->' | NORMALTERMINATION='>->'; 
	//////==============================================================================
	////// THE REST IS COPY/PASTE 'd from 
	//////{@link de.cau.cs.kieler.synccharts..labelparser.ActionLabel.xtext}
	//////==============================================================================
	//////==============================================================================
	////// Basic Actions
	//////==============================================================================
	////
	////Action returns sync::Action:
	////{sync::Action}
	////    (isImmediate?='#')? (delay=INT)? ({sync::Action.triggersAndEffects+=current}(trigger=BooleanExpression)? ("/" (effects+=Effect (',')? )*)?)
	////;        
	////
	////Effect returns sync::Effect: 
	////    Emission | Assignment | HostCode;
	////        
	////Emission returns sync::Emission:
	////    signal=[sync::Signal] 
	////    (("(" newValue=ValueExpression ")")
	////   |("(" newValue=BooleanExpression ")") )?;
	////
	////Assignment returns sync::Assignment:
	////    variable=[sync::Variable] ":=" 
	////     ( expression=ValueExpression
	////     | expression=BooleanExpression);
	////
	////SignalReference returns sync::SignalReference:
	////    signal = [sync::Signal|QualifiedName];
	////
	////VariableReference returns sync::VariableReference:
	////    variable = [sync::Variable];
	////
	//////Signal returns sync::Signal:
	//////    name=ID;
	//////    
	//////Variable returns sync::Variable:
	//////    name=ID;
	////
	//////==============================================================================
	////// Values
	//////==============================================================================
	////
	////// redefine INT terminal to allow negative numbers
	////terminal INT returns ecore::EInt:
	//// '-'?('0'..'9')+;
	////
	////IntValue returns sync::IntValue: 
	////    value=INT;
	////FloatValue returns sync::FloatValue:
	////    value=Float ; 
	////BooleanValue returns sync::BooleanValue :
	////    value=Boolean;
	////Value returns sync::Value:
	////    IntValue | FloatValue | BooleanValue;
	////
	////// make sure the Float rule does not shadow the INT rule
	////terminal Float returns ecore::EFloatObject : ((INT"."INT | INT("."INT)?("e"|"E")("+")?INT))"f"? | INT"f";
	////terminal Boolean returns ecore::EBooleanObject : "true" | "false";
	////
	//////==============================================================================
	////// Arithmetic Expressions
	//////==============================================================================
	////
	////// Example: ?A  
	////ValOperation returns sync::ComplexExpression:
	////    operator=ValOperator subExpressions+=SignalReference;
	////
	////// everything that evaluates to a primitive number value
	////ValueExpression returns sync::Expression:
	////    PlusOperation;
	////
	////// Example: 42, 42.2, ?A, var1, (1+2*3)
	////ParanthesedValueExpression returns sync::Expression:
	////    IntValue | FloatValue | ValOperation | VariableReference | HostCode | '('PlusOperation')' | '('DivOperation')';
	////
	////// Example: 1 + 2, varA - ?B
	////PlusOperation returns sync::Expression:
	////    MultOrDivOperation ({sync::ComplexExpression.subExpressions+=current} operator=PlusOperator subExpressions+=MultOrDivOperation)*;
	////
	////MultOrDivOperation returns sync::Expression:
	////    MultOperation | '('DivOperation')';
	////
	////// Example: 2 * 4, varA mod ?B
	////MultOperation returns sync::Expression:
	////    PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=MultOperator subExpressions+=PreOrNormalValueExpression)*;
	////
	////// Example: (2 / 4)
	////// note: division has to have always parantheses because the '/' sign is also used for trigger/effect delimiter
	////DivOperation returns sync::Expression:
	////    PreOrNormalValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=DivOperator subExpressions+=PreOrNormalValueExpression)*;
	////
	////// Example: pre (? A)
	////PreArithmOperation returns sync::ComplexExpression:
	////    operator=UnaryParanthesedOperator '('subExpressions+=ValOperation')';
	////    
	////PreOrNormalValueExpression returns sync::Expression:
	////    PreArithmOperation | ParanthesedValueExpression;
	////
	//////==============================================================================
	////// Boolean Expressions
	//////==============================================================================
	////
	////// Example: 42 <= ?A
	////CompareOperation returns sync::Expression:
	////    ValueExpression ({sync::ComplexExpression.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);     
	////
	////// Example: not A, not false, not (A or B)
	////// at the latter we need the parans to indicate the right binding
	////UnaryOperation returns sync::ComplexExpression:
	////    operator=UnaryOperator subExpressions+=ParanthesedBooleanExpression;
	////
	////UnaryParanthesedOperation returns sync::ComplexExpression:
	////    operator=UnaryParanthesedOperator '('subExpressions+=BooleanExpression ')';
	////
	////// Example: either negated or normal expression (with parantheses) 
	////UnaryOrNormalExpression returns sync::Expression:
	////    UnaryOperation | UnaryParanthesedOperation | ParanthesedBooleanExpression;
	////
	////// Example: A and B, not C and 42 <= ?D
	////AndOperation returns sync::Expression:
	////    UnaryOrNormalExpression ({sync::ComplexExpression.subExpressions+=current} operator=OperatorAnd subExpressions+=UnaryOrNormalExpression)*;
	////
	////// Example: A or B, C and B or D and not E 
	////OrOperation returns sync::Expression:
	////    AndOperation ({sync::ComplexExpression.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
	////
	////// Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
	////// note that the order of CompareOperation and SignalReference is important. This might be an Xtext bug...
	////ParanthesedBooleanExpression returns sync::Expression:
	////    BooleanValue | CompareOperation | SignalReference | HostCode | '('OrOperation')' ;
	////
	////// Example: not D and C or ?E = 42 or not (A and (B or C))
	////BooleanExpression returns sync::Expression:
	////    OrOperation;
	////
	//////==============================================================================
	////// Operators
	//////==============================================================================
	////    
	////enum OperatorType returns sync::OperatorType:
	////    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="/" | MOD="mod" | VAL="?" | PRE="pre";
	////
	////enum ValOperator returns sync::OperatorType:
	////    VAL="?";
	////
	////enum CompareOperator returns sync::OperatorType:
	////    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
	////
	////// not A    
	////enum UnaryOperator returns sync::OperatorType:
	////    NOT="not";
	////
	////// pre(A)
	////enum UnaryParanthesedOperator returns sync::OperatorType:
	////    PRE="pre";
	////
	////enum OperatorOr returns sync::OperatorType:
	////    OR="or";
	////
	////enum OperatorAnd returns sync::OperatorType:
	////    AND="and";
	////
	////enum OperatorPre returns sync::OperatorType:
	////    PRE="pre";
	////
	////enum PlusOperator returns sync::OperatorType:
	////    ADD="+" | SUB="-";
	////    
	////enum MultOperator returns sync::OperatorType: 
	////    MULT="*" | MOD="mod";
	////
	////enum DivOperator returns sync::OperatorType:  
	////    DIV="/";
	//
	//
	////==============================================================================
	//// Misc
	//////==============================================================================
	////    
	////HostCode returns sync::HostCode:
	////    //"'"code=STRING"'";
	////    code=STRING ("(" type=ID ")")?;
	public RegionElements getRegionAccess() {
		return (pRegion != null) ? pRegion : (pRegion = new RegionElements());
	}
	
	public ParserRule getRegionRule() {
		return getRegionAccess().getRule();
	}

	//terminal ID:
	//  "^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//  "0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//  "\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" |
	//  "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//  "/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//  "//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//  (" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//  .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
