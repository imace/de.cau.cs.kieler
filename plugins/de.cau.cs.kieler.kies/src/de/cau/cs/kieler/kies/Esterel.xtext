grammar de.cau.cs.kieler.kies.Esterel with de.cau.cs.kieler.core.kexpressions.KExpressions

generate esterel "http://www.cau.de/cs/kieler/kies/Esterel"
import "platform:/resource/de.cau.cs.kieler.core.kexpressions/model/kexpressions.ecore" as kexpressions
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

//	root rule. an esterel file can contain multiple modules
Program hidden(Esterel_SL_Comment, Esterel_ML_Comment, WS):
	(modules+=Module)*;

	// a module consists of an interface and a body
// !-(module)
Module:
	"module" name=ID ":" (interface=ModuleInterface)? body=ModuleBody end=EndModule;

EndModule:
	"end" "module"
	| "."; //deprecated
ModuleBody:
	statements+=Statement;
	// -!

//            Interface Declarations
// ----------------------------------------------
ModuleInterface:
	(intSignalDecls+=InterfaceSignalDecl
	| intTypeDecls+=TypeDecl
	| intSensorDecls+=SensorDecl
	| intConstantDecls+=ConstantDecls
	| intRelationDecls+=RelationDecl
	| intTaskDecls+=TaskDecl
	| intFunctionDecls+=FunctionDecl
	| intProcedureDecls+=ProcedureDecl)+;

	// overwrite to add the EsterelTypeIdentifier
ChannelDescription:
	(":" type=EsterelTypeIdentifier)
	| ("(" type=EsterelTypeIdentifier ")")
	| (":=" expression=Expression ":" type=EsterelTypeIdentifier);

	// overwrite to allow function references for signal declarations
EsterelTypeIdentifier returns kexpressions::TypeIdentifier:
	type=ValueType
	| typeID=ID
	| {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function|ID] |
	operator=CombineOperator));

	// overwrite to allow type definitions in a specific module
TypeIdentifier:
	type=ValueType
	| typeID=ID
	| ("combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator)
	| {EsterelType} estType=[Type|ID];

	// ==> Local Signal Declaration
// !-(localsignal) -------------------------------------
LocalSignalDecl:
	"signal" signalList=LocalSignalList "in" statement=Statement "end" (optEnd="signal")?;

LocalSignalList:
	{LocalSignal} signal+=ISignal
	("," signal+=ISignal)*;
	// -!

// ==> Sensor
// -------------------------------------
SensorDecl:
	"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";";

SensorWithType:
	(sensor=Sensor (":" type=TypeIdentifier)) | (sensor=Sensor "(" type=TypeIdentifier ")");

Sensor returns kexpressions::ISignal:
	name=ID;

	// ==> Relations
// -------------------------------------
RelationDecl:
	{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";";

RelationType:
	RelationImplication | RelationIncompatibility;

RelationImplication:
	first=[kexpressions::ISignal|ID] type="=>" second=[kexpressions::ISignal|ID];

RelationIncompatibility:
	incomp+=[kexpressions::ISignal|ID] type="#" incomp+=[kexpressions::ISignal|ID] ("#"
	incomp+=[kexpressions::ISignal|ID])*;

	// ==> Types
// -------------------------------------
TypeDecl:
	"type" types+=Type ("," types+=Type)* ";";

Type:
	name=ID;

	// ==> Constants
// -------------------------------------
ConstantDecls:
	"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";";

OneTypeConstantDecls:
	constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier;

ConstantWithValue:
	constant=Constant ("=" value=ConstantAtom)?;

Constant returns kexpressions::ValuedObject:
	{Constant} name=ID;

ConstantAtom:
	INT | ConstantLiteral;

ConstantLiteral:
	Float | Boolean | ID | STRING;

	// ==> Functions
// -------------------------------------
FunctionDecl:
	"function" functions+=Function ("," functions+=Function)* ";";

Function:
	name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier;

	// ==> Procedures
ProcedureDecl:
	"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";";

Procedure:
	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
	idList2+=TypeIdentifier)*)? ")";

	// ==> Tasks
TaskDecl:
	"task" tasks+=Task ("," tasks+=Task)* ";";

Task:
	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
	idList2+=TypeIdentifier)*)? ")";

	// ==============================================
// ===            B.4 Statements              ===
// ==============================================
// !-(parallel)
Statement:
	Sequence ({Parallel.list+=current} "||" list+=Sequence)*;

	// -!
AtomicStatement returns Statement:
	Abort | Assignment | Await | Block | ProcCall | Do | Emit | EveryDo | Exit | Exec | Halt | IfTest | LocalSignalDecl |
	Loop | Nothing | Pause | Present | Repeat | Run | Suspend | Sustain | Trap | LocalVariable | VarStatement | WeakAbort;

	// --> B.4.1 Control Flow Operators <--	
// !-(sequence)
Sequence returns Statement:
	AtomicStatement ({Sequence.list+=current} ";" list+=AtomicStatement)* ";"?;
	// -!
Block:
	"[" statement=Statement "]";

VarStatement returns Statement:
	vardecl=IVariable;

	// Assignment
// !-(assign) -------------------------------------
Assignment:
	var=[kexpressions::IVariable|ID] ":=" expr=Expression;
	// -!

// !-(abort) --> B.4.2 abort: Strong Preemption
// -------------------------------------
Abort:
	"abort" statement=Statement "when" body=AbortBody;

AbortBody:
	AbortInstance | AbortCase;

AbortInstance:
	delay=DelayExpr ("do" statement=Statement "end" (optEnd="abort")?)?;

AbortCase:
	cases+=AbortCaseSingle (cases+=AbortCaseSingle)* "end" (optEnd="abort")?;

AbortCaseSingle:
	"case" delay=DelayExpr ("do" statement=Statement)?;
	// -!

// --> B.4.25 weak abort: Weak Preemption
// -------------------------------------
WeakAbort returns Abort:
	{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody;

WeakAbortBody:
	WeakAbortInstance | WeakAbortCase;

WeakAbortEnd:
	{WeakAbortEnd} "end" (optEnd=WeakAbortEndAlt)?;

WeakAbortEndAlt:
	(end="weak")? endA="abort";

WeakAbortInstance returns AbortInstance:
	{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?;

WeakAbortCase returns AbortCase:
	{WeakAbortCase} cases+=AbortCaseSingle (cases+=AbortCaseSingle)* end=WeakAbortEnd;

	// --> B.4.3 await: Strong Preemption
// !-(await) -------------------------------------
Await:
	"await" body=AwaitBody;

AwaitBody:
	AwaitInstance | AwaitCase;

AwaitInstance:
	delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?;

AwaitCase:
	cases+=AbortCaseSingle (cases+=AbortCaseSingle)* end=AwaitEnd;

AwaitEnd:
	"end" "await"?;
	// -!

// --> B.4.4 call: Procedure Call
// -------------------------------------
ProcCall:
	"call" proc=[Procedure|ID] "(" (varList+=[kexpressions::IVariable|ID] ("," varList+=[kexpressions::IVariable|ID])*)?
	")"
	"(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";

	// --> B.4.5 do-upto: Conditional Iteration (deprecated)
// --> B.4.6 do-watching: Strong Preemption (deprecated)
// !-(doupto) -------------------------------------
Do:
	"do" statement=Statement (end=DoUpto | end=DoWatching);

DoUpto:
	"upto" expr=DelayExpr;

DoWatching:
	"watching" delay=DelayExpr (end=DoWatchingEnd)?;

DoWatchingEnd:
	"timeout" statement=Statement "end" (optEnd="timeout")?;
	// -!

// --> B.4.7 emit: Signal Emission <--
// !-(emit)2 -------------------------------------
Emit:
	"emit" ((signal=[kexpressions::ISignal|ID]) | tick=Tick) ("(" expr=Expression ")")?;
	// -!
// --> B.4.8 every-do: Conditional Iteration
// !-(every)-------------------------------------
EveryDo:
	"every" delay=DelayExpr "do" statement=Statement "end" (optEnd="every")?;
	// -!

// --> B.4.10 exit: Trap Exit
// !-(exit) -------------------------------------
Exit:
	"exit" trap=[TrapDecl|ID] ("(" expression=Expression ")")?;
	// -!
// --> B.4.11 halt: Wait Forever
// !-(halt) -------------------------------------
Halt:
	{Halt} "halt";
	// -!
// --> B.4.12: if: Conditional for Data
// !-(if)-------------------------------------
IfTest:
	"if" expr=Expression (thenPart=ThenPart)? (elsif+=ElsIf)* (elsePart=ElsePart)? "end" (optEnd="if")?;

ElsIf:
	"elsif" expr=Expression (thenPart=ThenPart)?;

ThenPart:
	"then" statement=Statement;

ElsePart:
	"else" statement=Statement;
	// -!
// --> B.4.13 loop: Infinite Loop
// --> B.4.14 loop-each: Condition Iteration
// !-(loop)-------------------------------------
Loop:
	"loop" body=LoopBody (end1=EndLoop | end=LoopEach);

EndLoop:
	"end" "loop"?;

LoopEach:
	"each" LoopDelay;

LoopDelay:
	delay=DelayExpr;

LoopBody:
	statement=Statement;
	// -!
// --> B.4.15 nothing: No Operation
// !-(nothing) -------------------------------------
Nothing:
	"nothing" {Nothing};
	// -!
// --> B.4.16 pause: Unit Delay
// !-(pause) -------------------------------------
Pause:
	"pause" {Pause};
	// -!
// --> B.4.17 present: Conditional for Signals
// !-(present) -------------------------------------
Present:
	"present" body=PresentBody (elsePart=ElsePart)? "end" (optEnd="present")?;

PresentBody:
	PresentEventBody | PresentCaseList;

PresentEventBody:
	event=PresentEvent (thenPart=ThenPart)?;

PresentCaseList:
	cases+=PresentCase (cases+=PresentCase)*;

PresentCase:
	"case" event=PresentEvent ("do" statement=Statement)?;

PresentEvent:
	expression=SignalExpression | "[" expression=SignalExpression "]" | tick=Tick;
	// -!

// --> B.4.18 repeat: Iterate a Fixed Number of Times
// -------------------------------------
Repeat:
	(positive?="positive")? "repeat" expression=Expression "times" statement=Statement "end" (optEnd="repeat")?;

	// --> B.4.19 run: Module Instantiation
// -------------------------------------
Run:
	"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
	"]")?; //deprecated


// Renamings
// -------------------------------------
ModuleRenaming:
	module=[Module|ID] | (newName=ID "/" module=[Module|ID]);

RenamingList:
	list+=Renaming (";" list+=Renaming)*;

Renaming:
	"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)*
	| "constant" renamings+=ConstantRenaming ("," renamings+=ConstantRenaming)*
	| "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)*
	| "procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)*
	| "task" renamings+=TaskRenaming ("," renamings+=TaskRenaming)*
	| "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*;

TypeRenaming:
	(newName=[Type|ID] | newType=ValueType) "/" oldName=[Type|ID];

ConstantRenaming:
	(newName=[kexpressions::ValuedObject|ID] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject|ID];

FunctionRenaming:
	(newName=[Function|ID] | newFunc=BuildInFunction) "/" oldName=[Function|ID];

ProcedureRenaming:
	newName=[Procedure|ID] "/" oldName=[Procedure|ID];

TaskRenaming:
	newName=[Task|ID] "/" oldName=[Task|ID];

SignalRenaming:
	(newName=[kexpressions::ISignal|ID] | "tick") "/" oldName=[kexpressions::ISignal|ID];

	// renamings can also rename build in types and functions
BuildInFunction:
	"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or";

	// --> B.4.21 suspend: Preemption with State Freeze
// !-(suspend)-------------------------------------
Suspend:
	"suspend" statement=Statement "when" delay=DelayExpr;
	// -!
// --> B.4.22 sustain: Emit a Signal Indefinitely
// !-(sustain) -------------------------------------
Sustain:
	"sustain" ((signal=[kexpressions::ISignal|ID]) | tick=Tick) ("(" expression=Expression ")")?;
	// -!
// --> B.4.23 trap: TrapDeclaration and Handling
// !-(trap)-------------------------------------
Trap:
	"trap" trapDeclList=TrapDeclList "in" statement=Statement
	(trapHandler+=TrapHandler)* "end" (optEnd="trap")?;

TrapDeclList:
	trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*;

TrapDecl returns kexpressions::ISignal:
	{TrapDecl} name=ID channelDescr=(ChannelDescription)?;

TrapHandler:
	"handle" trapExpr=TrapExpr "do" statement=Statement;
	// -!
// --> B.4.24 var: Local Variable Declaration
// !-(localvariable) -------------------------------------
LocalVariable:
	var=InterfaceVariableDecl "in" statement=Statement "end" (optEnd="var")?;
	// -!
// ==============================================
// ===            B.3 Expressions             ===
// ==============================================

// esterel is a bit richer than what is provided by kexpressions. These rules are introduced here
// care about order of the rules! 
AtomicExpression returns kexpressions::Expression:
	FunctionExpression
	| TrapExpression
	| BooleanValue
	| ValuedObjectTestExpression
	| TextExpression
	| '(' BooleanExpression ')'
	| ConstantExpression;

TrapExpression returns kexpressions::Expression:
	{TrapExpression} "??" trap=[kexpressions::ISignal|ID];

FunctionExpression returns kexpressions::Expression:
	{FunctionExpression} function=[Function|ID] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";

ConstantExpression returns kexpressions::Expression:
	{ConstantExpression} (constant=[Constant|ID] | value=ConstantAtom);

	// --> B.3.5 Trap Expressions <--
// -------------------------------------
TrapExpr returns kexpressions::Expression:
	SignalExpression;

	// --> B.3.3 Signal Expressions <--
// -------------------------------------
SignalExpression returns kexpressions::Expression:
	SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
	subExpressions+=SignalAndExpression)*;

SignalAndExpression returns kexpressions::Expression:
	SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
	subExpressions+=SignalNotExpression)*;

SignalNotExpression returns kexpressions::Expression:
	{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=(SignalNotExpression) |
	SignalAtomicExpression;

SignalAtomicExpression returns kexpressions::Expression:
	SignalReferenceExpr
	| "(" SignalExpression ")"
	| SignalPreExpr
	| TrapReferenceExpr // maybe place this somewhere else 
;

SignalReferenceExpr returns kexpressions::ValuedObjectReference:
	valuedObject=[kexpressions::ISignal|ID];

SignalPreExpr returns kexpressions::Expression:
	{kexpressions::OperatorExpression} operator=PreOperator '(' subExpressions+=SignalReferenceExpr ')';

TrapReferenceExpr returns kexpressions::ValuedObjectReference:
	{TrapReferenceExpr} valuedObject=[TrapDecl|ID];

	// --> B.3.4 Delay Expressions <--
// -------------------------------------
DelayExpr:
	(expr=Expression event=DelayEvent) | event=DelayEvent | (isImmediate?="immediate" event=DelayEvent);

DelayEvent:
	tick=Tick | expr=SignalReferenceExpr | "[" expr=SignalExpression "]";

	// --> Exec
// -------------------------------------
Exec:
	("exec" task=[Task|ID] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
	execCaseList+=ExecCase (execCaseList+=ExecCase)*) "end" (optEnd="exec")?;

ExecBody:
	{ExecBody} "(" (vars+=[kexpressions::IVariable|ID] ("," vars+=[kexpressions::IVariable|ID])*)? ")" "("
	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";

ExecCase:
	"case" task=[Task|ID] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?;

	// ==============================================
// === B.2 Namespaces and Predefined Objects  ===
// ==============================================
Tick:
	"tick";

terminal Esterel_SL_Comment:
	'%' !('\n' |
	'\r')* ('\r'? '\n')?;

terminal Esterel_ML_Comment:
	('%' '{')->('}' '%');

	// allow escaping by double quotes ( "this is a ""quote"", how nice." ) - esterelstyle
terminal STRING returns ecore::EString:
	'"' (!('"') | ('"' '"'))* '"';