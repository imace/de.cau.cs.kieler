import uml;

Void createImplements(Interface interface):
  let r = new InterfaceRealization:
  let c = new Class:
  r.setContract(interface)->
  r.setImplementingClassifier(c) ->
  interface.allOwningPackages().first().packagedElement.add(c);

/* Example transition for initial tests. Will probably be removed in final version */
Void flipTransition(Generalization g):
  let source = g.general:
  let target = g.specific:
  g.setGeneral(target)->
  g.setSpecific(source);

/* Creates some things every UseCaseDiagram should have.
 * Creates a Subject, an inner Usecase and an Actor with an Association to the Usecase.
 */
Void startUp(Model m):
  let sub = new Component:
  let use = new UseCase:
  use.subject.add(sub)->
  sub.ownedUseCase.add(use)->
  m.packagedElement.add(sub)->
  addActorToUseCase(use)->
  writeToJava(sub)->
  writeToJava(use);

/* Adds a new Actor to an existing usecase. */
Void addActorToUseCase(UseCase u):
  let own = new Property:
  let mem = new Property:
  let actor = new Actor:
  let asso = new Association:
  own.setType(actor)->
  mem.setType(u)->
  asso.memberEnd.add(own)->
  asso.memberEnd.add(mem)->
  asso.ownedEnd.add(own)->
  asso.ownedEnd.add(mem)->
  u.getModel().packagedElement.add(actor)->
  u.getModel().packagedElement.add(asso)->
  writeToJava(asso)->
  writeToJava(actor);

/* Adds a new Usecase to an existing Subject. */
Void addUseCasetoSubject(Component c):
  let use = new UseCase:
  use.subject.add(c)->
  c.ownedUseCase.add(use)->
  writeToJava(use);

/* Adds a new UseCase to an existing Actor */
Void addUseCaseToActor(Actor a):
  let own = new Property:
  let mem = new Property:
  let use = new UseCase:
  let asso = new Association:
  own.setType(a)->
  mem.setType(use)->
  asso.memberEnd.add(own)->
  asso.memberEnd.add(mem)->
  asso.ownedEnd.add(own)->
  asso.ownedEnd.add(mem)->
  a.getModel().packagedElement.add(use)->
  a.getModel().packagedElement.add(asso)->
  writeToJava(use)->
  writeToJava(asso);

/* Adds a new Actor to an existing Actor connected by a Generalization */
Void addActorGeneralization(Actor a):
  let act = new Actor:
  let gen = new Generalization:
  gen.setGeneral(a)->
  gen.setSpecific(act)->
  act.generalization.add(gen)->
  a.getModel().packagedElement.add(act)->
  writeToJava(act)->
  writeToJava(gen);

/* Adds a new UseCase to an existing UseCase connected by an Extend connection */
Void addUseCaseExtension(UseCase u):
  let use = new UseCase:
  let ext = new Extend:
  let sub = u.owner:
  ext.setExtendedCase(u)->
  ext.setExtension(use)->
  use.extend.add(ext)->
  if (sub == u.getModel()) then
    u.getModel().packagedElement.add(use)
  else
    use.subject.add((Component)sub)->
  sub.ownedUseCase.add(use)->
  writeToJava(use)->
  writeToJava(ext);

/* Adds a new UseCase to an existing Usecase connected by a Generalization */
Void addUseCaseGeneralization(UseCase u):
  let use = new UseCase:
  let gen = new Generalization:
  let sub = u.owner:
  gen.setGeneral(u)->
  gen.setSpecific(use)->
  use.generalization.add(gen)->
  if (sub == u.getModel()) then
    sub.getModel().packagedElement.add(use)
  else
    use.subject.add(sub)->
  sub.ownedUseCase.add(use)->
  writeToJava(gen)->
  writeToJava(use);

/* Adds a new UseCase to an existing UseCase connected by an Include connection */
Void addUseCaseInclusion(UseCase u):
  let use = new UseCase:
  let inc = new Include:
  let sub = u.owner:
  inc.setIncludingCase(use)->
  inc.setAddition(u)->
  use.include.add(inc)->
  if (sub == u.getModel()) then
    u.getModel().packagedElement.add(use)
  else 
    use.subject.add(sub)->
  sub.ownedUseCase.add(use)->
  writeToJava(use)->
  writeToJava(inc);

/* Transforms an Include to an Extend connection */
Void inclusionToExtend(Include i):
  let ext = new Extend:
  ext.setExtendedCase(i.addition)->
  ext.setExtension(i.includingCase)->
  i.owner.extend.add(ext)->
  i.destroy()->
  writeToJava(ext);

/* Transforms an Extend to an Include connection */
Void extendToInclusion(Extend e):
  let inc = new Include:
  inc.setIncludingCase(e.owner)->
  inc.setAddition(e.extendedCase)->
  e.owner.include.add(inc)->
  e.destroy()->
  writeToJava(inc);

/* Transforms an Extend to an Generalization connection */
Void extendToGeneralization(Extend e):
  let gen = new Generalization:
  gen.setGeneral(e.extendedCase)->
  gen.setSpecific(e.owner)->
  e.owner.generalization.add(gen)->
  e.destroy()->
  writeToJava(gen);

/* Transforms an Include to an Generalization connection */
Void includeToGeneralization(Include i):
  let gen = new Generalization:
  gen.setGeneral(i.addition)->
  gen.setSpecific(i.includingCase)->
  i.owner.generalization.add(gen)->
  i.destroy()->
  writeToJava(gen);

/* Adds a new ExtensionPoint to an existion UseCase */
Void addExtensionPointToUseCase(UseCase u):
  let e = new Extension:
  u.ownedElement.add(e)->
  writeToJava(e);

/* Adds a new Constraint to an existing Extend connection */
Void addConstraintToExtension(Extend e):
  let con = new Constraint:
  con.constrainedElement.add(e)->
  e.getModel().packagedElement.add(con);

/* Invoking a java method that temporary stores the given Element */
Void writeToJava(Element e):
  JAVA de.cau.cs.kieler.uml2.DiagramUpdater.cache(org.eclipse.emf.ecore.EModelElement);
