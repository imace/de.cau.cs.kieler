import mm;
import mm::pictograms;
import mm::algorithms;
import mm::algorithms::styles;

import annotations;

extension org::eclipse::xtend::util::stdlib::io;

/**
 * Creation and caching of the Diagram root element,
 *  used a cached extension in order to reduce parameters
 *  in the extension signatures
 */
create Diagram getDiagram():
 this.setLink(new PictogramLink) ->
 
 // this is needed to synthesize valid diagrams to be displayed by a graphiti editor
 this.setGraphicsAlgorithm(
   let rect = new Rectangle:
   rect.setHeight(1000) ->
   rect.setWidth(1000) ->   
   rect
  )  
;


/**
 *
 */
create Shape createShape(Object o):
  this.setActive(true) ->
  this.setVisible(true) ->
  this.setLink(new PictogramLink) ->
  getDiagram().children.add(this)
;

/**
 * Just a wrapper to be used to reveal the shape
 *  indicating that it has been created already!
 */
Shape getShape(Object o):
  o.createShape()
;


/**
 * Create and add an invisible anchor to 'shape'.
 *  The anchor will be a ChopBoxAnchor resulting
 *  in an edge rendering that one used to from typical
 *  graph layouts (edge tip points to the center of shape's GA).
 */
Anchor createAnchor(Shape shape):
  let anchor = new ChopboxAnchor:
  anchor.setActive(false) ->
  anchor.setVisible(true) ->
  anchor.setLink(new PictogramLink) ->
  anchor.setReferencedGraphicsAlgorithm(shape.graphicsAlgorithm) ->
  shape.anchors.add(anchor) ->
  anchor
;


/**
 * Create and add a visible anchor intended to serve
 *  as port to 'shape' at position (x,y).
 *  To this end an active and visible FixPointAnchor is created.  
 */
Anchor createPortAnchor(Shape shape, int x, int y):
  let anchor = new FixPointAnchor:
  anchor.setActive(true) ->
  anchor.setVisible(true) ->
  anchor.setLocation(createPoint(x,y)) ->
  anchor.setLink(new PictogramLink) ->
  anchor.setReferencedGraphicsAlgorithm(shape.graphicsAlgorithm) ->
  shape.anchors.add(anchor) ->
  anchor
;


/**
 *
 */
Connection createConnection(int width):
  let connection = new FreeFormConnection:
  let polyline = new Polyline:
  polyline.setLineWidth(width) ->
  polyline.setForeground(getColor("black")) ->
  connection.setActive(false) ->
  connection.setVisible(true) ->
  connection.setGraphicsAlgorithm(polyline) ->
  connection.setLink(new PictogramLink) ->  
  getDiagram().connections.add(connection) ->
  connection
;

Connection createConnection():
  createConnection(1)
;


/**
 *
 */
Connection createArrowConnection(int width):
  createConnection(width).addArrowHead()
;


Connection createArrowConnection():
  createArrowConnection(1)
;


/**
  *
  */
Connection addArrowHead(Connection connection, int scale):
  let decorator = new ConnectionDecorator:
  let figure = new Polygon:
  figure.points.addAll({createPoint(scale*-5,scale*2), createPoint(scale*-3,0), createPoint(scale*-5,scale*-2), createPoint(0,0)}) ->
  figure.setForeground(connection.graphicsAlgorithm.foreground) ->
  figure.setBackground(figure.foreground) ->
  figure.setFilled(true) ->  
  decorator.setVisible(true) ->
  decorator.setLocation(1.0) ->
  decorator.setLocationRelative(true) ->
  decorator.setGraphicsAlgorithm(figure) ->
  connection.connectionDecorators.add(decorator) ->
  connection
; 

Connection addArrowHead(Connection connection):
   addArrowHead(connection,  1)
; 



/**
 *
 */
Point createPoint(int x, int y):
  let point = new Point:
  point.setX(x) ->
  point.setY(y) ->
  point
;


/**********************/
/*                    */
/* GraphicsAlgorithms */
/*                    */
/**********************/


/**
  *
  */
Rectangle createRectangle(int x, int y, int width, int height, int lineWidth, Color fg, Color bg):
 let rect = new Rectangle:
 rect.setX(x) ->
 rect.setY(y) ->
 rect.setHeight(height) ->
 rect.setWidth(width) ->
 rect.setFilled(true) ->
 rect.setLineVisible(true) ->
 rect.setLineWidth(lineWidth) ->
 rect.setBackground(bg) ->
 rect.setForeground(fg) ->
 rect
;


Rectangle createRectangle(Shape shape, int x, int y, int width, int height, Style style):
  let rectangle = createRectangle(x,y,width,height,style):
  shape.setGraphicsAlgorithm(rectangle) ->
  rectangle
;


/**
  *
  */
Rectangle createRectangle(int x, int y, int width, int height, Style style):
 let rect = new Rectangle:
 rect.setX(x) ->
 rect.setY(y) ->
 rect.setHeight(height) ->
 rect.setWidth(width) ->
 rect.setFilled(true) ->
 rect.setLineVisible(true) ->
 rect.setStyle(style) ->
 rect
;


/**
  * RoundedRectangle
  */ 
RoundedRectangle createRoundedRectangle(int x, int y, int height, int width, int cornerHeight, int cornerWidth, Style style) :
  let roundedRectangle = new RoundedRectangle:
  roundedRectangle.setX(x) ->
  roundedRectangle.setY(y) ->
  roundedRectangle.setHeight(height) ->
  roundedRectangle.setWidth(width) ->
  roundedRectangle.setStyle(style) ->
  roundedRectangle.setFilled(false) ->
  roundedRectangle.setCornerWidth(cornerWidth) ->
  roundedRectangle.setCornerHeight(cornerHeight) ->
  roundedRectangle
;   


/**
 *
 */
 RoundedRectangle createRoundedRectangleWithText(Shape shape, int x, int y, String text, Font font, Style style):
  let roundedRectangle =  createRoundedRectangle(x,y, 30, 30, 30, 30, style):
  let label = roundedRectangle.createText(text):
  label.setFont(font) ->
  label.setY(4) ->
  roundedRectangle.setWidth(calculatetextWidth(text, font)) ->
  shape.setGraphicsAlgorithm(roundedRectangle) ->
  roundedRectangle
;



/**
  *
  */
Ellipse createEllipse(int x, int y, int width, int height, int lineWidth, Color fg, Color bg):
 let ellipse = new Ellipse:
 ellipse.setX(x) ->
 ellipse.setY(y) ->
 ellipse.setHeight(height) ->
 ellipse.setWidth(width) ->
 ellipse.setFilled(true) ->
 ellipse.setLineVisible(true) ->
 ellipse.setLineWidth(lineWidth) ->
 ellipse.setBackground(bg) ->
 ellipse.setForeground(fg) ->
 ellipse
;


/**
  *
  */
Ellipse createEllipse(int x, int y, int width, int height, Style style):
 let ellipse = new Ellipse:
 ellipse.setX(x) ->
 ellipse.setY(y) ->
 ellipse.setHeight(height) ->
 ellipse.setWidth(width) ->
 ellipse.setFilled(true) ->
 ellipse.setLineVisible(true) ->
 ellipse.setStyle(style) ->
 ellipse
;

Ellipse createEllipse(Shape shape, int x, int y, int width, int height, Style style):
  let ellipse = createEllipse(x,y,width,height,style):
  shape.setGraphicsAlgorithm(ellipse) ->
  ellipse
;


/**
 *
 */
Ellipse createCircle(Shape shape, int x, int y, int radius, Style style):
  let ellipse = createEllipse(x,y,radius,radius,style):
  shape.setGraphicsAlgorithm(ellipse) ->
  ellipse
;


/**
 *
 */
Text createText(GraphicsAlgorithm ga, String value):
  createText(ga, value, "default")
;

Text createText(GraphicsAlgorithm ga, String value, String style):
  let text = new Text:
  text.setFont(getFont(style)) ->
  text.setForeground(getColor("black")) ->
  text.setWidth(ga.width) ->
  text.setHorizontalAlignment(Orientation::ALIGNMENT_CENTER) ->
  text.setValue(value) ->
  ga.graphicsAlgorithmChildren.add(text) ->
  text
;



/**
 * Shorthand wraper for property creation.
 */
Property createProperty(String key, String value):
  let property = new Property:
  property.setKey(key) ->
  property.setValue(value) ->
  property
;


/**
 * Creation of the color elements
 *  allows to refer to colors by name
 *  adds them to the diagram on demand
 */
create Color getColor(String name):
 switch (name) {
   case "black" : (
    this.setRed(0) ->
    this.setGreen(0) ->
    this.setBlue(0) ->
    this)
   case "blue" : (
    this.setRed(51) ->
    this.setGreen(51) ->
    this.setBlue(153) ->
    this)
   case "darkGray" : (
    this.setRed(105) ->
    this.setGreen(105) ->
    this.setBlue(105) ->
    this)
   case "darkOrange" : (
    this.setRed(248) ->
    this.setGreen(179) ->
    this.setBlue(0) ->
    this)
   case "error" : (
    this.setRed(255) ->
    this.setGreen(0) ->
    this.setBlue(0) ->
    this)
   case "gray" : (
    this.setRed(190) ->
    this.setGreen(190) ->
    this.setBlue(190) ->
    this)
   case "lemon" : (
    this.setRed(255) ->
    this.setGreen(250) ->
    this.setBlue(205) ->
    this)
   case "red" : (
    this.setRed(255) ->
    this.setGreen(0) ->
    this.setBlue(0) ->
    this)
   case "white" : (
    this.setRed(255) ->
    this.setGreen(255) ->
    this.setBlue(255) ->
    this)
   case "yellow" : (
    this.setRed(255) ->
    this.setGreen(255) ->
    this.setBlue(0) ->
    this)
   default :
    null
 } ->
 getDiagram().colors.add(this)
;


/**
 * Creation of the available style collection
 *  allows to refer to colors by name
 *  adds them to the diagram on demand
 */
create Style getStyle(String name):
 switch(name) {
   case "black_lemon" : (
    this.setId("black_lemon") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("lemon")) ->
    this.setLineWidth(1) ->
    this)
   case "black_white" : (
    this.setId("black_white") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("white")) ->
    this.setLineWidth(4) ->
    this)
   case "black_black" : (
    this.setId("black_black") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("black")) ->
    this.setLineWidth(4) ->
    this)
   case "black_gray" : (
    this.setId("black_gray") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("gray")) ->
    this.setLineWidth(4) ->
    this)
   case "black_darkGray" : (
    this.setId("black_darkGray") ->
    this.setForeground(getColor("black")) ->
    this.setBackground(getColor("darkGray")) ->
    this.setLineWidth(4) ->
    this)
   case "red" : (
    this.setId("red") ->
    this.setForeground(getColor("red")) ->
    this.setBackground(getColor("white")) ->
    this.setLineWidth(4) ->
    this)
   default :
    null
 } ->
 getDiagram().styles.add(this)
;


/**
 * Creation of the available font collection
 *  here we will use the same font for all labels
 *  adds it to the diagram on demand
 */
create Font getFont(String name):
  switch (name) {
    case "10" : (
      this.setName("Arial") ->
      this.setSize(10) ->
      this.setBold(false) ->
      this)
    case "11" : (
      this.setName("Arial") ->
      this.setSize(11) ->
      this.setBold(false) ->
      this)
    case "12" : (
      this.setName("Arial") ->
      this.setSize(12) ->
      this.setBold(false) ->
      this)
    case "bold" : (
      this.setName("Arial") ->
      this.setSize(8) ->
      this.setBold(true) ->
      this)
    case "bold10" : (
      this.setName("Arial") ->
      this.setSize(10) ->
      this.setBold(true) ->
      this)
    case "bold12" : (
      this.setName("Arial") ->
      this.setSize(12) ->
      this.setBold(true) ->
      this)
    case "default" : (
      this.setName("Arial") ->
      this.setSize(8) ->
      this.setBold(false) ->
      this)
    default :
      null
  } ->
  getDiagram().fonts.add(this)
;


/**
 * ints is assumed to contain at least 1 entry
 */
int max(List[int] ints):
  let maxRemainder = (ints.size == 1?ints.first():ints.withoutFirst().max()):
  (ints.first() >= maxRemainder?ints.first():maxRemainder)
;


create IntAnnotation getIntProperty(Shape shape, String name):
  this.setName(name) ->
  this.setValue(0)
;


IntAnnotation getAndAddIntProperty(Shape shape, String name):
  let intAnno = shape.getIntProperty(name):
  intAnno.setValue(intAnno.value + 1) ->
  intAnno
;


int calculatetextWidth(String text, Font font): 
  JAVA de.cau.cs.kieler.klighd.graphiti.transformations.DiagramUtil.calculatetextWidth(java.lang.String, org.eclipse.graphiti.mm.algorithms.styles.Font)
;


int calculatetextHeight(String text, Font font):
  JAVA de.cau.cs.kieler.klighd.graphiti.transformations.DiagramUtil.calculatetextHeight(java.lang.String, org.eclipse.graphiti.mm.algorithms.styles.Font)
;


/**
  * cached wrapper suppressing multiple outputs of the same warning!
  */
cached showUniqueInfo(String string):
  info(string)
;


Void debug(List l):
  JAVA de.cau.cs.kieler.klighd.graphiti.transformations.DiagramUtil.debug(java.util.List)
;

//chsch: deactivated since given in io.ext
//Void debug(Object o):
//  JAVA de.cau.cs.kieler.klighd.graphiti.transformations.DiagramUtil.debug(java.lang.Object)
//;
