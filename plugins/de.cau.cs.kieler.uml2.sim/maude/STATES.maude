fmod STATE is
  sort ModState .
endfm
view ModState from TRIV to STATE is
  sort Elt to ModState .
endv 
fmod REGION is
  sort Region .
endfm
view Region from TRIV to REGION is
  sort Elt to Region .
endv 
fmod VERTEX is
  sort Vert .
endfm
view Vert from TRIV to VERTEX is
  sort Elt to Vert .
endv
***(
  Module STATES models the states, regions and pseudostates
  (and their hierarchical order) wrt. 
  the nameming convention in the formal semantics. Some equations 
  determining the type of a given state are defined. Furthermore start, 
  last, prefix, downset and upset of the formal sermantics are modeled.
)***
fmod STATES is
  including VERTEX .
  including STRING .
  including SET{Vert} * (sort Set{Vert} to Verts, sort NeSet{Vert} to NeVerts) .

  sorts Name StateName RegionName DefaultName CompositeName FinalName 
    HistDeepName HistShallowName .
  subsorts DefaultName CompositeName FinalName 
    HistDeepName HistShallowName < StateName .
  subsorts RegionName StateName < Name .
 
  sorts DefaultState CompositeState FinalState HistDeepState
    HistShallowState ModState .
  subsort DefaultState CompositeState FinalState HistDeepState
    HistShallowState < ModState .  
  sorts Region States Regions .
  subsort ModState Region < Vert .
  subsort States Regions < Verts .   
  subsort Name < ModState .
  subsort RegionName < Region .

  *** operators and the corresponding equations      
  *** single name constructors
  op F_ : String -> FinalName [ctor] .
  op C_ : String -> CompositeName [ctor] .
  op R_ : String -> RegionName [ctor] .
  op D : -> DefaultName [ctor] .
  op H : -> HistShallowName [ctor] .
  op H* : -> HistDeepName [ctor] .
  op root_ : RegionName -> Region [ctor] .
  op _:_ : CompositeState RegionName -> Region [ctor] .
  op _:_ : Region CompositeName -> CompositeState [ctor] .
  op _:_ : Region FinalName -> FinalState [ctor] .
  op _:_ : Region DefaultName -> DefaultState [ctor] .
  op _:_ : Region HistDeepName -> HistDeepState [ctor] .
  op _:_ : Region HistShallowName -> HistShallowState [ctor] .

  *** Variable declarations
  vars name : Name .
  vars v v2 v3 : Vert .
  var S : States .
  vars s : ModState .
  vars r : Region .
  vars V V2 : Verts .
  vars str str2 : String .

  *** functions determining the type (state, final state, region and 
  ***  history) of a given state
  op typeFinal_ : ModState -> Bool .
  eq typeFinal (v : (F str)) = true .
  eq typeFinal v = false [owise] .

  op typeState_ : Vert -> Bool .
  eq typeState (v : (C str)) = true .
  eq typeState v = false [owise] .
  
  op typeAnyState_ : Verts -> Bool .
  eq typeAnyState (v, V) = ((typeFinal v) or (typeState v)) and (typeAnyState V) .   
  eq typeAnyState empty = true .
     
  op typeRegion_ : Vert -> Bool .
  eq typeRegion root(R str) = true .
  eq typeRegion (v : (R str)) = true .  
  eq typeRegion v = false [owise] .

  op typeHistory_ : Vert -> Bool .
  eq typeHistory (v : H) = true .
  eq typeHistory (v : H*) = true .
  eq typeHistory v = false [owise] .

     *** corresponding to start as defined in the formal semantics
  *** mapped to sets of verts
  op start_ : Verts -> Verts .
  eq start (v : name) = v . 
  eq start (root(name)) = empty .  
  eq start (v, V) = (start v) , (start V) .

  *** corresponding to last as defined in the formal semantics
  op last _ : Vert -> Name .
  eq last (v : name) = name . 
  eq last root(name) = root(name) . 
  
  *** corresponding to prefix (not proper prefix) as defined in the
  *** formal semantics prefix x y: is x prefix of y?
  op prefix__ : Vert Vert -> Bool [memo] .
  eq prefix v v = true .
  ceq prefix v v2 = prefix v (start v2) if (len v) < (len v2) .
  eq prefix v v2 = false [owise] .

  *** corresponding to downset as defined in the formal semantics
  *** downset x: returns all Statenames that are prefix of x  
  op downset_ : Verts -> Verts [memo] .
  eq downset empty = empty .
  eq downset (v, V) = v, downset(start v), (downset V) .
  eq downset root(name) = root(name) .

  *** corresponding to upset as defined in the formal semantics but
  *** restricted to the statemachines verts given in the second argument
  *** upset y X: return all Verts x in X where y is prefix of x 
  op upset__ : Vert Verts -> Verts [memo] .
  ceq upset v (v2, V) = v2, (upset v V) if prefix v v2 .  
  eq upset v empty = empty .    
  eq upset v (v2, V) = upset v V [owise] .  

  *** getSubStates x Y: get all substates of x in Y .
  op getSubStates__ : Region Verts -> Verts  [format (g r c n) memo] .
  ceq getSubStates r (v, V) = v,  getSubStates r V
    if (r == start v) .
  ceq getSubStates r (v, V) = getSubStates r V
    if (r =/= start v) .
  eq getSubStates r empty = empty .

  *** getSubRegions x Y: get all subregions of x in Y .
  op getSubRegions__ : ModState Verts -> Verts [memo] .
  ceq getSubRegions s (v, V) = v,  getSubRegions s V
    if (s == start v) .
  ceq getSubRegions s (v, V) = getSubRegions s V
    if (s =/= start v) .
  eq getSubRegions s empty = empty .

  op getSubs__ : Vert Verts -> Verts .
  ceq getSubs v V = (getSubRegions v V) if typeState v .
  ceq getSubs v V = empty if typeFinal v .
  eq getSubs v V = (getSubStates v V) [owise] .
    
  op getsub __ : Vert Verts -> Vert [memo] .
  ceq getsub v (v2 ,  V) = v2
    if v == start v2 .
  eq getsub v (v2 ,  V) = getsub v V [owise] .
  ceq getsub v v2 = v2
    if v == start v2 .
  eq getsub v v2 = getsub v (start v2) [owise] .

  *** get the subsverts of v (determined with all vertices V) which are superverts of a state in V2 
  op getSubStToTgt___ : Vert Verts Verts -> Verts .
  eq getSubStToTgt v V2 V = intersection((getSubs v V), (downset V2)) .
  
  
  *** wo benutze ich das
  op containsSuper__ : Verts Verts -> Bool .
  eq containsSuper (v, V) V2 = ($containsSuper v V2) and (containsSuper V  V2) .
  eq containsSuper empty V = true .

  op $containsSuper__ : Vert Verts -> Bool .
  eq $containsSuper v (v2, V) = ((prefix v2 v) and v =/= v2) or ($containsSuper v  V) .
  eq $containsSuper v empty = false .
     
  *** wo benutze ich das   
  op len _ : Vert -> Nat .
  eq len (v : name) = (len v) + 1 . 
  eq len name = 1 .
  eq len root(R str) = 1 .

  *** comparelen x Y : return the length of a vert y in Y where x is
  *** prefix of y
  op comparelen__ : Vert Verts -> Nat [memo] .
  ceq comparelen v2 (v, V) = len v if prefix v2 v .
  eq comparelen v2 (v, V) = comparelen v2 V [owise] .
  eq comparelen v2 empty = 0 .

  *** explain
  op prettyVerts_ : Verts -> Verts [memo] .
  eq prettyVerts empty = empty .
  eq prettyVerts (v, V) = last v, prettyVerts V .
  
  op prettyVToV__ : Verts Verts -> Verts [memo] .
  eq prettyVToV V (V2, v) = (prettyVToV V V2), ($prettyVToV V v) .
  eq prettyVToV V empty = empty .

  op $prettyVToV__ : Verts Vert -> Verts [memo] .
  ceq $prettyVToV (V, v) v2 = v if (last v) == v2 .
  eq $prettyVToV (V, v) v2 = empty [owise] .
   
endfm
