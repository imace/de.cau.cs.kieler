import uml;

extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

//extension Extensions reexport;

String trigger2(Transition transition):
  let transitionLabel = transition.name:
  getTrigger(transitionLabel.toString())
;


String action2(Transition transition):
  let transitionLabel = transition.name:
  getAction(transitionLabel.toString())
;


//Effect effect2(Transition transition):
//  let effect = new Trigger:
//  let transitionName = transition.name:
//  let event = new Event:
//  event.setName(getTrigger(transitionName)) ->
//  effect.
//;

Set[Transition] getTransitions(StateMachine sm):
 ((Set[Transition])sm.eAllContents.select(e|e.metaType == Transition))
;

Set[Vertex] getStates(StateMachine sm):
 ((Set[Vertex])sm.eAllContents.select(e|e.metaType == State))
;

Set[String] getMaudeStates(StateMachine sm):
 ((Set[State])sm.getStates()).fullyHelp()
;


Set[Region] getRegions(StateMachine sm):
 ((Set[Region])sm.eAllContents.select(e|e.metaType == Region))
;

Set[String] getMaudeRegions(StateMachine sm):
 ((Set[Region])sm.getRegions()).fullyHelp()
;

State getParent(Region region):
 (State)region.eContainer()
;

Region getParent(State state):
 (Region)state.eContainer()
;

Region getParent(Pseudostate state):
 (Region)state.eContainer()
;

String getLabel(State n):
 n.getLabel()
;
String getLabel(Region n):
 n.getLabel()
;

String getMaudeLabel(State n):
 'C'+n.getLabel()
;
String getMaudeLabel(Region n):
 'R'+n.getLabel()
;
  // 
//Set[Vertex] getSourceStates(Transition n)
//  
//;
// Transitions are tuples of:
// sources Triggerevent guard Action ListofForkActions ListofJoinActions targets containingRegion
String genMaude(Transition n):
 // ToDo: generate source and target sets
 //(n.source).toString() + '   ' + (n.target).toString() + '   ' + n.trigger2() + '   ' + n.action2()+ '   ' +((Region)n.container).getMaudeLabel()
 'eq tr_'+n.getId()+ ' = '+
// sources (States only)
 (n.source.getId()) + ' ' +
// 'empty '+ 
// Triggerevent
 n.trigger2() + 
// guard 
 ' nil ' + 
// Action
 n.action2() + 
// ListofForkActions ListofJoinActions
 ' empty empty ' +
// targets (States and history pseudostates only)
 'empty '+
// containingRegion
 ((Region)n.eContainer()).getMaudeLabel() + ' .'   
;


Set[Transition] getTransitionsOP(StateMachine sm):
  let transitions = sm.getTransitions() :
  transitions.select(e|(e.source).metaType == Pseudostate)
;

Set[Transition] getInitialTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isInitial())
;

Set[Transition] getDHDTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isDH())
;

Set[Transition] getSHDTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isSH())
;

// Set[Vertex] extendForks(Set[Vertex] vertices, StateMachine sm):
//    let transitions = sm.getTransitions() :
//    let otherstates = vertices.select(e| e.metatype != Pseudostate) : 
//    let forkstates = vertices.select(e| e.metatype == Forkstate) :
//    forkstates
// ;

String genDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq def'+region.getMaudeLabel()+ ' = ' + region.getMaudeLabel() + ' default ' + ((State)tr.target).getMaudeLabel()+ ' .\n'  
;

String genDHDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq dDef'+region.getMaudeLabel()+ ' = ' + region.getMaudeLabel() + ' deepdefault ' + ((State)tr.target).getMaudeLabel()+ ' .\n'  
;
String genSHDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq sDef'+region.getMaudeLabel()+ ' = ' + region.getMaudeLabel() + ' shallowdefault ' + ((State)tr.target).getMaudeLabel()+ ' .\n'  
;

String fullyHelp(Region n):
 //'op R'+n.getLabel()+' : -> Region .\n'+
 '    eq R'+n.getLabel()+' = '+ n.fullyQualifiedName()
;
String fullyHelp(State n):
 //'op C'+n.getLabel()+' : -> ModState .\n'+
 '    eq C'+n.getLabel()+' = '+ n.fullyQualifiedName()
;

Set[Vertex] allVertexs(StateMachine sm):
 ((Set[Vertex])sm.eAllContents.select(e|(e.metaType == Region)||(e.metaType == State)))
; 


String fullyQualifiedName(Region n) : n.getParent().metaType == StateMachine ? 'root(R "'+n.getLabel()+'")' :
   fullyQualifiedName(n.getParent())+' : R "'+n.getLabel()+'"'
;
String fullyQualifiedName(State n) : n.getParent() == null ? n.getLabel() :
   fullyQualifiedName(n.getParent())+' : C "'+n.getLabel()+'"'
;

Set[String] getTriggerEvents(StateMachine sm):
 let transitions = sm.getTransitions() :
 (transitions.select(e|e.name.contains("/"))).trigger2()
;

Set[String] getAction(StateMachine sm):
 let transitions = sm.getTransitions() :
 (transitions.select(e|((String)e.name).contains("/"))).action2()
;

Boolean contains(String str):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.contains(java.lang.String)
;

String getAction(String transitionLabel):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAction(java.lang.String)
;
String getTrigger(String transitionLabel):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getTrigger(java.lang.String)
;


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

List[Transition] getIncomingTransitions(Vertex vertex) :
   vertex.eAllContents.select(e|e.metaType == Transition && ((Transition)e).target == vertex)
;

//-----------------------------------------------------------------------------

List[Transition] getOutgoingTransitions(Vertex vertex) :
   vertex.eAllContents.select(e|e.metaType == Transition && ((Transition)e).source == vertex)
;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

// Checks whether a transition is eligible to be considered by the maude code
// generation or in the other case is already handled by the maude simulatior
// implicitly. 
Boolean isConsidered(Transition transition):
  let source = transition.source:
  let target = transition.target:
  !(source.isInitial() || source.isDH() || source.isSH() || source.isFork() || source.isJoin()
  || target.isFork() || target.isJoin())
;

//-----------------------------------------------------------------------------

// Returns true iff the vertex (pseudostate fork or join) has already been
// checked and not needs to be visited again.
// It means that already exists a transition containing it.
boolean isDone(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isCheckedVertex(org.eclipse.uml2.uml.Vertex)  
;

//-----------------------------------------------------------------------------

// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
Set[Vertex] getPseudoSourceVertices(Pseudostate pseudostate) :
    // get all transitions that have a fork or join as a target
    let transitionList = getAllPseudostateTransitions(pseudostate).select(e|e.target.metaType == Pseudostate
         && ( e.target.isJoin() || e.target.isFork() )) :
    // Return all source vertices
    transitionList.source
;

//-----------------------------------------------------------------------------

// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
Set[Vertex] getPseudoTargetVertices(Pseudostate pseudostate) :
    // get all transitions that have a fork or join as a target
    let transitionList = getAllPseudostateTransitions(pseudostate).select(e|e.source.metaType == Pseudostate
         && ( e.source.isJoin() || e.source.isFork() )) :
    // Return all target vertices
    transitionList.target
;

//-----------------------------------------------------------------------------

Set[Transition] getAllPseudostateTransitions(Pseudostate pseudostate) :
   let incomingList = (List[Transition])pseudostate.getIncomingTransitions():
   let outgoingList = (List[Transition])pseudostate.getOutgoingTransitions():
   getAllPseudostateTransitions2(outgoingList).addAll(
   				getAllPseudostateTransitions2(incomingList))
;

Set[Transition] getAllPseudostateTransitions2(List[Transition] transitionList) :
  let firstTransition = transitionList.first():
  let firstTransitionSource = firstTransition.source:
  let firstTransitionTarget = firstTransition.target:
  let outList = {}:
  // add incoming transitions from 'normal vertices'
  if (!firstTransitionSource.isFork() && !firstTransitionSource.isJoin()) then
     outList.add(firstTransition)
  else
     outList.addAll(getAllPseudostateTransitions((Pseudostate)firstTransitionSource))
  ->
  // add outgoing transitions to 'normal vertices'
  if (!firstTransitionTarget.isFork() && !firstTransitionTarget.isJoin()) then
     outList.add(firstTransition)
  else
     outList.addAll(getAllPseudostateTransitions((Pseudostate)firstTransitionTarget))
  ->
  // add possibly other transitions
  if (transitionList.withoutFirst().size > 0) then
     outList.addAll(getAllPseudostateTransitions2(transitionList.withoutFirst()))
  else 
     null
  ->
  outList
;



// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
//Set[Vertex] getSourceNodes(Pseudostate pseudostate) :
//  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getTargetNodes(Pseudostate)  
//;

//-----------------------------------------------------------------------------
// if (pseudostate.isFork() || pseudostate.isJoin()) then (
// 	if (pseudostate.isFork()) then
// /   	pseudostate.eAllContents.select(e|(e.metaType == Vertex))
// 	else 
//    	pseudostate.eAllContents.select(e|(e.metaType == Vertex))
// ) 
// else 
//    null//
//;

//-----------------------------------------------------------------------------

//Set[Vertex] getSourceNodesFork(Pseudostate)
//;

//-----------------------------------------------------------------------------

// Test whether a vertex is of type Initial
Boolean isInitial(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isInitial(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Deep History
Boolean isDH(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isDH(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Shallow History
Boolean isSH(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isSH(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Fork
Boolean isFork(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isFork(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Join
Boolean isJoin(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isJoin(org.eclipse.uml2.uml.Vertex)
;

//-----------------------------------------------------------------------------

// Get the ID of a vertex
String getId(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Vertex)
;

// Get the ID of a transition
String getId(Transition transition):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Transition)
;

// Get the hash value of a String
String hash(String string):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.hash(java.lang.String)
;

//-----------------------------------------------------------------------------

//Void test():
//  let transition = new Transition :
//  let transitionList = new List[Transition] : 
//  transition.trigger2() ->
//  transitionList.trigger2() ->
//  trigger2(transition)
//;