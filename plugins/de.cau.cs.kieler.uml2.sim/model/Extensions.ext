import uml;

extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

//extension Extensions reexport;

String trigger2(Transition transition):
  let transitionLabel = transition.name:
  let returnTrigger = getTrigger(transitionLabel.toString()):
  if (returnTrigger != null && returnTrigger.length > 0) then
    returnTrigger
  else
    'nil'
;


String action2(Transition transition):
  let transitionLabel = transition.name:
  let returnAction = getAction(transitionLabel.toString()):
  if (returnAction != null && returnAction.length > 0) then
    returnAction
  else
    'skip'
;


//Effect effect2(Transition transition):
//  let effect = new Trigger:
//  let transitionName = transition.name:
//  let event = new Event:
//  event.setName(getTrigger(transitionName)) ->
//  effect.
//;

Set[Transition] getTransitions(StateMachine sm):
 ((Set[Transition])sm.eAllContents.select(e|e.metaType == Transition))
;

Set[Pseudostate] getForkJoin(StateMachine sm):
 ((Set[Transition])sm.eAllContents.select(e|e.metaType == Pseudostate && ( ((Vertex)e).isJoin() || ((Vertex)e).isFork() ) ))
;

Set[Vertex] getStates(StateMachine sm):
 //ToDo: FinalState is State ?!?
 ((Set[Vertex])sm.eRootContainer.eAllContents.select(e|e.metaType == State || e.metaType == FinalState))
;

Set[Vertex] getHistoryStates(StateMachine sm):
 ((Set[Vertex])sm.eRootContainer.eAllContents.select(e|e.metaType == Pseudostate && ((((Vertex)e).isDH())||((Vertex)e).isSH())))
;

Set[String] getHistoryMaudeStates(StateMachine sm):
 ((Set[State])sm.getHistoryStates()).fullyHistoryHelp()
;

Set[String] getMaudeStates(StateMachine sm):
 ((Set[State])sm.getStates()).fullyHelp()
;

Set[Region] getRegions(StateMachine sm):
 ((Set[Region])sm.eAllContents.select(e|e.metaType == Region))
;

Set[String] getMaudeRegions(StateMachine sm):
 ((Set[Region])sm.getRegions()).fullyHelp()
;

State getParent(Region region):
 (State)region.eContainer()
;

Region getParent(State state):
 (Region)state.eContainer()
;

Region getParent(Pseudostate state):
 (Region)state.eContainer()
;

String getLabel(State n):
 n.getLabel()
;
String getLabel(Region n):
 n.getLabel()
;

String getMaudeLabel(State n):
 'C'+n.getLabel()
;
String getMaudeLabel(Region n):
 'R'+n.getLabel()
;
  // 
//Set[Vertex] getSourceStates(Transition n)
//  
//;
// Transitions are tuples of:
// sources Triggerevent guard Action ListofForkActions ListofJoinActions targets containingRegion
String genMaude(Transition n):
 // ToDo: generate source and target sets
 //(n.source).toString() + '   ' + (n.target).toString() + '   ' + n.trigger2() + '   ' + n.action2()+ '   ' +((Region)n.container).getId()
 '   eq tr'+n.getId()+ ' = '+
// sources (States only)
 '('+(n.source.getId()) + ') ' +
// 'empty '+ 
// Triggerevent
 n.trigger2() + 
// guard 
 ' Gd ' + 
// Action
 n.action2() + 
// ListofForkActions ListofJoinActions
 ' skip skip ' +
// targets (States and history pseudostates only)
 '('+n.target.getId()+') ' +
// containingRegion
 ((Region)n.eContainer()).getId() + ' .'   
;



Set[Transition] getTransitionsOP(StateMachine sm):
  let transitions = sm.getTransitions() :
  transitions.select(e|(e.source).metaType == Pseudostate)
;

Set[Transition] getInitialTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isInitial())
;

Set[Transition] getDHDTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isDH())
;

Set[Transition] getSHDTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isSH())
;

// Set[Vertex] extendForks(Set[Vertex] vertices, StateMachine sm):
//    let transitions = sm.getTransitions() :
//    let otherstates = vertices.select(e| e.metatype != Pseudostate) : 
//    let forkstates = vertices.select(e| e.metatype == Forkstate) :
//    forkstates
// ;

String genDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq def'+region.getId()+ ' = ' + region.getId() + ' default ' + ((State)tr.target).getId()+ ' .\n'  
;

String genDHDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq dDef'+region.getId()+ ' = ' + region.getId() + ' deepdefault ' + ((State)tr.target).getId()+ ' .\n'  
;
String genSHDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq sDef'+region.getId()+ ' = ' + region.getId() + ' shallowdefault ' + ((State)tr.target).getId()+ ' .\n'  
;

String fullyHelp(Region n):
 //'op R'+n.getId()+' : -> Region .\n'+
 '    eq '+n.getId()+' = '+ n.fullyQualifiedName()
;
String fullyHelp(State n):
 //'op C'+n.getId()+' : -> ModState .\n'+
 '    eq '+n.getId()+' = '+ n.fullyQualifiedName()
;
String fullyHistoryHelp(Pseudostate n):
 //'op C'+n.getId()+' : -> ModState .\n'+
  if (n.isDH()) then
 '    eq '+n.getId()+' = '+ ((Region)n.eContainer()).fullyQualifiedName() + ' : H*'
 else
 '    eq '+n.getId()+' = '+ ((Region)n.eContainer()).fullyQualifiedName() + ' : H'
;

Set[Vertex] allVertexs(StateMachine sm):
 ((Set[Vertex])sm.eAllContents.select(e|(e.metaType == Region)||(e.metaType == State)))
; 


String fullyQualifiedName(Region n) : n.getParent().metaType == StateMachine ? 'root(R "'+n.getId()+'")' :
   fullyQualifiedName(n.getParent())+' : R "'+n.getId()+'"'
;
String fullyQualifiedName(State n) : n.getParent() == null ? n.getId() :
   fullyQualifiedName(n.getParent())+' : C "'+n.getId()+'"'
;

Set[String] getTriggerEvents(StateMachine sm):
 let transitions = sm.getTransitions() :
 (transitions.select(e|e.name.contains(('/')))).trigger2()
;

Set[String] getAction(StateMachine sm):
 let transitions = sm.getTransitions() :
 (transitions.select(e|((String)e.name).contains('/'))).action2()
;

Boolean contains(String str):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.contains(java.lang.String)
;

String getAction(String transitionLabel):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAction(java.lang.String)
;
String getTrigger(String transitionLabel):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getTrigger(java.lang.String)
;


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

List[Transition] getIncomingTransitions(Vertex vertex) :
   vertex.eRootContainer.eAllContents.select(e|e.metaType == Transition && ((Transition)e).target == vertex)
;

//-----------------------------------------------------------------------------

List[Transition] getOutgoingTransitions(Vertex vertex) :
   vertex.eRootContainer.eAllContents.select(e|e.metaType == Transition && ((Transition)e).source == vertex)
;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

// Checks whether a transition is eligible to be considered by the maude code
// generation or in the other case is already handled by the maude simulatior
// implicitly. 
Boolean isConsidered(Transition transition):
  let source = transition.source:
  let target = transition.target:
  !(source.isInitial() || source.isDH() || source.isSH() || source.isFork() || source.isJoin()
  || target.isFork() || target.isJoin())
;

//-----------------------------------------------------------------------------

// Clear all done marked vertices
Void clearDoneVertices():
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.clearDoneVertices()  
;


// Returns true iff the vertex (pseudostate fork or join) has already been
// checked and not needs to be visited again.
// It means that already exists a transition containing it.
boolean isDone(Vertex vertex, String id):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isDone(org.eclipse.uml2.uml.Vertex, java.lang.String)  
;

// Mark a vertex (pseudostate fork or join) that has just been visited
boolean markDone(Vertex vertex, String id):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.markDone(org.eclipse.uml2.uml.Vertex, java.lang.String)  
;



//-----------------------------------------------------------------------------

// Set a new last root region iff the new region is on a higher hierarchy level
Void setLastRootRegion(Region region) :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.setLastRootRegion(org.eclipse.uml2.uml.Region)  
;

// Reset the last root region
Void resetLastRootRegion() :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.resetLastRootRegion()  
;

// Get the last root region
Region getLastRootRegion() :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getLastRootRegion()  
;

//-----------------------------------------------------------------------------

// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
Set[Vertex] getPseudoTargetVertices(Pseudostate pseudostate) :
    let reset = resetLastRootRegion():
    // get all transitions that have a fork or join as a target
    let transitionList = getAllPseudostateTransitions(pseudostate,"OUTGOING").select(e|e.source.metaType == Pseudostate
         && ( e.source.isJoin() || e.source.isFork() )) :
    //Mark all source vertices
    //transitionList.source.markDoneIncoming() ->
    // Return all target vertices
    transitionList.target
;

//-----------------------------------------------------------------------------

// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
Set[Vertex] getPseudoSourceVertices(Pseudostate pseudostate) :
    let reset = resetLastRootRegion():
    // get all transitions that have a fork or join as a target
    let transitionList = getAllPseudostateTransitions(pseudostate,"INCOMING").select(e|e.target.metaType == Pseudostate
         && ( e.target.isJoin() || e.target.isFork() )) :
    //Mark all source vertices
    //transitionList.source.markDoneOutgoing() ->
    // Return all source vertices
    transitionList.source
;

//-----------------------------------------------------------------------------

Set[Transition] getAllPseudostateTransitions(Pseudostate pseudostate, String id) :
   let incomingList = (List[Transition])pseudostate.getIncomingTransitions():
   let outgoingList = (List[Transition])pseudostate.getOutgoingTransitions():
   let incomingOutgoingList = {}:
   incomingOutgoingList.addAll(incomingList) ->
   incomingOutgoingList.addAll(outgoingList) ->
  if (markDone(pseudostate, id)) then (
     setLastRootRegion(((Region)pseudostate.eContainer())) ->
     getAllPseudostateTransitions2(incomingOutgoingList, id)
  ) else
     {}
;


Set[Transition] helperTarget(Vertex firstTransitionTarget, Transition firstTransition, String id) :
  let outList = {}:
  // add outgoing transitions to 'normal vertices'
  if (!firstTransitionTarget.isFork() && !firstTransitionTarget.isJoin()) then
      outList.add(firstTransition)
  else
     outList.addAll(getAllPseudostateTransitions((Pseudostate)firstTransitionTarget, id))
  ->
  outList
;

Set[Transition] helperSource(Vertex firstTransitionSource, Transition firstTransition, String id) :
  let outList = {}:
  // add incoming transitions from 'normal vertices'
  if (!firstTransitionSource.isFork() && !firstTransitionSource.isJoin()) then
      outList.add(firstTransition)
  else 
     outList.addAll(getAllPseudostateTransitions((Pseudostate)firstTransitionSource, id))
  ->
  outList
;

Set[Transition] getAllPseudostateTransitions2(List[Transition] transitionList, String id) :
  let firstTransition = transitionList.first():
  let firstTransitionSource = firstTransition.source:
  let firstTransitionTarget = firstTransition.target:
  let outList = {}:
  outList.addAll(helperTarget(firstTransitionTarget, firstTransition, id)) ->
  outList.addAll(helperSource(firstTransitionSource, firstTransition, id)) ->
  // add possibly other transitions
  if (transitionList.withoutFirst().size > 0) then
     outList.addAll(getAllPseudostateTransitions2(transitionList.withoutFirst(), id))
  else 
     {}
  ->
  outList
;



// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
//Set[Vertex] getSourceNodes(Pseudostate pseudostate) :
//  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getTargetNodes(Pseudostate)  
//;

//-----------------------------------------------------------------------------
// if (pseudostate.isFork() || pseudostate.isJoin()) then (
// 	if (pseudostate.isFork()) then
// /   	pseudostate.eAllContents.select(e|(e.metaType == Vertex))
// 	else 
//    	pseudostate.eAllContents.select(e|(e.metaType == Vertex))
// ) 
// else 
//    null//
//;

//-----------------------------------------------------------------------------

//Set[Vertex] getSourceNodesFork(Pseudostate)
//;

//-----------------------------------------------------------------------------

// Get the alias of a vertex
String getAlias(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAlias(org.eclipse.uml2.uml.Vertex)
;

// Get the alias of a transition
String getAlias(Transition transition):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAlias(org.eclipse.uml2.uml.Transition)
;

// Test whether a vertex is of type Initial
Boolean isInitial(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isInitial(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Deep History
Boolean isDH(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isDH(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Shallow History
Boolean isSH(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isSH(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Fork
Boolean isFork(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isFork(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Join
Boolean isJoin(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isJoin(org.eclipse.uml2.uml.Vertex)
;

//-----------------------------------------------------------------------------

// Get the ID of a region
String getId(Region region):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Region)
;

// Get the ID of a vertex
String getId(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Vertex)
;

// Get the ID of a transition
String getId(Transition transition):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Transition)
;

// Get the hash value of a String
String hash(String string):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.hash(java.lang.String)
;

//-----------------------------------------------------------------------------

// Do not print out a string
Void ignore(String string) :
  null  
;

//-----------------------------------------------------------------------------

// Add a Pseudostate to a temporary list
Void addPseudostate(Pseudostate pseudostate) :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.addPseudostate(org.eclipse.uml2.uml.Pseudostate)
;
	
// Get the saved Pseudostates
List[Pseudostate] getPseudostates() :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getPseudostates()
;
	
// Reset the Pseudostates
Void resetPseudostates() :
 JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.resetPseudostates()
;	

//-----------------------------------------------------------------------------

//Void test():
//  let transition = new Transition :
//  let transitionList = new List[Transition] : 
//  transition.trigger2() ->
//  transitionList.trigger2() ->
//  trigger2(transition)
//;