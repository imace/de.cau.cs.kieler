import uml;

extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

//-----------------------------------------------------------------------------

// This method will immitate a transition trigger and return its String representation
String trigger2(Transition transition):
  let transitionLabel = transition.name:
  let returnTrigger = getTrigger(transitionLabel.toString()):
  if (returnTrigger != null && returnTrigger.length > 0) then
    returnTrigger
  else
    '(ev: "noevent")'
;

// This method will immitate a transition action and return its String representation
String action2(Transition transition):
  let transitionLabel = transition.name:
  let returnAction = getAction(transitionLabel.toString()):
  if (returnAction != null && returnAction.length > 0) then
    returnAction
  else
    'skip'
;

// INTERNAL: Helpermethod for action extraction
String getAction(String transitionLabel):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAction(java.lang.String)
;

// INTERNAL: Helpermethod for trigger extraction
String getTrigger(String transitionLabel):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getTrigger(java.lang.String)
;

// Get all trigger events that are used in the statemachine.
Set[String] getTriggerEvents(StateMachine sm):
 let transitions = sm.getTransitions() :
 transitions.select(e|e.name.toString().contains("/")).trigger2()
;

// INTERNAL: Helpermethod for action extraction
Set[String] getAction(StateMachine sm):
 let transitions = sm.getTransitions() :
 transitions.select(e|e.name.toString().contains("/")).action2()
;

//-----------------------------------------------------------------------------

Set[Transition] getTransitions(StateMachine sm):
 ((Set[Transition])sm.eAllContents.select(e|e.metaType == Transition))
;

Set[Pseudostate] getForkJoin(StateMachine sm):
 ((Set[Transition])sm.eAllContents.select(e|e.metaType == Pseudostate && ( ((Vertex)e).isJoin() || ((Vertex)e).isFork() ) ))
;

Set[Vertex] getStates(StateMachine sm):
 //ToDo: FinalState is State ?!?
 ((Set[Vertex])sm.eRootContainer.eAllContents.select(e|e.metaType == State || e.metaType == FinalState))
;

Set[Vertex] getHistoryStates(StateMachine sm):
 ((Set[Vertex])sm.eRootContainer.eAllContents.select(e|e.metaType == Pseudostate && ((((Vertex)e).isDH())||((Vertex)e).isSH())))
;

Set[String] getHistoryMaudeStates(StateMachine sm):
 ((Set[State])sm.getHistoryStates()).fullyHistoryHelp()
;

Set[String] getMaudeStates(StateMachine sm):
 ((Set[State])sm.getStates()).fullyHelp()
;

Set[Region] getRegions(StateMachine sm):
 ((Set[Region])sm.eAllContents.select(e|e.metaType == Region))
;

Set[String] getMaudeRegions(StateMachine sm):
 ((Set[Region])sm.getRegions()).fullyHelp()
;

State getParent(Region region):
 (State)region.eContainer()
;

Region getParent(State state):
 (Region)state.eContainer()
;

Region getParent(Pseudostate state):
 (Region)state.eContainer()
;

// 
//Set[Vertex] getSourceStates(Transition n)
//  
//;
// Transitions are tuples of:
// sources Triggerevent guard Action ListofForkActions ListofJoinActions targets containingRegion
String genMaude(Transition n):
 // ToDo: generate source and target sets
 //(n.source).toString() + '   ' + (n.target).toString() + '   ' + n.trigger2() + '   ' + n.action2()+ '   ' +((Region)n.container).getId()
 '   eq tr'+n.getId()+ ' = '+
// sources (States only)
 '('+(n.source.getId()) + ') ' +
// 'empty '+ 
// Triggerevent
 n.trigger2() + 
// guard 
 ' Gd ' + 
// Action
 n.action2() + 
// ListofForkActions ListofJoinActions
 ' skip skip ' +
// targets (States and history pseudostates only)
 '('+n.target.getId()+') ' +
// containingRegion
 ((Region)n.eContainer()).getId() + ' .'   
;



Set[Transition] getTransitionsOP(StateMachine sm):
  let transitions = sm.getTransitions() :
  transitions.select(e|(e.source).metaType == Pseudostate)
;

Set[Transition] getInitialTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isInitial())
;

Set[Transition] getDHDTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isDH())
;

Set[Transition] getSHDTransitions(StateMachine sm):
  let transitions = sm.getTransitionsOP() :
  transitions.select(e|(e.source).isSH())
;


String genDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq def'+region.getId()+ ' = ' + region.getId() + ' default ' + ((State)tr.target).getId()+ ' .\n'  
;

String genDHDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq dDef'+region.getId()+ ' = ' + region.getId() + ' deepdefault ' + ((State)tr.target).getId()+ ' .\n'  
;
String genSHDefault(Transition tr):
  let region = ((Pseudostate) tr.source).getParent() :
  ' eq sDef'+region.getId()+ ' = ' + region.getId() + ' shallowdefault ' + ((State)tr.target).getId()+ ' .\n'  
;

String fullyHelp(Region n):
 //'op R'+n.getId()+' : -> Region .\n'+
 '    eq '+n.getId()+' = '+ n.fullyQualifiedName()
;
String fullyHelp(State n):
 //'op C'+n.getId()+' : -> ModState .\n'+
 '    eq '+n.getId()+' = '+ n.fullyQualifiedName()
;
String fullyHistoryHelp(Pseudostate n):
 //'op C'+n.getId()+' : -> ModState .\n'+
  if (n.isDH()) then
 '    eq '+n.getId()+' = '+ ((Region)n.eContainer()).fullyQualifiedName() + ' : H*'
 else
 '    eq '+n.getId()+' = '+ ((Region)n.eContainer()).fullyQualifiedName() + ' : H'
;

Set[Vertex] allVertexs(StateMachine sm):
 ((Set[Vertex])sm.eAllContents.select(e|(e.metaType == Region)||(e.metaType == State)))
; 


String fullyQualifiedName(Region n) : n.getParent().metaType == StateMachine ? 'root(R "'+n.getId()+'")' :
   fullyQualifiedName(n.getParent())+' : R "'+n.getId()+'"'
;
String fullyQualifiedName(State n) : n.getParent() == null ? n.getId() :
   fullyQualifiedName(n.getParent())+' : C "'+n.getId()+'"'
;




//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

List[Transition] getIncomingTransitions(Vertex vertex) :
   vertex.eRootContainer.eAllContents.select(e|e.metaType == Transition && ((Transition)e).target == vertex)
;

//-----------------------------------------------------------------------------

List[Transition] getOutgoingTransitions(Vertex vertex) :
   vertex.eRootContainer.eAllContents.select(e|e.metaType == Transition && ((Transition)e).source == vertex)
;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

// Checks whether a transition is eligible to be considered by the maude code
// generation or in the other case is already handled by the maude simulatior
// implicitly. 
Boolean isConsidered(Transition transition):
  let source = transition.source:
  let target = transition.target:
  !(source.isInitial() || source.isDH() || source.isSH() || source.isFork() || source.isJoin()
  || target.isFork() || target.isJoin())
;

//-----------------------------------------------------------------------------

// Clear all done marked vertices
Void clearDoneVertices():
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.clearDoneVertices()  
;

// Returns true iff the vertex (pseudostate fork or join) has already been
// checked and not needs to be visited again.
// It means that already exists a transition containing it.
boolean isDone(Vertex vertex, String id):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isDone(org.eclipse.uml2.uml.Vertex, java.lang.String)  
;

// Mark a vertex (pseudostate fork or join) that has just been visited
boolean markDone(Vertex vertex, String id):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.markDone(org.eclipse.uml2.uml.Vertex, java.lang.String)  
;

//-----------------------------------------------------------------------------

// Set a new last root region iff the new region is on a higher hierarchy level
Void setLastRootRegion(Region region) :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.setLastRootRegion(org.eclipse.uml2.uml.Region)  
;

// Reset the last root region
Void resetLastRootRegion() :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.resetLastRootRegion()  
;

// Get the last root region
Region getLastRootRegion() :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getLastRootRegion()  
;

//-----------------------------------------------------------------------------

// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
// The method will also set the root region of that complex transition and will
// determine the trigger, guard and actio of the complex transition.
Set[Vertex] getPseudoTargetVertices(Pseudostate pseudostate) :
    let reset = resetLastRootRegion():
    let reset2 = resetComplexTransitionInformation():
    // get all transitions that have a fork or join as a target
    let allTransitionList = getAllPseudostateTransitions(pseudostate,"OUTGOING"):
    let selectedTransitionList = allTransitionList.select(e|e.source.metaType == Pseudostate
         && ( e.source.isJoin() || e.source.isFork() )) :
    // Add information about complex transition for all sub-transitions
    allTransitionList.trigger2().addComplexTransitionInformation("TRIGGER") ->
    allTransitionList.action2().addComplexTransitionInformation("ACTION") ->
//    allTransitionList.trigger2().addComplexTransitionInformation("GUARD") ->
    // Return all target vertices
    selectedTransitionList.target
;

//-----------------------------------------------------------------------------

// This returns all nodes for a join or fork pseudostate
// It will return null otherwise
// The method will also set the root region of that complex transition and will
// determine the trigger, guard and actio of the complex transition.
Set[Vertex] getPseudoSourceVertices(Pseudostate pseudostate) :
    let reset = resetLastRootRegion():
    let reset2 = resetComplexTransitionInformation():
    // get all transitions that have a fork or join as a target
    let allTransitionList = getAllPseudostateTransitions(pseudostate,"INCOMING") :
    let selectedTransitionList = allTransitionList.select(e|e.target.metaType == Pseudostate
         && ( e.target.isJoin() || e.target.isFork() )) :
    // Add information about complex transition for all sub-transitions
    allTransitionList.trigger2().addComplexTransitionInformation("TRIGGER") ->
    allTransitionList.action2().addComplexTransitionInformation("ACTION") ->
//    allTransitionList.trigger2().addComplexTransitionInformation("GUARD") ->
    // Return all source vertices
    selectedTransitionList.source
;

//-----------------------------------------------------------------------------

// INTERNAL: This will calculate all transitions for a complex transition that
// are either INCOMING or OUTGOING. These will be marked to be visited for
// one of both ids. The search (including backtracking) is exactly the same.
Set[Transition] getAllPseudostateTransitions(Pseudostate pseudostate, String id) :
   let incomingList = (List[Transition])pseudostate.getIncomingTransitions():
   let outgoingList = (List[Transition])pseudostate.getOutgoingTransitions():
   let incomingOutgoingList = {}:
   incomingOutgoingList.addAll(incomingList) ->
   incomingOutgoingList.addAll(outgoingList) ->
  if (markDone(pseudostate, id)) then (
  	 // Set the last root region of this pseudostate, if it is hierarchically higher
  	 // than it will be saved, otherwise it will be ignored
     setLastRootRegion(((Region)pseudostate.eContainer())) ->
     getAllPseudostateTransitions2(incomingOutgoingList, id)
  ) else
     {}
;

// INTERNAL: This helper method will add the firstTransition to a list and return this in the
// case that the transition target is neither a fork or join node,
// otherwise it will recursively call and add transitions for that fork/join node.
Set[Transition] helperTarget(Vertex firstTransitionTarget, Transition firstTransition, String id) :
  let outList = {}:
  // add outgoing transitions to 'normal vertices'
  if (!firstTransitionTarget.isFork() && !firstTransitionTarget.isJoin()) then
      outList.add(firstTransition)
  else
     outList.addAll(getAllPseudostateTransitions((Pseudostate)firstTransitionTarget, id))
  ->
  outList
;

// INTERNAL: This helper method will add the firstTransition to a list and return this in the
// case that the transition source is neither a fork or join node,
// otherwise it will recursively call and add transitions for that fork/join node.
Set[Transition] helperSource(Vertex firstTransitionSource, Transition firstTransition, String id) :
  let outList = {}:
  // add incoming transitions from 'normal vertices'
  if (!firstTransitionSource.isFork() && !firstTransitionSource.isJoin()) then
      outList.add(firstTransition)
  else 
     outList.addAll(getAllPseudostateTransitions((Pseudostate)firstTransitionSource, id))
  ->
  outList
;

// INTERNAL: This helper method will add all transitions eigther incoming or outgoing ones
// that belong to the complex transition. This may result in subsequent recursive calls.
Set[Transition] getAllPseudostateTransitions2(List[Transition] transitionList, String id) :
  let firstTransition = transitionList.first():
  let firstTransitionSource = firstTransition.source:
  let firstTransitionTarget = firstTransition.target:
  let outList = {}:
  outList.addAll(helperTarget(firstTransitionTarget, firstTransition, id)) ->
  outList.addAll(helperSource(firstTransitionSource, firstTransition, id)) ->
  // add possibly other transitions
  if (transitionList.withoutFirst().size > 0) then
     outList.addAll(getAllPseudostateTransitions2(transitionList.withoutFirst(), id))
  else 
     {}
  ->
  outList
;

//-----------------------------------------------------------------------------

// Get the alias of a vertex
String getAlias(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAlias(org.eclipse.uml2.uml.Vertex)
;

// Get the alias of a transition
String getAlias(Transition transition):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getAlias(org.eclipse.uml2.uml.Transition)
;

// Test whether a vertex is of type Initial
Boolean isInitial(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isInitial(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Deep History
Boolean isDH(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isDH(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Shallow History
Boolean isSH(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isSH(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Fork
Boolean isFork(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isFork(org.eclipse.uml2.uml.Vertex)
;

// Test whether a vertex is of type Join
Boolean isJoin(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.isJoin(org.eclipse.uml2.uml.Vertex)
;

//-----------------------------------------------------------------------------

// Get the ID of a region
String getId(Region region):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Region)
;

// Get the ID of a vertex
String getId(Vertex vertex):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Vertex)
;

// Get the ID of a transition
String getId(Transition transition):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getId(org.eclipse.uml2.uml.Transition)
;

// Get the hash value of a String
String hash(String string):
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.hash(java.lang.String)
;

//-----------------------------------------------------------------------------

// Do not print out a string, this can help for an Xpand template when whe 
// want to call a method but don't want to write out the resulting return values.
Void ignore(String string) :
  null  
;

//-----------------------------------------------------------------------------

// Add a Pseudostate to a temporary list
Void addPseudostate(Pseudostate pseudostate) :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.addPseudostate(org.eclipse.uml2.uml.Pseudostate)
;
	
// Get the saved Pseudostates
List[Pseudostate] getPseudostates() :
  JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getPseudostates()
;
	
// Reset the Pseudostates
Void resetPseudostates() :
 JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.resetPseudostates()
;	

//-----------------------------------------------------------------------------

// Add information about a complex transition (id == TRIGGER, GUARD or ACTION)
Void addComplexTransitionInformation(String item, String id) :
 JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.addComplexTransitionInformation(java.lang.String, java.lang.String)
;

// Get information about a complex transition (id == TRIGGER, GUARD or ACTION)
List[String] getComplexTransitionInformation(String id) :
 JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.getComplexTransitionInformation(java.lang.String)
;

// Reset information about a complex tranistion
Void resetComplexTransitionInformation() :
 JAVA de.cau.cs.kieler.uml2.sim.JavaEscape.resetComplexTransitionInformation()
;
