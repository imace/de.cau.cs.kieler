load EVENTS
load ACTIONS
load TAC

****************************************************************
*** ToDos in diesem File
*** - mode of execution ueberarbeiten
*** 
****************************************************************


fmod MODTRANSITION is
  including EVENTS .
  including STATES .
  including ACTIONS .

  sorts Guard ModTransition Menge .

  op ________ : Verts Event Guard Actions Actions Actions Verts Region -> 
	  ModTransition [ctor format (n d d d d d d d n)] .

  op _____ : Verts Event Actions Verts Region -> 
	  ModTransition [ctor format (n d d d d n)] .

  *** guards are abstract	  
  op Gd : -> Guard [ctor] .
 
  vars src tgt : Verts . 
  vars e : Event .
  vars g : Guard .
  vars a af aj : Action .
  vars A AF AJ : Actions .
  vars lreg : Vert .

  op source _ : ModTransition -> Verts .
  eq source (src e g A AF AJ tgt lreg) = src .
  eq source (src e A tgt lreg) = src .

  op target _ : ModTransition -> Verts .
  eq target (src e g A AF AJ tgt lreg) = tgt .
  eq target (src e A tgt lreg) = tgt .
	
  op region _ : ModTransition -> Region .
  eq region (src e A a AF AJ tgt lreg) = lreg .
  eq region (src e A tgt lreg) = lreg .
  
  op event_ : ModTransition -> Event .
  eq event(src e g A AF AJ tgt lreg) = e .
  eq event (src e A tgt lreg) = e .
  
  
endfm


view ModTransition from TRIV to MODTRANSITION is
  sort Elt to ModTransition .
endv

view Menge from TRIV to MODTRANSITION is
  sort Elt to Menge .
endv


fmod TRANSITIONS is
  including EVENT .
  including STATES .
  including ACTIONS .
  including SET{ModTransition} * (sort Set{ModTransition} to Transitions, sort NeSet{ModTransition} to NeTransitions) .
  including SET{Menge} * (sort Set{Menge} to Mengen, sort NeSet{Menge} to NeMengen) .
***  including SET{TransitionSet} * (sort Set{TransitionSet} to TransitionSets, sort NeSet{TransitionSet} to NeTransitionSets) .

  vars T T2 F : Transitions .
  vars NeT : NeTransitions .
  vars t t2 : ModTransition .
  vars src tgt src2 tgt2 C : Verts . 
  vars e e2 fe : Event .
  vars g g2 : Guard .
  vars A AF AJ A2 AF2 AJ2 actions : Actions .
  vars a af aj a2 af2 aj2 action : Action .
  vars lreg lreg2 : Vert .
  var str : String .  
  vars M N : Menge .
  vars MN NN : Mengen .
  vars NeMN : NeMengen .
  
   
  op mm_ : Transitions -> Menge .
  
    
  op conflict__ : ModTransition Transitions -> Bool .
  eq conflict t (t2, T) = ((prefix (region t) (region t2)) or 
        			(prefix (region t2) (region t))) or 
  						(conflict t T) .
  eq conflict t empty = false .


  op events_ : Transitions -> Events .
  eq events(t, T) = (event t) (events T) .
  eq events empty = nil .
  
  op actions_ : ModTransition -> Actions .
  eq actions(src e g A AF AJ tgt lreg) = A AF AJ .


  *** wo verwendet ?
  op actionsAll_ : ModTransition -> Actions .
  eq actionsAll(src e g A AF AJ tgt lreg) = A AF AJ .

  *** wo verwendet ?  
  op actionsJoin_ : ModTransition -> Actions .
  eq actionsJoin(src e g A AF AJ tgt lreg) = AJ .
  *** wo verwendet ?  
  op actionsFork_ : ModTransition -> Actions .
  eq actionsFork(src e g A AF AJ tgt lreg) = AF .
  *** wo verwendet ?
   op actionsMain_ : ModTransition -> Actions .
  eq actionsMain(src e g A AF AJ tgt lreg) = A .
  
  *** explain
  op getAcExp_ : ModTransition -> Action .
  eq getAcExp(src e g A AF AJ tgt lreg) = seq(A AF AJ) .

  op remLowPrio_ : Transitions -> Transitions .
  eq remLowPrio T = $remLowPrio empty T .
   
  op $remLowPrio__ : Transitions Transitions -> Transitions .
  ceq $remLowPrio T (T2, t) = $remLowPrio (T, t) T2 if noHigherPrioUML t (T, T2) .
  eq $remLowPrio T (T2, t) = $remLowPrio T T2 [owise] .
  eq $remLowPrio T empty = T .
  
      
  op noHigherPrio__ : ModTransition Transitions -> Bool .
  eq noHigherPrio t T = noHigherPrioUML t T .
  
  

  op noHigherPrioSC__ : ModTransition Transitions -> Bool .
  eq noHigherPrioSC t t2 = not (prefix (region t2) (region t) and (region t2) =/= (region t)) .
  eq noHigherPrioSC t empty = true .
  eq noHigherPrioSC t (T ,  t2) = (noHigherPrioSC t t2) and (noHigherPrioSC t T) .

  op noHigherPrioUML__ : ModTransition Transitions -> Bool .
  eq noHigherPrioUML t t2 = not (containsSuper (source t2) (source t)) .
  eq noHigherPrioUML t empty = true .
  eq noHigherPrioUML t (T ,  t2) = (noHigherPrioUML t t2) and (noHigherPrioUML t T) .
  
  
  op actionConflicts_ : Transitions -> Bool .
  eq actionConflicts (t, T) = (actionConflict t) or
      				($actionConflicts t T) or
  						(actionConflicts T) .
  eq actionConflicts empty = false . 	 

  op $actionConflicts__ : ModTransition Transitions -> Bool .
  eq $actionConflicts t (t2, T) = 
  	(neIntersection ((actionsAll t),(actionsAll t2))) or 
  	($actionConflicts t T) .
  eq $actionConflicts t empty = false . 	 
  
  *** conflict whithin a single compound transition
  op actionConflict_ : ModTransition -> Bool .
  eq actionConflict t = actionConflictPar (actionsJoin t) or
  					actionConflictPar (actionsFork t) .  
    
  op enabled___ : Verts Event Transitions -> Transitions [memo] .
  eq enabled C e (T ,  t) = ($enabled C e t) ,  (enabled C e T) .
  eq enabled C e empty = empty .
  op $enabled___ : Verts Event ModTransition -> ModTransition [memo] .
  ceq $enabled C e t = t if ((source t) subset C) and (event t)== e [label transenab] . 
  eq $enabled C e t = empty [owise] .

  op leave __ : Verts Transitions -> Verts .
  eq leave C empty = empty .
  eq leave C (src e g A AF AJ tgt lreg) =  intersection((upset lreg C) \ lreg, C) .
  eq leave C (T ,  t) = (leave C T) ,  (leave C t) .

  *** fire ist so deterministisch
  op fire _____ : String Verts Event Transitions Transitions -> Transitions [memo] .
  eq fire "UML" C fe T F = fireUML C fe T F .
  eq fire str C fe T F = fireSC C fe T F [owise] .
 
  op fireSC ____ :  Verts Event Transitions Transitions -> Transitions .
  ceq fireSC C fe (t, T) F = fireSC C fe T (F, t)
    if not (conflict t F) and (noHigherPrioSC t T) [label fire1] .
  eq fireSC C fe empty F = F .
  eq fireSC C fe (t, T) F = fireSC C fe T F [owise] .

  op fireUML ____ :  Verts Event Transitions Transitions -> Transitions .
  ceq fireUML C fe (T, t, T2) F = fireUML C fe (T, T2) (F, t)
    if not (conflict t F) and (noHigherPrioUML t (T, T2)) [label fire1] .
  eq fireUML C fe empty F = F .
  eq fireUML C fe (T, t, T2) F = fireUML C fe (T, T2) F [owise] .


  *** here we require a set transitons which is not free of conflicting transitions but these 
  *** are not related by the priority relation.
  
   
  op prettyTrans_ :  ModTransition -> ModTransition .
  eq prettyTrans (src e g A AF AJ tgt lreg) = 
    (prettyVerts src) e g A AF AJ (prettyVerts tgt) (prettyVerts lreg) .
  eq prettyTrans (src e A tgt lreg) = 
    (prettyVerts src) e A (prettyVerts tgt) (prettyVerts lreg) .
  

  op prettyTrans_ : Transitions -> Transitions .
  eq prettyTrans (empty).ModTransition = (empty).ModTransition .
  eq prettyTrans (t, T) = 
    prettyTrans t, prettyTrans T .
    
  op prettyTrans_ : Mengen -> Mengen .
  eq prettyTrans ((mm(T)), MN) = mm(prettyTrans T), (prettyTrans MN) .
  eq prettyTrans (mm(T)) = mm(prettyTrans T) .
  eq prettyTrans (empty).Menge = (empty).Menge .
  
  op prettyTToT__ : Transitions Transitions -> Transitions [memo] .
  eq prettyTToT T (T2, t) = (prettyTToT T T2), ($prettyTToT T t) .
  eq prettyTToT T empty = empty .

  op $prettyTToT__ : Transitions Transitions -> Transitions [memo] .
  ceq $prettyTToT (T, t) t2 = t if (prettyTrans t) == t2 .
  eq $prettyTToT (T, t) t2 = empty [owise] .


  op pT_ : Transitions -> Transitions .
  eq pT T = prettyTrans T .

  op pT_ : Mengen -> Mengen .
  eq pT MN = prettyTrans MN .

  op getConflTrans__ : ModTransition Transitions -> Transitions .
  ceq getConflTrans t (t2, T) = t2, (getConflTrans t T) if (conflict t t2) .
  eq getConflTrans t (t2, T) = (getConflTrans t T) [owise] .
  eq getConflTrans t empty = empty .
  

  op getConflSets_ : Transitions -> Mengen .
  ceq getConflSets (t, T) = mm((getConflTrans t T), t), getConflSets (T \ ((getConflTrans t T),t)) 
      if (getConflTrans t T) =/= (empty).ModTransition .
  eq getConflSets (t, T) = mm (t), getConflSets T [owise] .
  eq getConflSets (empty).ModTransition = (empty).Menge . 
  
  op getDeepestScope_ : Transitions -> Transitions .
  eq getDeepestScope T = $getDeepestScope T empty .
  
  op $getDeepestScope__ : Transitions Transitions -> Transitions .
  eq $getDeepestScope empty T = T .
  eq $getDeepestScope (t, T) empty = $getDeepestScope (t, T) t .
  ceq $getDeepestScope (t, T) (t2, T2) = $getDeepestScope T (t, t2, T2) 
    if len(region(t)) == len(region(t2)) .
  ceq $getDeepestScope (t, T) (t2, T2) = $getDeepestScope T t 
    if len(region(t)) > len(region(t2)) .
  eq $getDeepestScope (t, T) (t2, T2) = $getDeepestScope T (t2, T2) 
    [owise] .
  
  op getDeepestSource_ : Transitions -> Transitions .
  eq getDeepestSource T = $getDeepestSource T empty .
  
  op $getDeepestSource__ : Transitions Transitions -> Transitions .
  eq $getDeepestSource empty T = T .
  eq $getDeepestSource (t, T) empty = $getDeepestSource (t, T) t .
  ceq $getDeepestSource (t, T) (t2, T2) = $getDeepestSource T (t, t2, T2) 
    if len(source(t)) == len(source(t2)) .
  ceq $getDeepestSource (t, T) (t2, T2) = $getDeepestSource T t 
    if len(source(t)) > len(source(t2)) .
  eq $getDeepestSource (t, T) (t2, T2) = $getDeepestSource T (t2, T2) 
    [owise] .
    
		

  ******************************************************************
  *** das funktioniert jetzt
  ******************************************************************
  *** alle (Konflikt) Transitionen jeweils mit der Menge kombinieren
  *** Ceq erklaeren
  op $allIntoAll__ : Transitions Menge -> Mengen .
  ceq $allIntoAll (t, T) mm(T2) = mm(t, T2), ($allIntoAll T mm(T2)) if (getConflTrans t T2) == empty .
  eq $allIntoAll (t, T) mm(T2) = mm(t, (T2 \(getConflTrans t T2))), mm(T2), ($allIntoAll T mm(T2)) [owise] .
  eq $allIntoAll empty M = empty .
 
   *** alle (Konflikt) Transitionen mit allen Mengen kombinieren
  op allIntoAll__ : Transitions Mengen -> Mengen .
  eq allIntoAll T (M, NeMN) = ($allIntoAll T M), (allIntoAll T NeMN) .
  eq allIntoAll T M = $allIntoAll T M .
  eq allIntoAll (t, T) empty = mm(t), (allIntoAll T empty) .
  eq allIntoAll empty empty = empty .
  *** alle Mengen von (Konflikt) Transitionen miteinander kombinieren
  *** wir kombinieren jeweils eine Transition aus jeder Menge von Transitionen
  *** zu Mengen von Transitionen 
  op allSetsIntoAll__ : Mengen Mengen -> Mengen .
  eq allSetsIntoAll ((mm T), MN) NN  = (allSetsIntoAll MN (allIntoAll T NN)) .
  eq allSetsIntoAll empty MN = MN .


  *** Transitionen mit vergleichbarer und niedrigerer Prioritaet werden mit remLowPrio
  *** zuvor entfernt.  
  *** von den simple states (Blaettern) ausgehend zur root region (getDeepestScope NeT) 
  *** die Menge der Mengen feuerbarer Transitionen MN um die (Konflikt)Transitionen 
  *** auf diesem Level(Abstand zur root Region) in der State Hierarchy erweitern
  *** es ist moeglich, dass in einer hoeher gelegenen region ein Transition im Konflikt mit bereits 
  *** hinzugefuegten Transitionen ist.
  *** Im Jarnal Beispiel sind das die Transitionen 0,1,4 oder 5 mit der Transition 3
  *** Dann haben wir 2 Mengen feuerbarer Transitionen:
  ***  - die gegebene Menge ohne 0,1,4 und 5 aber mit 3 also mm(t, (T2 \(getConflTrans t T2))) und 
  ***  - die unveraenderte Menge, mit einer passenden Kombination von 0,1,4 und 5 ohne 3 mm(T2)	
  *** siehe dazu vorallem oben bei $allIntoAll 
  ******************************************************************
  *** das funktioniert 
  ******************************************************************   
  op fireIter__ : Transitions Mengen -> Mengen .
  *** eq fireIter T MN = fireIter (T \(getDeepestScope T)) (allSetsIntoAll getConflSets(getDeepestScope T) MN) .
  eq fireIter NeT MN = fireIter (NeT \(getDeepestScope NeT))  (allSetsIntoAll(getConflSets(getDeepestScope NeT)) MN) .
  eq fireIter empty MN = MN .

 endfm