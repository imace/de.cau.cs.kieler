load TSM 

fmod FIRESET is
  including TRANSITIONS .
  sort Fireset .
  op FS_ : Transitions -> Fireset .
endfm

view Fireset from TRIV to FIRESET is
	sort Elt to Fireset .
endv 

mod STEPSEM is 
    including SET{Fireset} * (sort Set{Fireset} to Firesets, sort NeSet{Fireset} to NeFiresets) .
    
    including STATEMACHINE .
    including TSM .
	var FSet : Firesets .
	var fs : Fireset .

	eq FS empty = empty .
	op prettyFS_ : Firesets -> Firesets .
	eq prettyFS empty = empty .
	eq prettyFS ((FS T), FSet) = (FS (prettyTrans T)), prettyFS FSet .

	
    sorts LtsState .

	op SMINT : -> StateMachine .
	eq SMINT = smHCFPB .
	
	*** eq SMINT = smHCConflB .

	var mastate : MState .
	op maState___ : String Configuration Events -> MState [ctor format (r d d d n)] .
	op maState___ : String Configuration EventSS -> MState [ctor format (r d d d n)] .

    
    sort Configuration .
    var configuration : Configuration .
    op unstableC_____ : StateMachine Verts HistoryConfs Transitions Action -> Configuration [format (n n n n n n n )] .
    op stableC___ : StateMachine Verts HistoryConfs -> Configuration .  
    op $fireC___ : Verts HistoryConfs Mengen -> Configuration .  
    op $unstableC____ : Verts HistoryConfs Transitions Action -> Configuration .
    op $stableC__ : Verts HistoryConfs -> Configuration .
    op $prestepC___ : Verts HistoryConfs Firesets -> Configuration .

	sort MState .	
	var mode : String .
	var mstate : MState .

    *** 	modelling a transition :
    ***x 	(src e g a af aj tgt lreg)
    vars src tgt src2 tgt2 : Verts . 
    vars e e2 : Event .
    vars g g2 : Guard .
    vars a af aj a2 af2 aj2 action : Actions .
    vars A AF AJ A2 AF2 AJ2 actions : Actions .
    vars lreg lreg2 : Vert .
	


    vars  ENA : EntryActions .
    vars  EXA : ExitActions .

    vars sm : StateMachine .
    vars HC : HistoryConfs .
    vars hc : HistoryConf .
    vars C2 : States . *** Konfiguration
    vars fe : Event . *** event selected for this rtc step
    vars E E2 : Events .
    vars ES ES2 : EventSS .
    vars C C' V V2 S : Verts .
    vars T T1 T2 F : Transitions .
    vars t t1 t2 : ModTransition .
    vars S2 : States .
    vars s :ModState .
    vars s2 s3 ds1 ds2 : ModState .
    vars V_vert V_vert2 : Vert .
    vars R : Regions .
    vars r r2 r3 : Region .
    vars c : CompositeName .
    vars shn : HistShallowName .
    vars dhn : HistDeepName .
    vars D : Defaults .
    vars d : Default .
    vars SH : ShallowDefaults .
    vars sh : ShallowDefault .
    vars DH : DeepDefaults .
    vars dh : DeepDefault .
    vars str : String .
    vars MN : Mengen .
 
    *** A labeled transition system state consists of:
    *** a state machine, a configuration, a historyconf and an Eventqueue
    
    op $fire _____ : String Verts Event Transitions Transitions -> Firesets [memo] .
    eq $fire "UML" C fe T F = $$fireUML C fe T F .
    eq $fire str C fe T F = FS (fireSC C fe T F) [owise] .
 
    *** remove transitions where prirority is defined to be lower
    op $$fireUML ____ :  Verts Event Transitions Transitions -> Firesets .    	
    ceq $$fireUML C fe (t, T) F = $$fireUML C fe T F 
    	if (conflict t T) and not (noHigherPrioUML t T) [label fire1] .
	eq $$fireUML C fe empty F = ($fireUML C fe F empty) .
	eq $$fireUML C fe (t, T) F = $$fireUML C fe T (F, t) [owise] .     	

    op $fireUML ____ :  Verts Event Transitions Transitions -> Firesets .    	
    ceq $fireUML C fe (t, T) F = $fireUML C fe T (F, t) 
    	if not (conflict t (F,T)) [label fire1] .
    ceq $fireUML C fe (t, T) F = ($fireUML C fe T (F, t)), ($fireUML C fe T F) 
    	if (conflict t T) and not (conflict t F) [label fire1] .
    ceq $fireUML C fe (t, T) F = ($fireUML C fe T F) 
    	if (conflict t F) [label fire1] .
	eq $fireUML C fe empty F = FS (fireUML C fe F empty) .
  
	op firesEvent__ : MState Event -> Bool .
	eq firesEvent (machineState mode (SM V D SH DH T) C (e E)) e = true .
	eq firesEvent (machineState mode (SM V D SH DH ENA EXA T) C (e E)) e = true .
	eq firesEvent mstate e = false [owise] .
	
	op actionConflicts_ : MState -> Bool .
	eq actionConflicts (fireState mode (SM V D SH DH T) C (e E)) = actionConflicts (fire mode C e (enabled C e T) empty) .
	eq actionConflicts (fireState mode (SM V D SH DH ENA EXA T) C (e E)) = actionConflicts (fire mode C e (enabled C e T) empty) .
	eq actionConflicts mstate = false [owise] .
	 
	op isStopped_ : MState -> Bool .
	eq isStopped (stopState mode (SM V D SH DH T) C E) = true .
	eq isStopped (stopState mode (SM V D SH DH ENA EXA T) C E) = true .
	eq isStopped mstate = false [owise] .  

	op machineState____ : String StateMachine Verts Events -> MState [ctor] .

	op fireState____ : String StateMachine Verts Events -> MState [ctor] .
	op stopState____ : String StateMachine Verts Events -> MState [ctor] .

	
	op prettyMState_ : MState -> MState .
	eq prettyMState (stopState mode sm C E) = 
		(stopState mode (prettySm sm) (prettyVerts C) E) . 

    op actionConflict_ : MState -> Bool .
    eq actionConflict (maState mode (unstableC sm V HC T a) E) = actionConflict a .
    eq actionConflict (maState mode ($unstableC V HC T a) E) = actionConflict a .    
	eq actionConflict mastate = false [owise] .    

    op acConfl_ : MState -> Bool .
    eq acConfl (maState mode ($unstableC V HC T a) ES) = acConfl (maState mode ($unstableC V HC T a) (nil).Events) .
    eq acConfl (maState mode (unstableC sm V HC T a) E) = actionConflict a .
***    eq acConfl (maState mode ($unstableC V HC T a) E) = actionConflict a .
    eq acConfl (maState mode ($unstableC V HC (t,T) a) E) = actionConflict
    (par (a seq(
				(getExitAc SMINT (prettyVToV (getVerts SMINT) V) (region (prettyTToT (getTrans SMINT) t))) 
				(getAcExp (prettyTToT (getTrans SMINT) t))
				(getEntryAc SMINT (prettyHCToHC (getVerts SMINT) HC) (target (prettyTToT (getTrans SMINT) t)) (region (prettyTToT (getTrans SMINT) t)))
				))) .
	eq acConfl mastate = false [owise] .    

	op firesT__ : MState Transitions -> Bool .
	eq firesT (maState mode (unstableC sm C HC T a) E) T2 = T2 subset T .
	eq firesT (maState mode ($unstableC C HC T a) E) T2 = T2 subset T .
	eq firesT mstate T = false [owise] .  

	op inConf__ : MState Verts -> Bool .
	eq inConf (maState mode (unstableC sm C HC T a) E) V2 = (prettyVerts V2) subset C .
	eq inConf (maState mode (stableC sm C HC) E) V2 = (prettyVerts V2) subset C .
	eq inConf (maState mode ($stableC C HC) E) V2 = (prettyVerts V2) subset C .
	eq inConf (maState mode ($stableC C HC) ES) V2 = inConf (maState mode ($stableC C HC) (nil).Events) V2 .
	eq inConf mstate V = false [owise] .  
	 
	op inHConf__ : MState Verts -> Bool .
	eq inHConf (maState mode (unstableC sm C HC T a) E) V2 = V2 == (getHC (start V2) HC) .
	eq inHConf (maState mode (stableC sm C HC) E) V2 = V2 == (getHC (start V2) HC) .
	eq inHConf (maState mode ($unstableC C HC T a) E) V2 = V2 == (getHC (start V2) (prettyHCToHC (getVerts SMINT) HC)) .
	eq inHConf (maState mode ($stableC C HC) E) V2 = V2 == (getHC (start V2) (prettyHCToHC (getVerts SMINT) HC)) .
	eq inHConf (maState mode ($stableC C HC) ES) V2 = inHConf (maState mode ($stableC C HC) (nil).Events) V2 .
	eq inHConf mstate V = false [owise] .  	
			  		
***(
	crl [computeFSetESINT] : maState mode ($stableC V HC) (e, ES) => 
		maState mode ($prestepC V HC ($fire mode (getVerts SMINT) e (enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) empty)) (e, ES) if
		(enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) =/= empty .
)***
	crl [computeFSetESINT] : maState mode ($stableC V HC) (e, ES) => 
		maState mode ($fireC V HC 
			(fireIter 
				(remLowPrio 
					(enabled 
						(prettyVToV (getVerts SMINT) V) 
						e (getTrans SMINT)
					)
				) 
			empty) 
		) (e, ES) if
		(enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) =/= empty .
	rl [fireFSetESINT] : maState mode ($fireC V HC (mm(T), MN)) ES => 
		maState mode ($unstableC V HC (prettyTrans T) (par nil)) ES .
	***(	
	crl [discardESINT] : maState mode ($stableC V HC) (e, ES) => 
		maState mode ($stableC V HC) (e, ES) if
		(fire mode (getVerts SMINT) e (enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) empty) == empty .
	)***	
	rl [execTransESINT] : maState mode ($unstableC V HC (t, T) (par A)) ES => 
		maState mode ($unstableC prettyVerts(((prettyVToV (getVerts SMINT) V) \ (leave (prettyVToV (getVerts SMINT) V) (prettyTToT (getTrans SMINT) t))) , (enterH SMINT (prettyHCToHC (getVerts SMINT) HC) (prettyTToT (getTrans SMINT) t))) HC T 
		(par (A 
			seq(
				(getExitAc SMINT (prettyVToV (getVerts SMINT) V) (region (prettyTToT (getTrans SMINT) t))) 
				(getAcExp (prettyTToT (getTrans SMINT) t))
				(getEntryAc SMINT (prettyHCToHC (getVerts SMINT) HC) (target (prettyTToT (getTrans SMINT) t)) (region (prettyTToT (getTrans SMINT) t)))
				)
		))) 
		ES .
	rl [finishedRTCESINT] : maState mode ($unstableC V HC empty (par A)) ES => 
		maState mode ($stableC V prettyHc(succHC (prettyVToV (getVerts SMINT) V) (prettyHCToHC (getVerts SMINT) HC))) ES .
		
	crl [fireTransINT] : maState mode ($stableC V HC) (E e E2) => 
		maState mode ($unstableC V HC (fire mode (getVerts SMINT) e (enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) empty) (par nil)) (E E2 e) if
		(fire mode (getVerts SMINT) e (enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) empty) =/= empty .
	crl [discardINT] : maState mode ($stableC V HC) (E e E2) => 
		maState mode ($stableC V HC) (E E2 e) if
		(fire mode (getVerts SMINT) e (enabled (prettyVToV (getVerts SMINT) V) e (getTrans SMINT)) empty) == empty .

	rl [execTransINT] : maState mode ($unstableC V HC (t, T) (par A)) E => 
		maState mode ($unstableC prettyVerts(((prettyVToV (getVerts SMINT) V) \ (leave (prettyVToV (getVerts SMINT) V) t)) , (enterH SMINT (prettyHCToHC (getVerts SMINT) HC) t)) HC T 
		(par (A 
			seq(
				(getExitAc SMINT (prettyVToV (getVerts SMINT) V) (region t)) 
				(getAcExp t)
				(getEntryAc SMINT (prettyHCToHC (getVerts SMINT) HC) (target t) (region t))
				)
		))) 
		E .
	rl [finishedRTCINT] : maState mode ($unstableC V HC empty (par A)) E => 
		maState mode ($stableC V prettyHc(succHC (prettyVToV (getVerts SMINT) V) (prettyHCToHC (getVerts SMINT) HC))) E .
	
	crl [fireTrans] : maState mode (stableC sm V HC) (E e E2) => 
		maState mode (unstableC sm V HC (fire mode (getVerts sm) e (enabled V e (getTrans sm)) empty) (par nil)) (E E2 e) if
		(fire mode (getVerts sm) e (enabled V e (getTrans sm)) empty) =/= empty .

	crl [discard] : maState mode (stableC sm V HC) (E e E2) => 
		maState mode (stableC sm V HC) (E E2 e) if
		(fire mode (getVerts sm) e (enabled V e (getTrans sm)) empty) == empty .
	rl [execTrans] : maState mode (unstableC sm V HC (t, T) (par A)) E => 
		maState mode (unstableC sm ((V \ (leave V t)) , (enterH sm HC t)) HC T 
		(par (A 
			seq(
				(getExitAc sm V (region t)) 
				(getAcExp t)
				(getEntryAc sm HC (target t) (region t))
				)
		))) 
		E .
	rl [finishedRTC] : maState mode (unstableC sm V HC empty (par A)) E => 
		maState mode (stableC sm V (succHC V HC)) E .
    
   	op prettyConf_ : Configuration -> Configuration .
    eq prettyConf (unstableC sm V HC T a) = unstableC (prettySm sm) (prettyVerts V) HC (prettyTrans T) a .
    eq prettyConf (stableC sm V HC) = stableC (prettySm sm) (prettyVerts V) HC .
  
endm
