/*
* generated by Xtext
*/

package de.cau.cs.kieler.sim.esi.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EsiGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class TracelistElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tracelist");
		private final Assignment cTracesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTracesTraceParserRuleCall_0 = (RuleCall)cTracesAssignment.eContents().get(0);
		
		//tracelist:
		//	traces+=trace+;
		public ParserRule getRule() { return rule; }

		//traces+=trace+
		public Assignment getTracesAssignment() { return cTracesAssignment; }

		//trace
		public RuleCall getTracesTraceParserRuleCall_0() { return cTracesTraceParserRuleCall_0; }
	}

	public class TraceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "trace");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cResetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTicksAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTicksTickParserRuleCall_3_0 = (RuleCall)cTicksAssignment_3.eContents().get(0);
		
		//trace:
		//	"!" "reset" ";" ticks+=tick+;
		public ParserRule getRule() { return rule; }

		//"!" "reset" ";" ticks+=tick+
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"reset"
		public Keyword getResetKeyword_1() { return cResetKeyword_1; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }

		//ticks+=tick+
		public Assignment getTicksAssignment_3() { return cTicksAssignment_3; }

		//tick
		public RuleCall getTicksTickParserRuleCall_3_0() { return cTicksTickParserRuleCall_3_0; }
	}

	public class TickElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tick");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTickAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cInputAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInputSignalParserRuleCall_1_0 = (RuleCall)cInputAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cPercentSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cOutputKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cColonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cOutputAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cOutputSignalParserRuleCall_2_3_0 = (RuleCall)cOutputAssignment_2_3.eContents().get(0);
		private final Assignment cExtraInfosAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExtraInfosKvpairParserRuleCall_3_0 = (RuleCall)cExtraInfosAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//tick:
		//	{tick} input+=signal* ("%" "Output" ":" output+=signal*)? extraInfos+=kvpair* ";";
		public ParserRule getRule() { return rule; }

		//{tick} input+=signal* ("%" "Output" ":" output+=signal*)? extraInfos+=kvpair* ";"
		public Group getGroup() { return cGroup; }

		//{tick}
		public Action getTickAction_0() { return cTickAction_0; }

		//input+=signal*
		public Assignment getInputAssignment_1() { return cInputAssignment_1; }

		//signal
		public RuleCall getInputSignalParserRuleCall_1_0() { return cInputSignalParserRuleCall_1_0; }

		//("%" "Output" ":" output+=signal*)?
		public Group getGroup_2() { return cGroup_2; }

		//"%"
		public Keyword getPercentSignKeyword_2_0() { return cPercentSignKeyword_2_0; }

		//"Output"
		public Keyword getOutputKeyword_2_1() { return cOutputKeyword_2_1; }

		//":"
		public Keyword getColonKeyword_2_2() { return cColonKeyword_2_2; }

		//output+=signal*
		public Assignment getOutputAssignment_2_3() { return cOutputAssignment_2_3; }

		//signal
		public RuleCall getOutputSignalParserRuleCall_2_3_0() { return cOutputSignalParserRuleCall_2_3_0; }

		//extraInfos+=kvpair*
		public Assignment getExtraInfosAssignment_3() { return cExtraInfosAssignment_3; }

		//kvpair
		public RuleCall getExtraInfosKvpairParserRuleCall_3_0() { return cExtraInfosKvpairParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class SignalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "signal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameAlphaNumSpecialTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cValuedAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cValuedLeftParenthesisKeyword_1_0_0 = (Keyword)cValuedAssignment_1_0.eContents().get(0);
		private final Assignment cValAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValValueParserRuleCall_1_1_0 = (RuleCall)cValAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		/// * From the Xtext documentation:
		// * The ?= sign (boolean assignment operator) expects a feature of type EBoolean and sets it to true if
		// * the right hand side was consumed independently from the concrete value of the right hand side.
		// * 
		// * I. e. 'valued' is set to true if a value could be read.
		// * / signal: // | AlphaNumSpecial)
		//	name=AlphaNumSpecial (valued?="(" val=value ")")?;
		public ParserRule getRule() { return rule; }

		//// | AlphaNumSpecial)
		//name=AlphaNumSpecial (valued?="(" val=value ")")?
		public Group getGroup() { return cGroup; }

		//// | AlphaNumSpecial)
		//name=AlphaNumSpecial
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//AlphaNumSpecial
		public RuleCall getNameAlphaNumSpecialTerminalRuleCall_0_0() { return cNameAlphaNumSpecialTerminalRuleCall_0_0; }

		//(valued?="(" val=value ")")?
		public Group getGroup_1() { return cGroup_1; }

		//valued?="("
		public Assignment getValuedAssignment_1_0() { return cValuedAssignment_1_0; }

		//"("
		public Keyword getValuedLeftParenthesisKeyword_1_0_0() { return cValuedLeftParenthesisKeyword_1_0_0; }

		//val=value
		public Assignment getValAssignment_1_1() { return cValAssignment_1_1; }

		//value
		public RuleCall getValValueParserRuleCall_1_1_0() { return cValValueParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEsoIntParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEsoFloatParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEsoBoolParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cEsoStringParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//value:
		//	EsoInt | EsoFloat | EsoBool | EsoString;
		public ParserRule getRule() { return rule; }

		//EsoInt | EsoFloat | EsoBool | EsoString
		public Alternatives getAlternatives() { return cAlternatives; }

		//EsoInt
		public RuleCall getEsoIntParserRuleCall_0() { return cEsoIntParserRuleCall_0; }

		//EsoFloat
		public RuleCall getEsoFloatParserRuleCall_1() { return cEsoFloatParserRuleCall_1; }

		//EsoBool
		public RuleCall getEsoBoolParserRuleCall_2() { return cEsoBoolParserRuleCall_2; }

		//EsoString
		public RuleCall getEsoStringParserRuleCall_3() { return cEsoStringParserRuleCall_3; }
	}

	public class EsoIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EsoInt");
		private final RuleCall cIntTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EsoInt returns ecore::EInt:
		//	Int;
		public ParserRule getRule() { return rule; }

		//Int
		public RuleCall getIntTerminalRuleCall() { return cIntTerminalRuleCall; }
	}

	public class EsoStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EsoString");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EsoString returns ecore::EString:
		//	STRING;
		public ParserRule getRule() { return rule; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}

	public class EsoFloatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EsoFloat");
		private final RuleCall cFloatTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EsoFloat returns ecore::EFloat:
		//	Float;
		public ParserRule getRule() { return rule; }

		//Float
		public RuleCall getFloatTerminalRuleCall() { return cFloatTerminalRuleCall; }
	}

	public class EsoBoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EsoBool");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EsoBool returns ecore::EBoolean:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class KvpairElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "kvpair");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPercentSignPercentSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyAlphaNumSpecialTerminalRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cValueAlternatives_3_0 = (Alternatives)cValueAssignment_3.eContents().get(0);
		private final RuleCall cValueAlphaNumSpecialTerminalRuleCall_3_0_0 = (RuleCall)cValueAlternatives_3_0.eContents().get(0);
		private final RuleCall cValueIntTerminalRuleCall_3_0_1 = (RuleCall)cValueAlternatives_3_0.eContents().get(1);
		private final RuleCall cValueFloatTerminalRuleCall_3_0_2 = (RuleCall)cValueAlternatives_3_0.eContents().get(2);
		
		//kvpair:
		//	"%%" // | AlphaNumSpecial)
		//	key=AlphaNumSpecial ":" value=(AlphaNumSpecial | Int | Float);
		public ParserRule getRule() { return rule; }

		//"%%" // | AlphaNumSpecial)
		//key=AlphaNumSpecial ":" value=(AlphaNumSpecial | Int | Float)
		public Group getGroup() { return cGroup; }

		//"%%"
		public Keyword getPercentSignPercentSignKeyword_0() { return cPercentSignPercentSignKeyword_0; }

		//// | AlphaNumSpecial)
		//key=AlphaNumSpecial
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }

		//AlphaNumSpecial
		public RuleCall getKeyAlphaNumSpecialTerminalRuleCall_1_0() { return cKeyAlphaNumSpecialTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//value=(AlphaNumSpecial | Int | Float)
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//AlphaNumSpecial | Int | Float
		public Alternatives getValueAlternatives_3_0() { return cValueAlternatives_3_0; }

		//AlphaNumSpecial
		public RuleCall getValueAlphaNumSpecialTerminalRuleCall_3_0_0() { return cValueAlphaNumSpecialTerminalRuleCall_3_0_0; }

		//Int
		public RuleCall getValueIntTerminalRuleCall_3_0_1() { return cValueIntTerminalRuleCall_3_0_1; }

		//Float
		public RuleCall getValueFloatTerminalRuleCall_3_0_2() { return cValueFloatTerminalRuleCall_3_0_2; }
	}
	
	
	private TracelistElements pTracelist;
	private TraceElements pTrace;
	private TickElements pTick;
	private SignalElements pSignal;
	private ValueElements pValue;
	private EsoIntElements pEsoInt;
	private EsoStringElements pEsoString;
	private EsoFloatElements pEsoFloat;
	private EsoBoolElements pEsoBool;
	private KvpairElements pKvpair;
	private TerminalRule tSpecial;
	private TerminalRule tAlphaNumSpecial;
	private TerminalRule tSTRING;
	private TerminalRule tInt;
	private TerminalRule tFloat;
	private TerminalRule tWS;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public EsiGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//tracelist:
	//	traces+=trace+;
	public TracelistElements getTracelistAccess() {
		return (pTracelist != null) ? pTracelist : (pTracelist = new TracelistElements());
	}
	
	public ParserRule getTracelistRule() {
		return getTracelistAccess().getRule();
	}

	//trace:
	//	"!" "reset" ";" ticks+=tick+;
	public TraceElements getTraceAccess() {
		return (pTrace != null) ? pTrace : (pTrace = new TraceElements());
	}
	
	public ParserRule getTraceRule() {
		return getTraceAccess().getRule();
	}

	//tick:
	//	{tick} input+=signal* ("%" "Output" ":" output+=signal*)? extraInfos+=kvpair* ";";
	public TickElements getTickAccess() {
		return (pTick != null) ? pTick : (pTick = new TickElements());
	}
	
	public ParserRule getTickRule() {
		return getTickAccess().getRule();
	}

	/// * From the Xtext documentation:
	// * The ?= sign (boolean assignment operator) expects a feature of type EBoolean and sets it to true if
	// * the right hand side was consumed independently from the concrete value of the right hand side.
	// * 
	// * I. e. 'valued' is set to true if a value could be read.
	// * / signal: // | AlphaNumSpecial)
	//	name=AlphaNumSpecial (valued?="(" val=value ")")?;
	public SignalElements getSignalAccess() {
		return (pSignal != null) ? pSignal : (pSignal = new SignalElements());
	}
	
	public ParserRule getSignalRule() {
		return getSignalAccess().getRule();
	}

	//value:
	//	EsoInt | EsoFloat | EsoBool | EsoString;
	public ValueElements getValueAccess() {
		return (pValue != null) ? pValue : (pValue = new ValueElements());
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//EsoInt returns ecore::EInt:
	//	Int;
	public EsoIntElements getEsoIntAccess() {
		return (pEsoInt != null) ? pEsoInt : (pEsoInt = new EsoIntElements());
	}
	
	public ParserRule getEsoIntRule() {
		return getEsoIntAccess().getRule();
	}

	//EsoString returns ecore::EString:
	//	STRING;
	public EsoStringElements getEsoStringAccess() {
		return (pEsoString != null) ? pEsoString : (pEsoString = new EsoStringElements());
	}
	
	public ParserRule getEsoStringRule() {
		return getEsoStringAccess().getRule();
	}

	//EsoFloat returns ecore::EFloat:
	//	Float;
	public EsoFloatElements getEsoFloatAccess() {
		return (pEsoFloat != null) ? pEsoFloat : (pEsoFloat = new EsoFloatElements());
	}
	
	public ParserRule getEsoFloatRule() {
		return getEsoFloatAccess().getRule();
	}

	//EsoBool returns ecore::EBoolean:
	//	"true" | "false";
	public EsoBoolElements getEsoBoolAccess() {
		return (pEsoBool != null) ? pEsoBool : (pEsoBool = new EsoBoolElements());
	}
	
	public ParserRule getEsoBoolRule() {
		return getEsoBoolAccess().getRule();
	}

	//kvpair:
	//	"%%" // | AlphaNumSpecial)
	//	key=AlphaNumSpecial ":" value=(AlphaNumSpecial | Int | Float);
	public KvpairElements getKvpairAccess() {
		return (pKvpair != null) ? pKvpair : (pKvpair = new KvpairElements());
	}
	
	public ParserRule getKvpairRule() {
		return getKvpairAccess().getRule();
	}

	//terminal Special:
	//	"," | "." | "/" | "@" | "#" | "$" | "&" | "*" | "=" | "+" | "-";
	public TerminalRule getSpecialRule() {
		return (tSpecial != null) ? tSpecial : (tSpecial = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "Special"));
	} 

	//terminal AlphaNumSpecial:
	//	("a".."z" | "A".."Z" | Special) ("a".."z" | "A".."Z" | "0".."9" | Special)*;
	public TerminalRule getAlphaNumSpecialRule() {
		return (tAlphaNumSpecial != null) ? tAlphaNumSpecial : (tAlphaNumSpecial = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AlphaNumSpecial"));
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	////terminal Alpha:
	////    ('a'..'z' | 'A'..'Z')+;
	//terminal Int:
	//	("+" | "-")? "0".."9"+;
	public TerminalRule getIntRule() {
		return (tInt != null) ? tInt : (tInt = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "Int"));
	} 

	//terminal Float:
	//	("+" | "-")? "0".."9"+ "." "0".."9"+;
	public TerminalRule getFloatRule() {
		return (tFloat != null) ? tFloat : (tFloat = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "Float"));
	} 

	////terminal AlphaNum:
	////    (Alpha | '0'..'9')+;
	////terminal Comment:
	////    '%' ('a'..'z' | 'A'..'N' | 'P'..'Z' | ('0' .. '9') | Special)->'\n';
	//terminal WS:
	//	"\t" | " " | "\r" | "\n";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 
}
