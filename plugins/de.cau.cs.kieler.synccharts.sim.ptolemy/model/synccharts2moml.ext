//import annotatations;
//import ecore;
import expressions;
import synccharts;

import moml;

//-----------------------------------------------------------------------------
//--     S Y N C C H A R T S - 2 - P T O     T R A N S F O R M A T I O N     --
//-----------------------------------------------------------------------------

//Start Model Transformation here.
create DocumentRoot this transform(synccharts::Region sc):
 	this.setEntity(createBaseEntity(sc))
;   
	
	
//-----------------------------------------------------------------------------
//--       B A S I C   M O M L - E N T I T I E S   C R E A T I O N           --
//-----------------------------------------------------------------------------

//Add a link between port and relation (within baseEntity).
//Only iff this link does not already exist. 
Void addLink(EntityType baseEntity, String port, String relation) :
	let l = new LinkType:
	l.setPort(port) ->
	l.setRelation(relation) ->
   //if not already exists
   (baseEntity.link.select(ee|ee.port.matches(l.port)
   						   && ee.relation.matches(l.relation)).size == 0) ?
		baseEntity.link.add(l) : null
;


//Add a relation (within baseEntity).
//Only iff this relation does not already exist. 
Void addRelation(EntityType baseEntity, String name, String property) :
	let r = new RelationType:
    let p1 = new PropertyType:
    let p2 = new PropertyType:
    let v = new VertexType:
	r.setName(name) ->
    r.setClass("ptolemy.actor.TypedIORelation") ->
   		p1.setName("width") ->
   		p2.setName(property) ->
   		p1.setClass("ptolemy.data.expr.Parameter") ->
   		p1.setValue("-1") ->
   	r.property.add(p1) ->
   //if not already exists
   (baseEntity.relation.select(ee|ee.name.matches(r.name)).size == 0) ?
		   baseEntity.relation.add(r) : null
;


//Add a vertex relation (within baseEntity).
//Only iff this vertex relation does not already exist. 
Void addVertexRelation(EntityType baseEntity, String name, String property) :
	let r = new RelationType:
    let p1 = new PropertyType:
    let p2 = new PropertyType:
    let v = new VertexType:
	r.setName(name) ->
    r.setClass("ptolemy.actor.TypedIORelation") ->
   		p1.setName("width") ->
   		p2.setName(property) ->
   		p1.setClass("ptolemy.data.expr.Parameter") ->
   		p1.setValue("-1") ->
   		v.setName(name+"VERTEX") ->
   		v.setValue("{0.0, 0.0}") ->
   	r.property.add(p1) ->
   	//r.property.add(p2) ->
   	r.vertex.add(v) ->
   //if not already exists
   (baseEntity.relation.select(ee|ee.name.matches(r.name)).size == 0) ?
	   baseEntity.relation.add(r) : null 
;


//Add a KIELER combine function for local signals (within baseEntity).
//Only iff this actor does not already exist. 
Void addCombineFunction(EntityType baseEntity, String name) :
   let e = new EntityType:
   let p1 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.domains.sr.lib.Combine") ->
   	p1.setName("combine function") ->
   	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
   	p1.setValue("1") ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   


//Add a KIELER combine function for environment signals (within baseEntity).
//Only iff this actor does not already exist. 
Void addEnvironmentCombineFunction(EntityType baseEntity, 
								   String name, 
								   String signalID) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.domains.sr.lib.Combine") ->
   	p2.setName("combine function") ->
   	p2.setClass("ptolemy.kernel.util.StringAttribute") ->
   	p2.setValue("1") ->
   	p1.setName("signal name") ->
   	p1.setClass("ptolemy.data.expr.Parameter") ->
   	p1.setValue("'"+signalID+"'") ->
   e.property.add(p1) ->
   e.property.add(p2) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   
  

//Add a KIELER normal termination actor (within baseEntity).
//Only iff this actors does not already exist. 
Void addKielerNormalTermination(EntityType baseEntity) :
   let e = new EntityType:
   e.setName("KielerNormalTermination") ->
   e.setClass1("ptolemy.actor.kiel.KielerNormalTermination") ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   
  

//Add a KIELER IO actor (within baseEntity).
//Only iff this actors does not already exist. 
Void addKielerIO(EntityType baseEntity, String name, String signalID) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   let p3 = new PropertyType:
   let port = new PortType:
    let p4 = new PropertyType:
    let p5 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.kiel.KielerIO") ->
   	p1.setName("signal name") ->
   	p1.setClass("ptolemy.data.expr.Parameter") ->
   	p1.setValue("'"+signalID+"'") ->
   	port.setName("signal") ->
   	port.setClass("ptolemy.actor.TypedIOPort") ->
 	  	p4.setName("output") ->
 	  	p5.setName("_type") ->
 	  	p5.setClass("ptolemy.actor.TypeAttribute") ->
 	  	p5.setValue("int") ->
 	port.property.add(p4) ->
 	port.property.add(p5) ->
   e.port.add(port) ->	
   e.property.add(p1) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
		  baseEntity.entity.add(e) : null
;


//Void addConstant(EntityType baseEntity, String value):
//   let e = new EntityType:
//   let p1 = new PropertyType:
//   let p2 = new PropertyType:
//   let p3 = new PropertyType:
//   let p4 = new PropertyType:
//   let p5 = new PropertyType:
//   p1.setName("Const") ->
//  p1.setClass("ptolemy.actor.lib.Const") ->
//   	p2.setName("value") ->
//   	p2.setClass("ptolemy.data.expr.Parameter") ->
// 		p2.setValue(value) ->
//   		p3.setName("_icon") ->
//   		p3.setClass("ptolemy.vergil.icon.BoxedValueIcon") ->
//   			p4.setName("attributeName") ->
//   			p4.setClass("ptolemy.kernel.util.StringAttribute") ->
//   			p4.setValue("value") ->
//   			p5.setName("displayWidth") ->
//   			p5.setClass("ptolemy.data.expr.Parameter") ->
//   			p5.setValue("60") ->
//   		p3.property.add(p4) ->
//   		p3.property.add(p5) ->
//   	p2.property.add(p3) ->
//   e.property.add(p1) ->
//   e.property.add(p2) ->
//   //if not already exists
//   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
//   			baseEntity.entity.add(e) : null
//;


//-----------------------------------------------------------------------------
//--     P R E P R O C E S S I N G  :  TRANSFORM OUTPUT SIGNALS              --
//-----------------------------------------------------------------------------
//Transforms output signals that might be used in triggers to output signals 
//that are not used in triggers and auxiliary local signals that can be used in
//triggers.
//@author cmot, 01. Dec 2009

//Main function should be called for the top most state
Void outputSignalTransformation(State topState):
  //get the output signals, for these local signals must be defined
  let outputSignalList = topState.signals.select(e|e.isOutput):
  let signalList = topState.signals:
  //add new output signals (with the same names)
  (outputSignalList.size > 0) ?
  	outputSignalTransformationNewSignals(outputSignalList)
  	: null ->
  //add new emissions of new output signals wherever the original outputs where emitted
  outputSignalTransformationNewEmissionsRegions(topState.regions, outputSignalList, topState) ->
  //rename original signals
  (outputSignalList.size > 0) ?
  	outputSignalTransformationRenameSignals(outputSignalList, signalList)
  	: null
;
//Recursive traverses all regions
Void outputSignalTransformationNewEmissionsRegions(List[Region] regionList,
											 List[Signal] outputSignalList,
											 State topState) :
   let region = regionList.first():
   (regionList.withoutFirst().size > 0) ?
    	outputSignalTransformationNewEmissionsRegions(regionList.withoutFirst(), 
    											outputSignalList, 
    											topState) 
    	: null ->
   (region.states.size > 0) ?
   		outputSignalTransformationNewEmissionsStates(region.states, 
   											   outputSignalList, 
   											   topState) 
   		: null
   
;
//Recursive traverses all states
Void outputSignalTransformationNewEmissionsStates(List[State] stateList,
											 List[Signal] outputSignalList,
											 State topState) :
   let state = stateList.first():
   (stateList.withoutFirst().size > 0) ?
    	outputSignalTransformationNewEmissionsStates(stateList.withoutFirst(), 
    										   outputSignalList, 
    										   topState) 
    	: null ->
   (state.regions.size > 0) ?
   		outputSignalTransformationNewEmissionsRegions(state.regions, 
   												outputSignalList, 
   												topState) 
   		: null ->
   (state.outgoingTransitions.size > 0) ?
   		outputSignalTransformationNewEmissionsTransitions(state.outgoingTransitions, 
   													outputSignalList, 
   													topState)
		: null
;
//Recusrive traverses all transitions
Void outputSignalTransformationNewEmissionsTransitions(List[Transition] transitionList,
 												 List[Signal] outputSignalList,
 												 State topState) :
 let transition = transitionList.first():
 (transitionList.withoutFirst().size > 0) ?
 		outputSignalTransformationNewEmissionsTransitions(transitionList.withoutFirst(),
 													outputSignalList,
 													topState)
 		: null ->
  (transition.effects.size > 0) ?
  	outputSignalTransformationNewEmissionsEffects(transition.effects, 
  												  transition, 
  												  outputSignalList, 
  												  topState)
  	: null		
;
//Recursive traverses all effects
Void outputSignalTransformationNewEmissionsEffects(List[Effect] effectList,
										Transition transition,
										List[Signal] outputSignalList,
										State topState) :
 let effect = effectList.first():
 (effectList.withoutFirst().size > 0) ?
 		outputSignalTransformationNewEmissionsEffects(effectList.withoutFirst(),
 												transition,
 												outputSignalList,
 												topState)
 		: null ->
  (effect.metaType.name.matches("synccharts::Emission") 
    && (outputSignalList.contains(((Emission)effect).signal))) ?
    	outputSignalTransformationNewEmissionsEmission(transition, 
    												   ((Emission)effect).signal, 
    												   topState)
    	: null
;
//If an emission is found, add a new one for the new output signal
Void outputSignalTransformationNewEmissionsEmission(Transition transition,
											  Signal outputSignal,
											  State topState) :
  let newEmission = new Emission:
  //note, that the original signal (outputSignal) is of type local NOW
  let newSignal = topState.signals.select(e|e.name.matches(outputSignal.name) && e.isOutput).get(0):
  newEmission.setSignal(newSignal) ->
  //add a new emission to the transition
  transition.effects.add(newEmission)
;											  

//renames all output signals to signals with l
//adds new output signals
Void outputSignalTransformationNewSignals(List[Signal] outputSignalList) :
 let outputSignal = outputSignalList.first():
 let newSignal = new Signal:
 //set new output signal's name and output type
 newSignal.setIsOutput(true) ->
 newSignal.setIsInput(false) ->
 newSignal.setName(outputSignal.name) ->
 //add it to the original state (the top most)
 ((State)outputSignal.eContainer).signals.add(newSignal) ->
 //make original signal a local signal
 outputSignal.setIsOutput(false) ->
 (outputSignalList.withoutFirst().size > 0) ? 
 		outputSignalTransformationNewSignals(outputSignalList.withoutFirst()) 
 		: null
;

//renames all output signals to signals with l
//adds new output signals
Void outputSignalTransformationRenameSignals(List[Signal] outputSignalList, List[Signal] signalList) :
 let outputSignal = outputSignalList.first():
 let uniqueName = getUniqueName(outputSignal.name, signalList):
 //rename original signal
 outputSignal.setName(uniqueName) ->
 (outputSignalList.withoutFirst().size > 0) ? 
 		outputSignalTransformationRenameSignals(outputSignalList.withoutFirst(), signalList) 
 		: null
;
//adds "local" to a name (until it is unique)
String getUniqueName(String name, List[Signal] signalList):
   let newName = name + "local":
   (signalList.select(e|e.name.matches(newName)).size > 0) ?
      getUniqueName(newName, signalList): newName
;      

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//--     P R E P R O C E S S I N G  :  TRANSFORM INPUT SIGNALS              --
//-----------------------------------------------------------------------------
//Transforms input signals that might be used in emissions to input signals 
//that are not used in emissions and auxiliary local signals that can be used in
//emissions.
//@author cmot, 01. Dec 2009
//Addition (07.06.2010): Note that not-constructive synccharts must be prevented,
//this are auxiliary signals that appear in a strong-abortion. These are not
//allowed to appear inside the terminated state!!! (e.g. R in ABRO)

//ATTENTION: this method can oly be used iff we remove ANY output port from modal model
//actors whose connected/adjacent input ports appear in triggers of strong abortion transitions
//This is because such a syncchart would not be constructive. Without this modification the
//Ptolemy model cannot be simulated, because of in general Ptolemy cannot make any assumptions
//about relations from outputs to inputs!


//Main function should be called for the top most state
Void inputSignalTransformation(State topState):
  //get the input signals, for these local auxiliary signals must be defined
  let inputSignalList = topState.signals.select(e|e.isInput):
  let signalList = topState.signals:
  //add parallel regions with new input signals (with the same names)
  (inputSignalList.size > 0) ?
  	inputSignalTransformationNewSignals(inputSignalList, topState, signalList)
  	: null 
;

//for every input signal construct a new region
Void inputSignalTransformationNewSignals(List[Signal] inputSignalList, 
										 State topState,
										 List[Signal] signalList) :
 let inputSignal = inputSignalList.first():

 let uniqueName = getUniqueName(inputSignal.name, signalList):
 let topmostState = ((State)inputSignal.eContainer):
 let newSignalName = inputSignal.name:
 let newSignal = new Signal:
// let newSignal2 = new Signal:
 let newRegion = new Region:
 let newState = new State:
 let newTransition = new Transition:
 let newValuedObjectReference = new ValuedObjectReference:
 let newEmission = new Emission: 
 //make original signal a local signal
 inputSignal.setIsInput(false) ->
 //rename original signal
 inputSignal.setName(uniqueName) ->
 //add new signal to the original state (the top most)
 topmostState.signals.add(newSignal) ->
 //set new input signal's name and input type
 newSignal.setIsInput(true) ->
 newSignal.setIsOutput(false) ->
 newSignal.setName(newSignalName) ->
 //construct new region
 newValuedObjectReference.setValuedObject(newSignal) ->
 newEmission.setSignal(inputSignal) ->
 newTransition.setTrigger(newValuedObjectReference) ->
 newTransition.effects.add(newEmission) ->
 newTransition.setTargetState(newState) ->
 newState.outgoingTransitions.add(newTransition) ->
 newState.setIsInitial(true) ->
 newRegion.states.add(newState) ->
 //add new region to original state
 ((State)inputSignal.eContainer).regions.add(newRegion) ->
 (inputSignalList.withoutFirst().size > 0) ? 
 		inputSignalTransformationNewSignals(inputSignalList.withoutFirst(), topState, signalList) 
 		: null
;


//adds "local" to a name (until it is unique)
//String getUniqueName(String name, List[Signal] signalList):
//   let newName = name + "local":
//   (signalList.select(e|e.name.matches(newName)).size > 0) ?
//      getUniqueName(newName, signalList): newName
//;      

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//--     P R E P R O C E S S I N G  :  NORMAL TERMINATION 2 WEAK ABORT       --
//-----------------------------------------------------------------------------

Void n2wRegion(List[synccharts::State] stateList) :
  let state = stateList.first():
  (stateList.withoutFirst().size > 0) ?
     n2wRegion(stateList.withoutFirst()) : null ->
  (state.isMacroState()) ?
  	n2wState(state.regions) : null ->
  (!state.outgoingTransitions.isEmpty) ?
  	n2wTransition(state.outgoingTransitions, state) : null
;

Void n2wState(List[synccharts::Region] regionList) :
  let region = regionList.first():
  (regionList.withoutFirst().size > 0) ?
     n2wState(regionList.withoutFirst()) : null ->
  (region.states.size > 0) ?
  	 n2wRegion(region.states) : null
;

Void n2wTransition(List[synccharts::Transition] transitionList, synccharts::State state) :
  let transition = transitionList.first():
  let operatorExpression = new expressions::OperatorExpression:
  dump("TEST TRANSITION "+getURIFragment(transition)) ->
  (transitionList.withoutFirst().size > 0) ?
     n2wTransition(transitionList.withoutFirst(), state) : null ->
   //add a new operator/complex expression trigger (will be filled recusively)
   operatorExpression.setOperator(expressions::OperatorType::AND) ->
  (transition.type.toString().matches("NORMALTERMINATION") && (state.regions.size > 0)) ?
    transition.setTrigger(operatorExpression) : null ->
  (transition.type.toString().matches("NORMALTERMINATION") && (state.regions.size > 0)) ?
    n2wBuildTriggerState(state.regions, 
  						 state.parentRegion.parentState,
  						 transition) : null ->
  //test how many trigges are in, if only one delete AND if non, delete operatorExpression
  (operatorExpression.subExpressions.size == 1) ?
     transition.setTrigger(operatorExpression.subExpressions.get(0)) : null ->
  //modify the type from NORMALTERMINATION to WEAKABORT   
  (transition.type.toString().matches("NORMALTERMINATION")) ? 
    transition.setType(synccharts::TransitionType::WEAKABORT) : null
;

Void n2wBuildTriggerState(List[synccharts::Region] regionList, 
					             synccharts::State mainState, 
					        synccharts::Transition weakAbortTransition) :
  let region = regionList.first():
  let regionSignalName = "finished_" + hash(region.states.flatten().toString()):
  let regionSignal = new expressions::Signal:
  let valuedObjectReference = new expressions::ValuedObjectReference:
  let trigger = weakAbortTransition.trigger:
   //construct a new (local) signal
   regionSignal.setName(regionSignalName) ->
   regionSignal.setType(expressions::ValueType::PURE) ->
   //add signal to main state
   mainState.signals.add(regionSignal) ->
   //construct a new signal reference (for trigger) and add it
   valuedObjectReference.setValuedObject(regionSignal) ->
   ((OperatorExpression)trigger).subExpressions.add(valuedObjectReference) ->
 
  (regionList.withoutFirst().size > 0) ?
  	 n2wBuildTriggerState(regionList.withoutFirst(), mainState, weakAbortTransition) : null ->
  (region.states.size > 0) ?
  	n2wBuildTriggerRegion(region.states, mainState, weakAbortTransition, regionSignal) : null
;

Void n2wBuildTriggerRegion(List[synccharts::State] stateList, 
								   synccharts::State mainState, 
							  synccharts::Transition weakAbortTransition,
							  Signal regionSignal) :
  let state = stateList.first():
  (stateList.withoutFirst().size > 0) ?
  	 n2wBuildTriggerRegion(stateList.withoutFirst(), mainState, weakAbortTransition,regionSignal) : null ->
  (state.isFinal) ?
    dump("FINAL STATE FOUND "+state.getStateId()) : null ->
  (state.isFinal) ?
    n2wBuildTriggerFinalState(state, mainState, weakAbortTransition,regionSignal) : null
;

Void n2wBuildTriggerFinalState(synccharts::State finalState, 
							   synccharts::State mainState, 
						  synccharts::Transition weakAbortTransition,
						  Signal regionSignal) :
  let newTransition = new synccharts::Transition:
   //construct a new self transition 
   newTransition.setTargetState(finalState) ->
   //add self transition
   finalState.outgoingTransitions.add(newTransition) ->
   //add emission for all incoming transitions
   n2wBuildTriggerFinalStateTransitions(finalState.incomingTransitions(),
    									 weakAbortTransition, regionSignal)
;							  

Void n2wBuildTriggerFinalStateTransitions(List[synccharts::Transition] transitionList,
								 synccharts::Transition weakAbortTransition,
								 Signal regionSignal) :
    let transition = transitionList.first():
	let signalEmission = new Emission:
    signalEmission.setSignal(regionSignal) ->
    dump("FINAL TRANSITION SIGNAL "+regionSignal.name + " FOR "+ transition.getURIFragment()) ->
	transition.effects.add(signalEmission) ->
    (transitionList.withoutFirst().size > 0) ?
		    n2wBuildTriggerFinalStateTransitions(transitionList.withoutFirst(),
			  						  weakAbortTransition,
								 	  regionSignal) : null
;


//-----------------------------------------------------------------------------
//--    E x t e n s i o n        for calculating incoming transitions        --
//-----------------------------------------------------------------------------

List[synccharts::Transition] incomingTransitions(synccharts::State targetState) :
  let parentRegion = (synccharts::Region)targetState.eContainer:
  let list = createTransitionList():
  list.removeAll(list) ->
  (parentRegion != null) ?
      incomgingTransitionsHelperStates(parentRegion.states, targetState, list) : null ->
  list
;
create List[synccharts::Transition] createTransitionList () :
  null
;
Void incomgingTransitionsHelperStates(List[synccharts::State] stateList,
				         synccharts::State targetState, 
				         List[synccharts::Transition] list) :
  let state = stateList.first():
  (state.outgoingTransitions.size > 0) ?
       incomgingTransitionsHelperTransitions(state.outgoingTransitions, targetState, list) : null ->
  (stateList.withoutFirst().size > 0) ?
       incomgingTransitionsHelperStates(stateList.withoutFirst(), targetState, list) : null
;        
Void incomgingTransitionsHelperTransitions(List[synccharts::Transition] transitionList,
				         synccharts::State targetState, 
				         List[synccharts::Transition] list) :
  let transition = transitionList.first():
  (transition.targetState == targetState) ?
  		list.add(transition) : null ->
  (transitionList.withoutFirst().size > 0) ?
       incomgingTransitionsHelperTransitions(transitionList.withoutFirst(), targetState, list) : null
;       


//-----------------------------------------------------------------------------
//--     P R E P R O C E S S I N G  :  RAISE ALL LOCAL VARS TO UPPER LEVEL   --
//-----------------------------------------------------------------------------

Void localSignalShiftPreprocessingRegion(List[synccharts::State] stateList, synccharts::State mainState) :
  let state = stateList.first():
  (stateList.withoutFirst().size > 0) ?
     localSignalShiftPreprocessingRegion(stateList.withoutFirst(), mainState) : null ->
  (state.isMacroState()) ?
  	localSignalShiftPreprocessingState(state.regions, mainState) : null ->
  (!state.signals.isEmpty && state != mainState) ?
  	localSignalShiftPreprocessingSignal(state.signals, state, mainState) : null
;

Void localSignalShiftPreprocessingState(List[synccharts::Region] regionList, synccharts::State mainState) :
  let region = regionList.first():
  (regionList.withoutFirst().size > 0) ?
     localSignalShiftPreprocessingState(regionList.withoutFirst(), mainState) : null ->
  (region.states.size > 0) ?
  	 localSignalShiftPreprocessingRegion(region.states, mainState) : null
;

Void localSignalShiftPreprocessingSignal(List[Signal] signalList, synccharts::State state, synccharts::State mainState) :
  let signal = signalList.first():
  (signalList.withoutFirst().size > 0) ?
     localSignalShiftPreprocessingSignal(signalList.withoutFirst(), state, mainState) : null ->
  (signal.isLocal()) ?
    mainState.signals.add(signal) : null ->
  (signal.isLocal()) ?
    state.signals.remove(signal) : null
;

//-----------------------------------------------------------------------------
//--     P R E P R O C E S S I N G  :  RENAME ALL LOCAL VARS 4 UNIFICATION   --
//-----------------------------------------------------------------------------

Void localSignalRenamingPreprocessingRegion(List[synccharts::State] stateList) :
  let state = stateList.first():
  (stateList.withoutFirst().size > 0) ?
     localSignalRenamingPreprocessingRegion(stateList.withoutFirst()) : null ->
  (state.isMacroState()) ?
  	localSignalRenamingPreprocessingState(state.regions) : null ->
  (!state.signals.isEmpty) ?
  	localSignalRenamingPreprocessingSignal(state.signals, state) : null
;

Void localSignalRenamingPreprocessingState(List[synccharts::Region] regionList) :
  let region = regionList.first():
  (regionList.withoutFirst().size > 0) ?
     localSignalRenamingPreprocessingState(regionList.withoutFirst()) : null ->
  (region.states.size > 0) ?
  	 localSignalRenamingPreprocessingRegion(region.states) : null
;

Void localSignalRenamingPreprocessingSignal(List[Signal] signalList, synccharts::State state) :
  let signal = signalList.first():
  (signalList.withoutFirst().size > 0) ?
     localSignalRenamingPreprocessingSignal(signalList.withoutFirst(), state) : null ->
  (signal.isLocal()) ?
  	signal.setName(signal.name + "_" + state.getStateId()) : null
;

//-----------------------------------------------------------------------------
//--                   T O P L E V E L    E N T I T I E S                    --
//-----------------------------------------------------------------------------

//Create basic / outer most enclosing entity.	
create EntityType this createBaseEntity(synccharts::Region mainRegion):
	let outerStateURIHash = getStateId(mainRegion.states.get(0)):
   	this.setName(outerStateURIHash + "_simulation") ->
  	this.setClass1("ptolemy.actor.TypedCompositeActor") ->
  	//consider output signals that may be used in triggers 
  	//REMOVED SINCE ONLY EXPERIMENTAL YET
    outputSignalTransformation(mainRegion.states.get(0)) ->  	
  	
  	//consider input signals that may be used in outputs 
  	//REMOVED SINCE ONLY EXPERIMENTAL YET
    inputSignalTransformation(mainRegion.states.get(0)) ->
    //ATTENTION: this method can oly be used iff we remove ANY output port from modal model
    //actors whose connected/adjacent input ports appear in triggers of strong abortion transitions
    //This is because such a syncchart would not be constructive. Without this modification the
    //Ptolemy model cannot be simulated, because of in general Ptolemy cannot make any assumptions
    //about relations from outputs to inputs!

  	//normal termination preprocessing
    n2wRegion(mainRegion.states) ->

  	//rename all local signals (in order to shift them later)
    localSignalRenamingPreprocessingRegion(mainRegion.states) ->
    //shift them to the upper most state!
    localSignalShiftPreprocessingRegion(mainRegion.states, mainRegion.states.get(0)) ->
  	

    dump("signalList after renaming2: "+mainRegion.states.get(0).signals.flatten().toString()) -> 
    
    dump("REGIONS COUNT:" + mainRegion.states.get(0).regions.size) ->
  	
// FIXME: changed to test if SRDirector is ok
//   	this.createMainSyncChartDirector(mainRegion.states.get(0).signals
//   												.select(e|e.isLocal()).name) ->
   	this.createSRDirector(mainRegion.states.get(0).signals
  												.select(e|e.isLocal()).name) ->
   	//mainRegion has exactly ONE top most state
   	//iterate over all regions within this top most state
   	//the  of this containing Entity is derived from this
   	//   top most state, w/ " simulation" added
    IterateRegions(mainRegion.states.get(0).regions, this, mainRegion
    											.states.get(0).signals) ->
    //add "this" EntityType so that IterateRegions is able to add 
    //new entities or properties
    
    //finally delete output ports of modalmodels that appear in trigges of preemptive transitions!
    this.entity.DeleteOutputPorts() ->

    //connect most top input signals
    ConnectTopmostInputSignals(this, this.entity) ->

//    //delete termination output port that corrupts operation
//    deleteModalModelPorts((List[EntityType])
//  				(this.entity.select(e|e.name.startsWith(outerStateURIHash))),
//  				"terminated"+outerStateURIHash) -> 
   				
   //post processing: reconsider priorities
   ConsiderTransitionPriorities(this.entity) 
   
;






//-----------------------------------------------------------------------------
//--     A U T O M A T I C   R E C O N S I D E R   P R I O R I T I E S       --
//-----------------------------------------------------------------------------

//Go thru each hierarchy stage
//Go thru all ModalModels
//Go thru all States
//Go thru all outgoing transitions
//For all (OTHER) outgoing transitions with higher priority:
//    Add negated trigger with AND operator

//Go thru all ModalModels
Void ConsiderTransitionPriorities(List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConsiderTransitionPriorities_ModalModel(firstEntity,
										        firstEntity.entity) : null ->
	(entityList.size > 1) ?
		ConsiderTransitionPriorities(entityList.withoutFirst()) : null
;

//Use ModalModel to go to deeper hierarchies (refinements!)
Void ConsiderTransitionPriorities_ModalModel(EntityType modalModel,
											 List[EntityType] entityList):
   let firstEntity = entityList.first():
   //if this is a ModalController => Check all states
   (firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalController")
    && firstEntity.link != null) ?
   			ConsiderTransitionPriorities_ModalController(firstEntity,
   														 firstEntity.entity)
	: null ->   											
		 
	//if this is a Refinement => Recursively go into it		 
   (firstEntity.class1.matches("ptolemy.domains.modal.modal.Refinement")) ?
   			ConsiderTransitionPriorities(firstEntity.entity)
	: null ->   											
		 
//   dump("[Priorities - MM] ModalModel:"+ modalModel.name + 
//   		      ", State:"+ firstEntity.name + "(" + firstEntity.class1 + ")") ->
   
   (entityList.size > 1) ?
		ConsiderTransitionPriorities_ModalModel(modalModel, 
												entityList.withoutFirst()) 
		: null
;

//Use ModalController (of ModalModel) to go thru kernel.states
Void ConsiderTransitionPriorities_ModalController(EntityType modalController,
												  List[EntityType] entityList):
   let firstEntity = entityList.first():
   let linkList = modalController.link
   						.select(e|e.port.matches(firstEntity.name + ".outgoingPort")):
   let relationList = modalController.relation
   						.select(e|RelationContainedInLinkList(e,linkList)):
   
//   dump(" [Priorities - MC] ModalController:"+ modalController.name + 
//   		      ", State:"+ firstEntity.name + "(" + firstEntity.class1 + ")") ->
   				   
   (firstEntity.class1.matches("ptolemy.domains.modal.kernel.State")) ?
   			ConsiderTransitionPriorities_State(
   				modalController,
   				firstEntity,
   				relationList,
   				relationList) 
   	: null ->

   	(entityList.size > 1) ?
		ConsiderTransitionPriorities_ModalController(modalController, 
													 entityList.withoutFirst()) 
		: null
;

//Helper function
Boolean RelationContainedInLinkList(RelationType relation, 
									List[LinkType] linkList) :
	let firstLink = linkList.first():
	let match = firstLink.relation.matches(relation.name):
    (linkList.size > 1) ?
		 match || RelationContainedInLinkList(relation, linkList.withoutFirst())
     :
		 match
;


//Use Kernel.State to go thru all transitions
Void ConsiderTransitionPriorities_State(EntityType modalController,
										EntityType kernelState,
										List[RelationType] outgoingRelations,
										List[RelationType] relationList) :
	let firstRelation = relationList.first():
	let outgoingRelationsCopy = outgoingRelations.select(e|true):
//   	dump("  [Priorities - ST] State:"+ kernelState.name + 
//   		      ", Relation:"+ firstRelation.getTrigger() + " [" +firstRelation.getPriority()+"] --> " + relationList.size) ->
   		      
	ConsiderTransitionPriorities_Relation(firstRelation, outgoingRelationsCopy) ->
   		      
    (relationList.size > 1) ?
    	ConsiderTransitionPriorities_State(modalController,
										kernelState,
										outgoingRelations,
										relationList.withoutFirst())
     	: null										
;


String getTrigger(Moml::RelationType relation) :
	relation.property.select(e|e.name.matches("guardExpression")).get(0).value
;

Void setTrigger(RelationType relation, String trigger) :
	dump("  SET TRIGGER:"+trigger) ->
	relation.property.select(e|e.name.matches("guardExpression")).get(0)
		.setValue(trigger)
;

int getPriority(RelationType relation) :
	(relation.property.select(e|e.name.matches("priority")).get(0).value).asInteger()
;

Boolean isEmptyTrigger(RelationType relation) :
	((relation == null) 
	||
	(relation.getTrigger() == null)
	|| 
	(relation.getTrigger().length == 0)) ?
	 		true
	 : false	
;

//For each transition (relation), add negated trigger of transition w/ 
//lower priority value
Void ConsiderTransitionPriorities_Relation(RelationType relation,
										   List[RelationType] otherRelations):
    let firstOtherRelation = otherRelations.first():

   	dump("   [Priorities - RE] Compare:"+ relation.getTrigger() + "[" + relation.getPriority() + "] > " 
   		      + firstOtherRelation.getTrigger() + " [" +firstOtherRelation.getPriority()+"] ---> " + otherRelations.size) ->
    
    //if other relation has higher priority - both triggers != null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (!firstOtherRelation.isEmptyTrigger())
       && (!relation.isEmptyTrigger())) ?
       relation.setTrigger("(!("+firstOtherRelation.getTrigger()+")) && "+relation.getTrigger())
       : null ->

    //if other relation has higher priority - relation.trigger = null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (!firstOtherRelation.isEmptyTrigger())
       && (relation.isEmptyTrigger())) ?
       relation.setTrigger("(!("+firstOtherRelation.getTrigger()+"))")
       : null ->

    //if other relation has higher priority - otherRelation.trigger = null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (firstOtherRelation.isEmptyTrigger())
       && (!relation.isEmptyTrigger())) ?
       relation.setTrigger("(false) && "+relation.getTrigger())
       : null ->
    
    //if other relation has higher priority - both triggers = null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (firstOtherRelation.isEmptyTrigger())
       && (relation.isEmptyTrigger())) ?
       relation.setTrigger("(false)")
       : null ->
       
    (otherRelations.size > 1) ?   
     			ConsiderTransitionPriorities_Relation(relation, otherRelations.withoutFirst())
				: null 								    										   	
;										   



//-----------------------------------------------------------------------------
//--        A U T O M A T I C - D E L E T E  O U T P U T   P O R T S         --
//-----------------------------------------------------------------------------

//ATTENTION: this method can oly be used iff we remove ANY output port from modal model
//actors whose connected/adjacent input ports appear in triggers of strong abortion transitions
//This is because such a syncchart would not be constructive. Without this modification the
//Ptolemy model cannot be simulated, because of in general Ptolemy cannot make any assumptions
//about relations from outputs to inputs!

// call this method with the root region

Void DeleteOutputPorts(EntityType entity) :
    resetQueue2Delete() ->
	DeleteOutputPorts(entity, null) ->
	if (getQueueSize2Delete() > 0) then 
		deleteModalModelPort()
	else
	  	null
;


Void DeleteOutputPorts(EntityType entity, EntityType modalModel) :
    let entityClass = entity.class1:
	switch {
	  case (entityClass.matches("ptolemy.domains.modal.modal.ModalModel")) :
			// if this is a region, go on with modal controller (typically there is just one per region)
			// modalModel.entity.select(e|e.name.matches("_Controller")).first()
		    entity.entity.DeleteOutputPorts(entity)
	  case (entityClass.matches("ptolemy.domains.modal.modal.ModalController") && (modalModel != null)) :
	  		// delete (output) ports for controller
			 modalModel.port.select(p|p.name.endsWith("o")).DeleteOutputPorts2(modalModel)
	  case (entityClass.matches("ptolemy.domains.modal.modal.Refinement")) :
	        // do this recursively in all hierachy levels
	        entity.entity.DeleteOutputPorts(null)
	  default :
	    	null
	} 
;


cached Void DeleteOutputPorts2(PortType port, EntityType modalModel) :
  // this statemet gets all transition relations, that have a property named guardExpression
  // containing the specific port in question
  // if this list is > 0 then the output port must be deleted!
  let controller = (EntityType) modalModel.entity.select
 									(e|e.name.matches("_Controller")).first():
  let transitions = controller.relation.select(r|r.name.contains("transition")) :
  
  dump("#### test #### " + port.name + ", " +  modalModel.name) ->
  
  transitions.DeleteOutputPorts3(port, modalModel)
   
 ;


cached Void DeleteOutputPorts3(RelationType r, PortType port, EntityType modalModel) :
    let portName = port.name.subString(0,port.name.length-1) :
    let preemptiveTransition = r.property.select(p|p.name.matches("preemptive") && p.value.matches("true")) :
    let foundExpression =      r.property.select(p|p.name.matches("guardExpression") && p.value.contains(portName)) : 
 	let controller = (EntityType) modalModel.entity.select(e|e.name.matches("_Controller")).first():	
 	
 	//dumpI(preemptiveTransition.size) ->
 	//dumpI(foundExpression.size) ->
    if (preemptiveTransition.size > 0 
    	 && foundExpression.size > 0) then
		  //dump("DELETE >>> " + port.name) ->
 	      //modalModel.deleteModalModelPort(port.name)
 	      enqueue2Delete(modalModel, port.name)
 	      //controller.port.remove(controller.port
 		  //	  .select(e|e.name.matches(portName)).first()) 
 	else
 		null
;


Void deleteModalModelPort() :
  let modalModel = popModalModel2Delete() :
  let portName = popPortName2Delete() :
  
  dump("||||||||||| DELETE :" + modalModel.name + ", " + portName) ->
  
  deleteModalModelPort(modalModel, portName)
  
  ->
  if (getQueueSize2Delete() > 0) then
  	  deleteModalModelPort()
  else
      null
; 


// Termination ports are not needed on the toplevel, so these can be deleted.
// This is done by iterating thru the list of all modalmodels (and their
// controller).
Void deleteModalModelPort(EntityType modalModel, String portName) :
 	let controller = (EntityType) modalModel.entity.select
 									(e|e.name.matches("_Controller")).first():
	//debug output
 	dump("DELETE "+portName +" IN " + modalModel.name) ->
 	
	//delete port and links in modal model
	modalModel.relation.remove(modalModel.relation
			  .select(e|e.name.matches(portName+"Relation")).first()) ->
	modalModel.port.remove(modalModel.port.select(e|e.name.matches(portName))
			  .first()) ->

	modalModel.link.remove(modalModel.link
			  .select(e|e.relation.matches(portName+"Relation")).first()) ->
	modalModel.link.remove(modalModel.link
			  .select(e|e.relation.matches(portName+"Relation")).first()) ->
	modalModel.link.remove(modalModel.link
			  .select(e|e.relation.matches(portName+"Relation")).first()) ->


	//debug output
 	dump("DELETE "+portName +" IN " + controller.name) ->
 	
 	//delete port in controller
 	controller.port.remove(controller.port
 			  .select(e|e.name.matches(portName)).first())
;


Void enqueue2Delete(Moml::EntityType modalModel, String portName) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.enqueue2Delete(
			 org.ptolemy.moml.Moml.EntityType, java.lang.String) 
;

String popPortName2Delete() :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.popPortName2Delete()
;

Moml::EntityType popModalModel2Delete() :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.popModalModel2Delete()
;

Void resetQueue2Delete() :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.resetQueue2Delete()
;

int getQueueSize2Delete() :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.getQueueSize2Delete()
;


	//modalModel.port.remove(modalModel.port.select(e|e.name.matches(portName))
	//		  .first()) ->
	//modalModel.relation.remove(modalModel.relation
	//		  .select(e|e.name.matches(portName+"Relation")).first()) ->
	//modalModel.link.remove(modalModel.link
	//		  .select(e|e.relation.matches(portName+"Relation")).first()) ->
	//modalModel.link.remove(modalModel.link
	//		  .select(e|e.relation.matches(portName+"Relation")).first()) ->
 	
 	//delete port in controller
 	

//-----------------------------------------------------------------------------
//--                 A U T O M A T I C - C O N N E N T I O N                 --
//-----------------------------------------------------------------------------

//Connect top most input signals.
Void ConnectTopmostInputSignals(EntityType baseEntity, 
							    List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectTopmostInputSignalsHelper(baseEntity, 
										 firstEntity.name, 
										 firstEntity.port) : null ->
	(entityList.size > 0) ?
		ConnectTopmostInputSignals(baseEntity, entityList.withoutFirst()) : null
;
Void ConnectTopmostInputSignalsHelper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	//for only input ports (that have a property with the name "*_input")
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "environment_input") : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
			    modalModelName + "." + firstPort.name, 
			    firstPort.name + "_RELATION") : null ->
		
	//create kielerIO for every environment input and connect it	
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addKielerIO(baseEntity, 
					firstPort.name + "_KIELERIO", 
					firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
		        firstPort.name + "_KIELERIO.signal", 
		        firstPort.name + "_RELATION") : null ->

	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addVertexRelation(baseEntity, 
		                  firstPort.name + "_RELATION", 
		                  "local_input") : null ->
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
		        modalModelName + "." + firstPort.name, 
		        firstPort.name + "_RELATION") : null ->
 
	//generate KielerCombine-functions and connect local outputs to it
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addCombineFunction(baseEntity, 
		                   firstPort.name + "_COMBINE") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addRelation(baseEntity, 
		            firstPort.name + modalModelName + "_COMBINERELATION", 
		            "local_output") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
		        firstPort.name + "_COMBINE.input", 
		        firstPort.name + modalModelName + "_COMBINERELATION" ) : null->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
		        modalModelName + "." + firstPort.name, 
		        firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	//connect local input vertex with output combine OR function operators
	//be careful: local signals end with o or i now, oCombine must be 
	//linked with iVertex!!!
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
		        firstPort.name.subString(0,firstPort.name.length-1) 
		         										+ "o_COMBINE.output",
		        firstPort.name + "_RELATION") : null ->
	
	//generate ADD-functions and connect environment outputs to it
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addEnvironmentCombineFunction(baseEntity, 
									  firstPort.name + "_COMBINE", 
									  firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addRelation(baseEntity, 
					firstPort.name + modalModelName + "_COMBINERELATION", 
					"environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.input", 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	(portList.size > 0) ?
		ConnectTopmostInputSignalsHelper(baseEntity, 
										 modalModelName, 
										 portList.withoutFirst()) : null
;


//Connect nested input signals.
Void ConnectNestedInputSignals(EntityType baseEntity, 
							   List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectNestedInputSignals_LocalToEnvironment_Helper
										(baseEntity,
					 					firstEntity.name,
					 					firstEntity.port) : null ->
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectNestedInputSignalsHelper(baseEntity, 
										firstEntity.name, 
										firstEntity.port) : null ->
	(entityList.size > 0) ?
		ConnectNestedInputSignals(baseEntity, 
								  entityList.withoutFirst()) : null
;
//Local signals for which exist input and output ports are treated as 
//environment signals.
//Because they are defined in an outer layer, so rename their type accordingly!
Void ConnectNestedInputSignals_LocalToEnvironment_Helper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	
	//the portlist is the one of the inspected modalModel that we compare
	//the base entity is the one we check for the ports

	((firstPort.property.select(e|e.name.matches("local_input")).size > 0)
	  && (baseEntity.port.select(e|e.name.matches(firstPort.name)).size > 0)) ?
	firstPort.property.select(e|e.name.matches("local_input"))
				.setName("environment_input") 
	: null ->
			
	((firstPort.property.select(e|e.name.matches("local_output")).size > 0) 
	  && (baseEntity.port.select(e|e.name.matches(firstPort.name)).size > 0)) ?
	firstPort.property.select(e|e.name.matches("local_output"))
				.setName("environment_output") 
	: null ->

	(portList.size > 0) ?
		ConnectNestedInputSignals_LocalToEnvironment_Helper(
										baseEntity,
									 	modalModelName, 
									 	portList.withoutFirst()) : null
;

Void ConnectNestedInputSignalsHelper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	//for termination ports
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		dump("Connect Termination for Port :"
//			 +firstPort.name+" in " + baseEntity.name) : null ->
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		addRelation(baseEntity, 
//					modalModelName + "_COMBINERELATION", 
//					"termination") : null ->
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		addLink(baseEntity, 
//				"KielerNormalTermination.state terminated", 
//				modalModelName  + "_COMBINERELATION") : null ->
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		addLink(baseEntity, 
//				modalModelName + ".terminated" + baseEntity.name, 
//				modalModelName  + "_COMBINERELATION") : null ->
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		addRelation(baseEntity, 
//					"TERMINATION_RELATION", 
//					"termination") : null ->
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		addLink(baseEntity, 
//				"KielerNormalTermination.all states terminated", 
//				"TERMINATION_RELATION") : null ->
	//only (!!!) connect termination signals for abortion of outer/current state!
	// (not INNER states)
//	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
//		addLink(baseEntity, 
//				"terminated" + baseEntity.name, 
//				"TERMINATION_RELATION") : null ->
//	
	//for only input ports (that have a property with the name "*_input")
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "environment_input") : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + 
				firstPort.name, 
				firstPort.name + "_RELATION") : null ->
		
	//connect every environment input to relation	
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name, 
				firstPort.name + "_RELATION") : null ->

	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "local_input") : null ->
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + "_RELATION") : null ->
 
	//generate KielerCombine-functions and connect local outputs to it
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addCombineFunction(baseEntity, 
						   firstPort.name + "_COMBINE") : null ->

 ///-----
	//do this only, iff there are no input/output ports of this local signal,
	// hence it is defined on this hierarchy layer! (= true local signals),
	// local signals are treated as environment signals in nested hearchy 
	//layers!
	
	//connect local input vertex with output combine operator
	//be careful: local signals end with o or i now, oCombine must be linked 
	//with iVertex!!!
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name.subString(0,firstPort.name.length-1) 
							+ "o_COMBINE.output", 
				firstPort.name + "_RELATION") : null ->
	//connect local output vertex with input combine 
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addRelation(baseEntity, 
					firstPort.name + modalModelName + "_COMBINERELATION",
					 "local_output") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.input", 
				firstPort.name + modalModelName + "_COMBINERELATION" ) : null->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + modalModelName +"_COMBINERELATION") : null ->
 ///-----

	//generate KielerCombine-functions and connect environment outputs to it
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addEnvironmentCombineFunction(baseEntity, 
									  firstPort.name + "_COMBINE", 
									  firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addRelation(baseEntity, 
					firstPort.name + modalModelName + "_COMBINERELATION", 
					"environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.input", 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	//connect combine function w/ output ports
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name, 
				firstPort.name + "_RELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.output", 
				firstPort.name + "_RELATION") : null ->

	(portList.size > 0) ?
		ConnectNestedInputSignalsHelper(baseEntity, 
										modalModelName, 
										portList.withoutFirst()) : null
;


//-----------------------------------------------------------------------------
//--            R E G I O N S     A N D     M A C R O S T A T E S            --
//-----------------------------------------------------------------------------

//Create ModalModel == Region-Component. 
create EntityType this createModalModelEntity(synccharts::Region region, 
											  int number, 
									 	List[Signal] signalList):
	let p0 = new PropertyType:
	let p1 = new PropertyType:
		p0.setName("directorClass") ->
		p0.setClass("ptolemy.data.expr.StringParameter") ->
		p0.setValue("ptolemy.domains.modal.kernel.KielerFSMDirector") ->
		p1.setName("_tableauFactory") ->
		p1.setClass("ptolemy.vergil.modal.modal.ModalTableauFactory") ->
	this.property.add(p1) ->
   	this.setName(getStateId(region.parentState) 
   											 	+ "_region_" + number) ->
  	this.setClass1("ptolemy.domains.modal.modal.ModalModel") ->
  	//first add signals if any
  	(signalList.size > 0) ?
  		addSignalsToModalModel(this, signalList, region) : null ->
//  	//then add termination signal (outer)
//  	addTerminationSignalToModalModel(this, region) ->
//  	//then add termination signals (inner)
//  	addTerminationSignalsToModalModel(this, region.states) ->
  	//then create simple states and macro state declarations
   	this.entity.add(createModalControllerEntity(region, signalList)) ->
   	//then add macro state refinements (for all macro states)
   	IterateStatesRefinement(region.states, this, signalList)
;
//Create ModalController == Region-Declaration (simple states and macro
// states declarations).
create EntityType this createModalControllerEntity(synccharts::Region region,
									 List[Signal] signalList):
   	this.setName("_Controller") ->
  	this.setClass1("ptolemy.domains.modal.modal.ModalController") ->
  	//first add signals if any
  	(signalList.size > 0) ?
		addSignalsToModalController(this, 
									null, 
									signalList, 
									region, 
									null) : null ->
//  	//add termination signal
//	this.addTerminationSignalToModalController(null, region.parentState) ->
//  	//add termination signals 
//	this.addTerminationSignalsToModalController(null, region.states) ->
  	//then iterated all states (if any in this region)
	(region.states.size > 0) ? 
		IterateStates(region.states, this) : null
;


//Create MacroState == State-Component (of a macro state).
create EntityType this createMacroStateEntity(synccharts::State state):
	//elementURIFragment is *NOT* real XPATH!
	let elementURIFragment = getURIFragment(state):
	let elementURIFragmentProperty = newPropertyType("elementURIFragment",
							 		"ptolemy.kernel.util.StringAttribute",
							 		elementURIFragment):
	let p1 = new PropertyType:
	let p2 = new PropertyType:
		p1.setName("refinementName") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p1.setValue(getStateId(state)) ->
		p2.setName("originalName") ->
		p2.setClass("ptolemy.kernel.util.StringAttribute") ->
		p2.setValue(state.label+" ("+state.id+")") ->
   	this.setName(getStateId(state)) ->
  	this.setClass1("ptolemy.domains.modal.kernel.State") ->
	this.property.add(p1) ->
	this.property.add(p2) ->
	this.property.add(elementURIFragmentProperty) ->
  	SetStateInitialFinalFlag(state, this)
;


//Create ModalRefinement == State-Definition (of a macro state /w regions).
create EntityType this createMacroStateRefinementEntity(
										synccharts::State state, 
										EntityType modalModel,
										List[Signal] signalList):
   	this.setName(getStateId(state)) ->
  	this.setClass1("ptolemy.domains.modal.modal.Refinement") ->
   	//getMovedSignalNames() contains names of moved signals
	//signalList.addAll(state.signals) ->
	//signalList.union(state.signals) ->
	//FIXME: why does the added list gets empty?//
	moveToSignalList(signalList, state.signals) ->
   	//add signals to refinement (so outer signals are visible inside), if any
   	(signalList.size > 0) ?
	   	this.addSignalsToModalController(modalModel, 
	   									 signalList, 
	   									 state.parentRegion, 
	   									 getMovedSignalNames()) : null ->
   	//create SyncChartDirector
// FIXME: changed to test if SRDirector is ok
//   	this.createSyncChartDirector(getMovedSignalNames()) ->
   	this.createSRDirector(getMovedSignalNames()) ->

//   	//add termination signal
//   	this.addTerminationSignalToModalController(modalModel, state) ->
//   	//add KielerNormalTermination
//   	this.addKielerNormalTermination() ->
   	IterateRegions(state.regions, this, signalList) ->
    //connect nested input signals
    ConnectNestedInputSignals(this, this.entity)
;
//Create SimpleState == State-Component.
create EntityType this createSimpleStateEntity(synccharts::State state):
	//elementURIFragment is *NOT* real XPATH!
	let elementURIFragment = getURIFragment(state):
	let elementURIFragmentProperty = newPropertyType("elementURIFragment",
							 		"ptolemy.kernel.util.StringAttribute",
							 		elementURIFragment):
   	this.setName(getStateId(state)) ->
  	this.setClass1("ptolemy.domains.modal.kernel.State") ->
	this.property.add(elementURIFragmentProperty) ->
  	SetStateInitialFinalFlag(state, this)
;


//-----------------------------------------------------------------------------
//--            (J A V A)   H E L P E R    F U N C T I O N S                 --
//-----------------------------------------------------------------------------

//Move signalList to the other newList. 
Void moveToSignalList(List[Signal] newList, 
					  List[Signal] signalList) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			moveToSignalList(org.eclipse.emf.common.util.EList, 
							 org.eclipse.emf.common.util.EList)
;
List[String] getMovedSignalNames():
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			 getMovedSignalNames()
;


//Do some java console output for debugging purpose. 
Void P() :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.P()
//	null
;

//Do some java console output for debugging purpose. 
Void V() :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.V()
//	null
;


//Do some java console output for debugging purpose. 
Void dump(String s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.dump(
			 java.lang.String)
//	null
;
Void dumpI(Integer s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.dumpI(
			 java.lang.Integer)
//	null
;



//Get URIFragment of an model element to identify it. 
String getURIFragment(synccharts::State state) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava
			.getURIFragment(de.cau.cs.kieler.synccharts.State)
;

//Get State Id of an model element to identify it. 
String getStateId(synccharts::State state) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava
			.getStateId(de.cau.cs.kieler.synccharts.State)
;

//Get URIFragment of an model element to identify it. 
String getURIFragment(synccharts::Transition transition) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava
			.getURIFragment(de.cau.cs.kieler.synccharts.Transition)
;

//Get hash value of a string. 
String hash(String s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			hash(java.lang.String)
;

//Get URIFragment of an model element to identify it. 
int getPortType(Signal signal, synccharts::Region region) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			getPortType(de.cau.cs.kieler.core.expressions.Signal,
						de.cau.cs.kieler.synccharts.Region)
;

//Construct a new property entity.
PropertyType newPropertyType
								(String name,
								String class,
								String value) :
	let p1 = new PropertyType :
	p1.setClass(class) ->
	p1.setName(name) ->
	p1.setValue(value) ->
	p1
;

//Decide whether a states is initial or final and add the appropriate
//property to the entity.
Void SetStateInitialFinalFlag(synccharts::State state, 
									  EntityType entity) :
	let p1a = new PropertyType:
	let p1b = new PropertyType:
	let p2 = new PropertyType:
		p1a.setName("isInitialState") ->
		p1a.setClass("ptolemy.data.expr.Parameter") ->
		p1a.setValue("true") ->
		p1b.setName("isInitialState") ->
		p1b.setClass("ptolemy.data.expr.Parameter") ->
		p1b.setValue("false") ->
		p2.setName("isFinalState") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
  	state.isInitial ? entity.property.add(p1a) : entity.property.add(p1b) 
  	//(do not set it to final, otherwise it can't even being reset!)
  	//this was unfortunately an error in ptolemy that was fixed
  	//BUT the syncchart fixed point iteration does not work if we
  	//cannot fire FSMs again (-> unknown inputs may remain)
  	//state.isFinal ? entity.property.add(p2) :null
;

//Test whether a state is a macro state or a simple state.
boolean isMacroState(synccharts::State state) :
 	state.regions.size > 0
; 

//Construct the trigger.
String buildTrigger(expressions::Expression expression, 
					String terminatedURIHash) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			buildTrigger(de.cau.cs.kieler.core.expressions.Expression, 
						 java.lang.String)
;

//Construct the effect.
String buildEffect(List[synccharts::Effect] effectList, 
				   String terminatedURIHash) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			buildEffect(org.eclipse.emf.common.util.EList, 
						java.lang.String)
;


//-----------------------------------------------------------------------------
//--               I T E R A T I O N S  ( STATES & REGIONS )                 --
//-----------------------------------------------------------------------------

//Iteratate over all states (in a region).
//For  macro states : add states entity AND list them as a refinement property
//For simple states : add states
Void IterateTransitions(List[synccharts::Transition] transitionList,
							 EntityType entity):
 	let transition = transitionList.last():
 	(transitionList.size > 0) ? 
 			dump(transition.label.toString()) 
 			: null ->
 	(transitionList.size > 0) ? 
 			dump(getStateId(transition.sourceState) + " -> " + 
 			getStateId(transition.targetState)) 
 			: null ->
 	(transitionList.size > 0) ? 
 			dump(transition.sourceState.toString() + " -> " + 
 			transition.targetState.toString()) 
 			: null ->
	(transitionList.size > 0) ? 
			addTransition(transition,
						  entity,
				  		  getStateId(transition.sourceState) 
				  		  + "_transition_" + transitionList.size) 
		    : null -> 	
    (transitionList.size > 1) ? 
    		IterateTransitions(transitionList.withoutLast(), entity) 
    		: null
;


//Iteratate over all states (in a region).
//For  macro states : add states entity AND list them as a refinement property
//For simple states : add states
Void IterateStates(List[synccharts::State] stateList, 
						EntityType entity):
 	let state = stateList.last():
 	state.isMacroState() ? 
 			entity.entity.add(createMacroStateEntity(state)) 
 			: entity.entity.add(createSimpleStateEntity(state)) ->
 	IterateTransitions(state.outgoingTransitions, entity) ->
    (stateList.size > 1) ? 
    		IterateStates(stateList.withoutLast(), entity) 
    		: null
;


//Iteratate over all states (in a region)
//For  macro states : define the refinement (and recursively add regions!)
//For simple states : do nothing
Void IterateStatesRefinement(List[synccharts::State] stateList, 
								  EntityType entity, 
								  List[Signal] signalList) :
 	let state = stateList.last():
 	state.isMacroState() ? 
 				entity.entity.add(
 					createMacroStateRefinementEntity(state, entity, signalList)) 
 				: null ->
    (stateList.size > 1) ? 
    			IterateStatesRefinement(stateList.withoutLast(), 
    			entity, signalList) 
    			: null
;


//Iterate over all regions (in a state)
//Add an own modal model for each region
//Define all signals that are defined until now!
Void IterateRegions(List[synccharts::Region] regionList, 
					EntityType entity, 
					List[Signal] signalList):
 	let region = regionList.last():
 	entity.entity.add(createModalModelEntity(region, 
 											 regionList.size, 
 											 signalList)) ->
    (regionList.size > 1) ? 
    				IterateRegions(regionList.withoutLast(), 
    							   entity, 
    							   signalList) : null 
; 


//-----------------------------------------------------------------------------
//--                 C R E A T E     D I R E C T O R S                       --
//-----------------------------------------------------------------------------

//Create a "SYNCCHART Director" (for macro state definition)
Void createSyncChartDirector(EntityType entity, 
							 List[String] stateSignalNames):
    let p0 = new PropertyType:
	 let p1 = new PropertyType:
	 p1.setName("statesignals") ->
	 p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	 p1.setValue(stateSignalNames.flatten().toString()) ->
    p0.setName("XXX Kieler SyncChart Director") ->
	p0.setClass("ptolemy.actor.kiel.SyncChartDirector") ->
	p0.property.add(p1) ->
	entity.property.add(p0) 
;

//Create a "SYNCCHART Director" (for macro state definition)
Void createSRDirector(EntityType entity, 
							 List[String] stateSignalNames):
    let p0 = new PropertyType:
	 let p1 = new PropertyType:
	 p1.setName("statesignals") ->
	 p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	 p1.setValue(stateSignalNames.flatten().toString()) ->
    p0.setName("SR Director") ->
	p0.setClass("ptolemy.domains.sr.kernel.SRDirector") ->
	p0.property.add(p1) ->
	entity.property.add(p0) 
;

//Create outer most "SYNCCHART Director" (ticks every seconds)
Void createMainSyncChartDirector(EntityType entity, 
								 List[String] stateSignalNames):
    let p0 = new PropertyType:
	 let p1 = new PropertyType:
	 let p2 = new PropertyType:
	 let p3 = new PropertyType:
	 let p4 = new PropertyType:
	 let p5 = new PropertyType:
		p1.setName("iterations") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("0") ->
		p2.setName("synchronizeToRealTime") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("false") ->
		p3.setName("timeResolution") ->
		p3.setClass("ptolemy.data.expr.Parameter") ->
		p3.setValue("1.0E-10") ->
		p4.setName("period") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		p4.setValue("0") ->
  	 	p5.setName("statesignals") ->
	 	p5.setClass("ptolemy.kernel.util.StringAttribute") ->
	 	p5.setValue(stateSignalNames.flatten().toString()) ->
    p0.setName("XXX Kieler SyncChart Director") ->
	p0.setClass("ptolemy.actor.kiel.SyncChartDirector") ->
	p0.property.add(p1) ->
	p0.property.add(p2) ->
	p0.property.add(p3) ->
 	p0.property.add(p4) ->
 	p0.property.add(p5) ->
	entity.property.add(p0) 
;


//-----------------------------------------------------------------------------
//--         C R E A T E     R E L A T I O N S   &   L I N K S               --
//-----------------------------------------------------------------------------

//Add a state 2 state transition.
Void addTransition(	synccharts::Transition transition, 
					EntityType entity,
					String name) :
	let link1 = new LinkType:
	let link2 = new LinkType:
	dump("addTransition from " + getStateId(transition.sourceState) + " to " + getStateId(transition.targetState)) ->
	link1.setPort(
		getStateId(transition.sourceState) + ".outgoingPort") ->
	link1.setRelation(name) ->
	link2.setPort(
		getStateId(transition.targetState) + ".incomingPort") ->
	link2.setRelation(name) ->
	entity.relation.add(createRelation(name, transition)) ->
	entity.link.add(link1) ->
	entity.link.add(link2) 
;


//Create a Relation Type for a Port connection to a ModalController or 
//ModalModel.
Void addPortRelationAndLinks(EntityType entity, String portName):
    let relation = new RelationType:
	let p1 = new PropertyType:
	let link1 = new LinkType:
	let link2 = new LinkType: 
		p1.setName("width") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("Auto") ->
    relation.setName(portName + "Relation") ->
    relation.setClass("ptolemy.actor.TypedIORelation") ->
	relation.property.add(p1) ->
	link1.setPort(portName) ->
	link1.setRelation(portName + "Relation") ->
	link2.setPort("_Controller." + portName) ->
	link2.setRelation(portName + "Relation") ->
	entity.relation.add(relation) ->
	entity.link.add(link1) ->
	entity.link.add(link2)
;


//Create a Relation Type for State2State transitions.
create RelationType this createRelation(String name,
										synccharts::Transition transition):
	let p1 = new PropertyType:
//	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4 = new PropertyType:
	let p5 = new PropertyType:
	let p6 = new PropertyType:
	let p7 = new PropertyType:
	let p8 = new PropertyType:
	let p9 = new PropertyType:
		p1.setName("EmfFragmentURI") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p1.setValue(getURIFragment(transition)) ->
//		p2.setName("outputActions") ->
//		p2.setClass("ptolemy.domains.modal.kernel.OutputActionsAttribute") ->
		p3.setName("setActions") ->
		p3.setClass("ptolemy.domains.modal.kernel.CommitActionsAttribute") ->
		p4.setName("reset") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		//by default in SyncCharts we have a reset behavior unless its 
		//a history transition
		(!transition.isHistory) ? p4.setValue("true") : p4.setValue("false") ->
		p5.setName("preemptive") ->
		p5.setClass("ptolemy.data.expr.Parameter") ->
		(transition.type.toString().matches("STRONGABORT")) ? 
								p5.setValue("true") : p5.setValue("false") ->
		p6.setName("defaultTransition") ->
		p6.setClass("ptolemy.data.expr.Parameter") ->
		p6.setValue("false") -> //defaultTransition is NOT "normal termination"
		//transition.transitionKind.toString().matches("NORMALTERMINATION") ? 
		//						p6.setValue("true") : p6.setValue("false") ->
		p7.setName("nondeterministic") ->
		p7.setClass("ptolemy.data.expr.Parameter") ->
		p7.setValue("false") ->
		p8.setName("refinementName") ->
		p8.setClass("ptolemy.kernel.util.StringAttribute") ->
		//add priority as string value for post procession on ptolemy model
		p9.setName("priority") ->
		p9.setClass("ptolemy.kernel.util.StringAttribute") ->
		p9.setValue(""+transition.priority) ->
    this.setName(name) ->
	this.property.add(p1) ->
//	this.property.add(p2) ->
	this.property.add(p3) ->
	this.property.add(p4) ->
	this.property.add(p5) ->
	this.property.add(p6) ->
	this.property.add(p7) ->
	this.property.add(p8) ->
	this.property.add(p9) ->
	addTrigger(this, transition) ->
	addEmission(this, transition)
;


//-----------------------------------------------------------------------------
//--                N O R M A L    T E R M I N A T I O N                     --
//-----------------------------------------------------------------------------

//Add termination signals so a normal termination (weak abortion) can be 
//triggered.
Void addTerminationSignalToModalController(EntityType entity, 
										   EntityType parent, 
										   synccharts::State state) :
	let port = new PortType:
	let p1a = new PropertyType:
	//let p1b = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	port.setName("terminated" + getStateId(state)) ->
	port.setClass("ptolemy.domains.modal.modal.RefinementPort") ->
	p1a.setName("output") ->
	//p1b.setName("input") ->
	p2.setName("_type") ->
	p2.setClass("ptolemy.actor.TypeAttribute") ->
	p2.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3.setName("termination") ->
   	p3.setClass("ptolemy.kernel.util.StringAttribute") ->
	port.property.add(p1a) ->
	//port.property.add(p1b) ->
	port.property.add(p2) ->
	port.property.add(p3) ->
	entity.port.add(port)
;
Void addTerminationSignalsToModalController(EntityType entity, 
										    EntityType parent, 
										List[synccharts::State] stateList) :
	let state = stateList.last():
	//only for macro states
	(state.isMacroState()) ?
			addTerminationSignalToModalController(entity, 
												  parent, 
												  state) : null ->
	(stateList.size > 1)?
		addTerminationSignalsToModalController(entity, parent, 
										  	  stateList.withoutLast()) : null
;
Void addTerminationSignalToModalModel(EntityType entity, 
									  synccharts::Region region) :
 	addTerminationSignalToModalModel(entity, region.parentState)
;
Void addTerminationModalModelLink(EntityType entity, String stateURIHash) : 
	let l = new LinkType:
	l.setPort(stateURIHash + ".terminated" + stateURIHash) ->
	l.setRelation("terminated" + stateURIHash + "Relation") ->
	entity.link.add(l)	
;
Void addTerminationSignalToModalModel(EntityType entity, 
									  synccharts::State state) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	port.setName("terminated" + getStateId(state)) ->
	port.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	p1.setName("output") ->
	p2.setName("_type") ->
	p2.setClass("ptolemy.actor.TypeAttribute") ->
	p2.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3.setName("termination") ->
   	p3.setClass("ptolemy.kernel.util.StringAttribute") ->
	port.property.add(p1) ->
	port.property.add(p2) ->
	port.property.add(p3) ->
	entity.port.add(port) ->  
	addPortRelationAndLinks(entity, port.name)
;
Void addTerminationSignalsToModalModel(EntityType entity, 
									   List[synccharts::State] stateList) :
	let state = stateList.last():
	//only for macro states
	(state.isMacroState()) ?
		addTerminationSignalToModalModel(entity, state) : null ->  
	(state.isMacroState()) ?
	 	addTerminationModalModelLink(entity, 
	 								 ""+getStateId(state)) 
	 	: null ->
	(stateList.size > 1)?
		addTerminationSignalsToModalModel(entity, 
										  stateList.withoutLast()) 
		: null
;


//-----------------------------------------------------------------------------
//--                     A D D I N G     S I G N A L S                       --
//-----------------------------------------------------------------------------

//Add signals in signalsList to ModalModel entity.
Void addSignalsToModalModel(EntityType entity, 
							List[Signal] signalList,
							synccharts::Region region) :
	let port = new PortType:
	let portLocalIn = new PortType:
	let portLocalOut = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p3a = new PropertyType:
	let p3b = new PropertyType:
	let p4a = new PropertyType:
	let p4b = new PropertyType:
	let p4c = new PropertyType:
	let p4d = new PropertyType:
	let portType = new PropertyType:
	let portTypeLocalIn = new PropertyType:
	let portTypeLocalOut = new PropertyType:
	let signal = signalList.first():
	port.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	port.setName(signal.name) ->
	portLocalIn.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalIn.setName(signal.name+"i") ->
	portLocalOut.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalOut.setName(signal.name+"o") ->
	p4a.setName("environment_input") ->
	p4b.setName("environment_output") ->
	p4c.setName("local_input") ->
	p4d.setName("local_output") ->
	p4a.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4b.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4c.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4d.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setName((getPortType(signal, region)).toString()) ->
	portTypeLocalIn.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalIn.setName("1") -> //in
	portTypeLocalOut.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalOut.setName("2") -> //out
	//denote environmental and local input/output signals
	(signal.isInput) ? port.property.add(p4a) : null ->
	(signal.isOutput) ? port.property.add(p4b) : null ->
	p1.setName("input") ->
	p2.setName("output") ->
	//if local signal, create in AND output port
	portLocalIn.property.add(p4c) ->
 	portLocalOut.property.add(p4d) ->	
	portLocalIn.property.add(p1) ->
	portLocalOut.property.add(p2) ->
	p3.setName("_type") ->
	p3.setClass("ptolemy.actor.TypeAttribute") ->
	p3.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3a.setName("_type") ->
	p3a.setClass("ptolemy.actor.TypeAttribute") ->
	p3a.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3b.setName("_type") ->
	p3b.setClass("ptolemy.actor.TypeAttribute") ->
	p3b.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	port.property.add(p3) ->
	port.property.add(portType) -> //input or real type
	portLocalIn.property.add(p3a) ->
	portLocalIn.property.add(portTypeLocalIn) -> //(local) input
	portLocalOut.property.add(p3b) ->
	portLocalOut.property.add(portTypeLocalOut) -> //(local) output
	
	//only add ports that are used ( w/ type != 0 or -1) 
	//do not handle local ports here
	(!(portType.name.matches("0") 
		|| portType.name.matches("-1") 
		|| signal.isLocal()))  ?
			entity.port.add(port) : null ->
			
	//also add necessary relation that connect above ports with the 
	//controller
	(!(portType.name.matches("0") 
		|| portType.name.matches("-1") 
		|| signal.isLocal()))  ?
			addPortRelationAndLinks(entity, port.name) : null ->
	
	//add local ports
	(signal.isLocal()) ?
			entity.port.add(portLocalIn) : null ->
	(signal.isLocal()) ?
			entity.port.add(portLocalOut) : null ->
	(signal.isLocal()) ?
			addPortRelationAndLinks(entity, portLocalIn.name) : null ->
	(signal.isLocal()) ?
			addPortRelationAndLinks(entity, portLocalOut.name) : null ->
	
	//if still signals remain, continue
	(signalList.size > 1) ? addSignalsToModalModel(entity,
												   signalList.withoutFirst(), 
												   region) : null
;


//Helper function detecting local signals.
//If signals is not input and signal is not output => signal is local.
Boolean isLocal(Signal signal) :
 (!signal.isInput && !signal.isOutput)
;

//Add signals in signalsList to ModalController entity.
//StateSignalList contains all local signals that are defined in this state
//and that do not need to be added.
Void addSignalsToModalController(EntityType entity, EntityType parent,
								 List[Signal] signalList,
								 synccharts::Region region,
								 List[String] stateSignalNames) :
	let port = new PortType:
	let portLocalIn = new PortType:
	let portLocalOut = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p1b = new PropertyType:
	let p2b = new PropertyType:
	let p3 = new PropertyType:
	let p3a = new PropertyType:
	let p3b = new PropertyType:
	let p1c = new PropertyType:
	let p4a = new PropertyType:
	let p4b = new PropertyType:
	let p4c = new PropertyType:
	let p4d = new PropertyType:
	let portType = new PropertyType:
	let portTypeLocalIn = new PropertyType:
	let portTypeLocalOut = new PropertyType:
	let signal = signalList.first():
	let isStateSignal = (stateSignalNames != null) 
						 && (stateSignalNames.select(e|e.matches(signal.name))
						 										  .size > 0 ):
	port.setClass("ptolemy.domains.modal.modal.RefinementPort") ->
	port.setName(signal.name) ->
	portLocalIn.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalIn.setName(signal.name+"i") ->
	portLocalOut.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalOut.setName(signal.name+"o") ->
	p4a.setName("environment_input") ->
	p4b.setName("environment_output") ->
	p4c.setName("local_input") ->
	p4d.setName("local_output") ->
	p4a.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4b.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4c.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4d.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalIn.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalIn.setName("1") -> //in
	portTypeLocalOut.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalOut.setName("2") -> //out
	p1.setName("input") ->
	p2.setName("output") ->
	p1b.setName("input") ->
	p2b.setName("output") ->
	portType.setName((getPortType(signal, region)).toString()) ->
	//denote environmental and local input/output signals
	(signal.isInput) ? port.property.add(p4a) : null ->
	(signal.isOutput) ? port.property.add(p4b) : null ->
	(signal.isInput) ? port.property.add(p1) : null ->
	(signal.isOutput) ? port.property.add(p2) : null ->

	//if local signal, create in AND output port
	portLocalIn.property.add(p4c) ->
 	portLocalOut.property.add(p4d) ->	
	portLocalIn.property.add(p1b) -> //in only
	portLocalOut.property.add(p2b) ->

	p3.setName("_type") ->
	p3.setClass("ptolemy.actor.TypeAttribute") ->
	p3.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3a.setName("_type") ->
	p3a.setClass("ptolemy.actor.TypeAttribute") ->
	p3a.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3b.setName("_type") ->
	p3b.setClass("ptolemy.actor.TypeAttribute") ->
	p3b.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	port.property.add(p3) ->
	port.property.add(portType) ->
	portLocalIn.property.add(p3a) ->
	portLocalIn.property.add(portTypeLocalIn) -> //(local) input
	portLocalOut.property.add(p3b) ->
	portLocalOut.property.add(portTypeLocalOut) -> //(local) output
	
	//only add ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") 
			|| portType.name.matches("-1") 
			|| signal.isLocal())) ?
			entity.port.add(port) : null ->

	//only link ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") 
			|| portType.name.matches("-1") 
			|| signal.isLocal())) ?
			linkSignalRelationToState(entity, parent, signal.name) : null ->
	
	//add local ports 
	(signal.isLocal() && !isStateSignal) ?
			entity.port.add(portLocalIn) : null ->
	(signal.isLocal() && !isStateSignal) ?
			entity.port.add(portLocalOut) : null ->
	(signal.isLocal() && !isStateSignal) ?
			linkSignalRelationToState(entity, parent, signal.name+"i") 
			: null ->
	(signal.isLocal() && !isStateSignal) ?
			linkSignalRelationToState(entity, parent, signal.name+"o") 
			: null ->

	//if still signals remain, continue
	(signalList.size > 1) ? addSignalsToModalController(entity, parent,
													signalList.withoutFirst(),
													region,
													stateSignalNames) : null	
;


//Helperfunction connecting signals to a modalController.
linkSignalRelationToState(EntityType modalController, 
						  EntityType parent, 
						  String signalName) :
	let stateName = modalController.name:
	let l = new LinkType:
	l.setPort(stateName + "." + signalName) ->
	dump(parent.name) ->
	dump(stateName + "." + signalName) ->
	l.setRelation(signalName + "Relation") ->
	parent.link.add(l)
;


//-----------------------------------------------------------------------------
//--         C R E A T E     T R I G G E R   /   E M I S S I O N S           --
//-----------------------------------------------------------------------------

//Create guardExpression.
Void addTrigger(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	//terminated source state triggers the normal termination
	let terminatedURIHash = getStateId(transition.sourceState):
	p1.setName("guardExpression") ->
	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	//if normal termination, replace trigger by termination-trigger
	(transition.type.toString().matches("NORMALTERMINATION")) ? 
		p1.setValue(buildTrigger(transition.trigger, terminatedURIHash)) :
		p1.setValue(buildTrigger(transition.trigger, "")) ->
	relation.property.add(p1)
;


//Create outputActions.
Void addEmission(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	let terminatedURIHash = getStateId(
							transition.targetState.parentRegion.parentState):
	p1.setName("outputActions") ->
	p1.setClass("ptolemy.domains.modal.kernel.OutputActionsAttribute") ->
//	//if target state is final state, then add termination-effect
//	(transition.targetState.isFinal) ?
//		p1.setValue(buildEffect(transition.effects, terminatedURIHash)) :
		p1.setValue(buildEffect(transition.effects, "")) ->
	relation.property.add(p1) 
;
