import synccharts;
import annotations;
import kexpressions;
import utilities;
import esterel;
import ecore;

extension feature; 
extension org::eclipse::xtend::util::stdlib::cloning;

/**
 * 
 * Global Variables:
 *		* recursive : should the rules be applied recursively?
 * 		* rule1-8 : should ruleX be considered?
 * ALL these have to be provided by the calling facade!
 *
 */ 

/* 
 	Main algorithm
*/
Boolean ruleAll(List[State] states, Integer max):
	//if rule2applies(s) then rule2(s) ->
	//if rule5applies(s) then rule5(s) ->
	//if rule6applies(s) then rule6(s) 
	
	if states.size > 0 then 
	(
		let s = states.first():
		switch{
			case ((boolean) GLOBALVAR rule1) && rule1applies(s) : 
				rule1(s)
			case ((boolean) GLOBALVAR rule2) && rule2applies(s) :
				(rule2(s)  )
			case ((boolean) GLOBALVAR rule4) && rule4applies(s):
				(rule4(s))
			case ((boolean) GLOBALVAR rule5) && rule5applies(s) :
				//s.setLabel("rule5") 
				(rule5(s))	 
			case ((boolean) GLOBALVAR rule6) && rule6applies(s) :
				//s.setLabel("rule6")  
				(rule6(s, states)) 
			default :
			// clear the body references and remove state
			(s.clearBodyReferences() -> states.remove(states.first()) -> ruleAll(states, max))
		} 		
	) ->
	
	//if max < 102 then
	recursiveRule(states, max)
;

/*
Void ruleAll(List[State] states, Integer max):
	//states.remove(states.first()) ->
	if states.size > 0 then 
		rule(states, max + 1)		
;*/

/**
 * Recursive rule used to specify wheter the control flow should be passed
 * back to the java implementation or if xtend should keep on transforming
 */
Void recursiveRule(List[State] states, Integer max):
	 if ((boolean) GLOBALVAR recursive) && states.size > 0 then
		ruleAll(states, max + 1)
;


/**
	rule1 : Remove unnecessary conditional state 
		if conditional, one plain outgoing transition
*/
Boolean rule1applies(State s):
	switch {
		case isConditional(s) && isOneOutTransition(s) : 
			(isTransitionWithout(s.outgoingTransitions.get(0)) ? true : false)
		default : false
	}
;

Void rule1(State s):
	let targetState = s.outgoingTransitions.get(0).targetState:
	let incomingTrans = s.incomingTransitions.copyList():
	// bend transition to new target
	incomingTrans.setTargetState(targetState) ->
	s.outgoingTransitions.get(0).removeTransition() ->
	// remove conditional state
	s.removeStateFromRegion()
;

/*
	rule2 : Remove unnecessary plain states
		if simplestate, is not final nor initial, has only one outgoing transition
		with trigger = #tick
*/
Boolean rule2applies(State s):
	switch {
		case isSimpleState(s) && !s.isFinal && !s.isInitial &&
			isOneOutTransition(s) && isOutTransitionTick(s.outgoingTransitions.get(0)):
				true
		default : false
	}
;

Void rule2(State s):
	let incomingTrans = s.incomingTransitions.copyList():
	let outgoingTrans = s.outgoingTransitions.first():
	let effects = outgoingTrans.effects:
	// bend transitions
	incomingTrans.setTargetState(outgoingTrans.targetState) ->
	// append effects
	incomingTrans.addEffects(effects) ->

	// remove state and outgoing transition
	outgoingTrans.removeTransition() ->
	s.parentRegion.states.remove(s)
;

/*
	rule2.2 : remove unnecessary plain states where in and out have the same trigger (not immediate)
*/
// TODO



/*
	rule4: Remove simple final states if there is more than one and bend transitions
		more than 1 final simplestate
*/
Boolean rule4applies(State s):
	switch {
		case hasMultipleSimpleFinalSubStates(s) : 
			true
		default: false
	}
;

Void rule4(State s):
	let regions = (List[Region]) s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	regions.handleRule4()	
;

Void handleRule4(Region r):
	let simpleFinals = r.states.select(e|e.isSimpleState() && e.isFinal):
	let firstFinal = simpleFinals.first():
	let simpleWithoutFirst = simpleFinals.withoutFirst():
	simpleWithoutFirst.handleRule4rec(firstFinal)
;

Void handleRule4rec(State s, State to):
	let incomings = s.incomingTransitions.copyList():
	incomings.bendAndRemove(to)
;

Void bendAndRemove(Transition t, State to):
	let oldTarget = t.targetState:
	t.setTargetState(to) ->
	oldTarget.removeStateFromRegion()
;

/*
	rule5 : Remove unnecessary normal terminations
		macro state with no final states and outgoing transition
		care: do not remove loopstates
*/
Boolean rule5applies(State s):
	switch {
		case !isSimpleState(s) && hasOutNormalTransitions(s) && !hasFinalSubState(s) && !hasOnlySelfLoop(s):
				true
		default: false
	}
;

Void rule5(State s):
	let outTrans = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION
		&& (s.isInitial || e.sourceState != e.targetState)).copyList():
	outTrans.removeTransAndPossiblyState()
;

Void removeTransAndPossiblyState(Transition t):
	let target = t.targetState:
	t.removeTransition() ->
	if(target.incomingTransitions.isEmpty) then
		removeStateFromRegion(target)
;

/*
	rule6 : remove unnecessary macro states
		if no outgoing weak/strong abortions, no signals or variables, 
		is no parallel macro state, has a parent macro state 
*/
Boolean rule6applies(State s):
	switch {
		// do not remove inital loopstate 
		
		// TODO check if just test for interfaceDecls or signals and vars
		case !hasOutWeakTransitions(s) && !hasOutStrongTransitions(s) && !isSimpleState(s) &&
			!hasSignalsVariables(s) && hasParentMacroState(s) && !isParallelMacroState(s):
				true
		default: false
	}
;

Void rule6(State s, List[State] states):
	let r = s.regions.first():
	let initial = findInitialState(r):
	let finalMacros = r.states.select(e|!isSimpleState(e) && e.isFinal):
	let finalSimples = r.states.select(e|isSimpleState(e) && e.isFinal):
	let incomingTrans = s.incomingTransitions.copyList():
	let normalTerms = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	
	// do not make states without incoming transitions or only one selfloop noninitial
	if (!incomingTrans.isEmpty) then
		(if (!s.hasOnlySelfLoop()) then
			initial.setIsInitial(false)) ->
			
	// reroute all incoming transitions to the initial state
	incomingTrans.setTargetState(initial) ->
	initial.incomingTransitions.addAll(incomingTrans) ->
		
	// if normal termination exist 
	(s.outgoingTransitions.size == 1) ?
	(
	// final macros become nonfinal 
	finalMacros.setIsFinal(false) ->
	// final simples become nonfinal
	finalSimples.setIsFinal(false) ->
	
	finalSimples.createWeakAbortTo(s.outgoingTransitions.get(0).targetState) ->
	if !normalTerms.isEmpty then
		finalMacros.copyNormalTransitionFrom(normalTerms.get(0))
	)
	: s
	
	// copy whole stuff 
	->
	(let copyStates = r.states.copyList():
	s.parentRegion.states.addAll(copyStates) ->
	// add the inner states to the list, as there might be new optimization potential
	//states.addAll(copyStates)
	states.addToFrontOfList(copyStates)
	) 
	
	->
	
	
	
	
	// remove old normal termination and old state
	if (!normalTerms.isEmpty) then
		normalTerms.removeTransition() ->
	s.removeStateFromRegion()
;


/*
	Predicates
*/

Boolean isConditional(State s):
	s.type == StateType::CONDITIONAL
;

Boolean isOneOutTransition(State s):
	s.outgoingTransitions.size == 1
;

Boolean isTransitionWithout(Transition t):
	t.trigger == null && t.effects.size == 0
;

Boolean isOutTransitionTick(Transition t):
	// TODO add "tick"
	t.isImmediate && true
;

Boolean hasOnlySelfLoop(State s):
	let self = s.incomingTransitions.select(e|e.targetState == e.sourceState):
	self.size > 0 && self.size == s.outgoingTransitions.size
;

Boolean hasOutTransitions(State s):
	!s.outgoingTransitions.isEmpty
;
Boolean hasOutWeakTransitions(State s):
	let weaks = s.outgoingTransitions.select(e|e.type == TransitionType::WEAKABORT):
	weaks.size > 0
;

Boolean hasOutNormalTransitions(State s):
	let normals = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	normals.size > 0
;

Boolean hasOutStrongTransitions(State s):
	let strongs = s.outgoingTransitions.select(e|e.type == TransitionType::STRONGABORT):
	strongs.size > 0 
;

Boolean hasInterfaceDeclaration(State s):
	s// TODO s.interfaceDecls.size == 0
;

Boolean hasFinalSubState(State s):
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	!states.select(e|e.isFinal).isEmpty
;

Void collectStates(Region r, List[State] states):
	states.addAll(r.states)
;


Boolean hasMultipleSimpleFinalSubStates(State s):
	let regions = s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	!regions.isEmpty
;

Boolean hasParentMacroState(State s):
	s.parentRegion.parentState != null
;

Boolean isParallelMacroState(State s):
	s.regions.size > 1	
;

/*
	convinient methods
*/
State findInitialState(Region r):
	let initials = r.states.select(e|e.isInitial):
	if initials.isEmpty then
	 (let s = new State:
	 let sig = new Signal:
	 sig.setName("fail") ->
	 s.setLabel("here i fail") ->
	 s.signals.add(sig) ->
	 r.states.add(s) ->
	 initials.add(s) ) ->
	initials.get(0)
;

/*
	creation methods
*/
Void createWeakAbortTo(State from, State to):
	let t = new Transition:
	from.outgoingTransitions.add(t) ->
	t.setSourceState(from) ->
	t.setTargetState(to) ->
	to.incomingTransitions.add(t) ->
	
	
	t.setType(TransitionType::WEAKABORT) ->
	t.setIsImmediate(true)
	// todo t.setTrigger tick
;

Void copyNormalTransitionFrom(State from, Transition t):
	/*let newT = (Transition) clone(t):
	newT.setType(TransitionType::NORMALTERMINATION) ->
	newT.setSourceState(from) ->
	from.outgoingTransitions.add(newT)
*/

	let newT = new Transition:
	newT.setSourceState(from) ->
	newT.setType(t.type) ->
	newT.setTrigger((Expression) clone(t.trigger)) -> 
	newT.setEffects((List[Effect]) clone(t.effects)) ->
	newT.setTargetState(t.targetState) ->
	from.outgoingTransitions.add(newT) ->
	t.targetState.incomingTransitions.add(newT)
	
;

Void addEffects(Transition t, List[Effect] effects):
	// make sure to clone! as it's containment
	t.effects.addAll(clone(effects))
; 

List[Transition] copyList(List[Transition] list):
	let copy = {}:
	copy.addAll(list)
;

Void removeTransition(Transition t):
	let source = t.sourceState:
	let target = t.targetState:
	t.setTargetState(null) ->
	t.setSourceState(null) ->
	source.outgoingTransitions.remove(t) ->
	target.incomingTransitions.remove(t)
;

// remove a state from the region
Void removeStateFromRegion(State state):
	let parent = state.parentRegion:
 state.outgoingTransitions.removeAll(state.outgoingTransitions) ->
 state.incomingTransitions.removeAll(state.incomingTransitions) ->
 parent.states.remove(state)
 ->
 // todo verify
 if parent.states.isEmpty then
 	parent.parentState.regions.remove(parent)
 	
;
  
 // clears bodycontents of all child states of State s.
Void clearBodyReferences(State s):
	let states = (Set[State]) s.eAllContents.select(e| State.isInstance(e) && ((State)e).bodyReference != null):
	states.add(s) ->
	states.setBodyReference(null)
;
  
Void addToFrontOfList(List list, List list2):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.addToFrontOfList(java.util.List, java.util.List)
;

Void debug(EObject obj):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.debug(org.eclipse.emf.ecore.EObject)
;

Void debug(Region r):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.debug(org.eclipse.emf.ecore.EObject)
;

Void debug(State s):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.debug(org.eclipse.emf.ecore.EObject)
;
