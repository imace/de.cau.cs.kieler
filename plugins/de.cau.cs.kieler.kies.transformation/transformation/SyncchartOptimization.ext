import synccharts;
import annotations;
import kexpressions;
import utilities;
import esterel;
import ecore;

extension feature; 
extension org::eclipse::xtend::util::stdlib::cloning;

/**
 * 
 * Global Variables:
 *		* recursive : should the rules be applied recursively?
 * 		* rule1-8 : should ruleX be considered?
 * ALL these have to be provided by the calling facade!
 *
 */ 

/* 
 	Main algorithm
 	
 	rule 2 & 3 just need to be applied to simplestates
 	rule 7 & 8 can just be applied if the State still exists
*/
Boolean ruleAll(List[State] states):

	if states.size > 0 then 
	(
		let s = states.first():
		switch{
			case ((boolean) GLOBALVAR rule1) && rule1applies(s) : 
				rule1(s)
			case ((boolean) GLOBALVAR rule2) && s.isSimpleState() && rule2applies(s) :
				rule2(s)
			case ((boolean) GLOBALVAR rule3) && s.isSimpleState() && rule3applies(s) :
				rule3(s)
			case ((boolean) GLOBALVAR rule4) && rule4applies(s):
				rule4(s)
			case ((boolean) GLOBALVAR rule5) && rule5applies(s) : 
				rule5(s)
			case ((boolean) GLOBALVAR rule6) && rule6applies(s) :
				rule6(s, states)
			case s.parentRegion != null && ((boolean) GLOBALVAR rule7) && rule7applies(s) :
				rule7(s)
			case s.parentRegion != null && ((boolean) GLOBALVAR rule8) && rule8applies(s) :
				rule8(s)
			default :
			// this state is finished - clear the body references and remove state
			(s.clearBodyReferences() -> states.remove(states.first()) -> ruleAll(states))
		} 		
	) ->
	
	recursiveRule(states)
;

/**
 * Recursive rule used to specify wheter the control flow should be passed
 * back to the java implementation or if xtend should keep on transforming
 */
Void recursiveRule(List[State] states):
	 if ((boolean) GLOBALVAR recursive) && states.size > 0 then
		ruleAll(states)
;


/**
	rule1 : Remove unnecessary conditional state 
		if conditional, one plain outgoing transition
*/
Boolean rule1applies(State s):
	switch {
		case isConditional(s) && isOneOutTransition(s) : 
			(isTransitionWithout(s.outgoingTransitions.get(0)) ? true : false)
		default : false
	}
;

Void rule1(State s):
	let targetState = s.outgoingTransitions.get(0).targetState:
	let incomingTrans = s.incomingTransitions.copyList():
	// bend transition to new target
	incomingTrans.setTargetState(targetState) ->
	s.outgoingTransitions.get(0).removeTransition() ->
	// remove conditional state
	s.removeStateFromRegion()
;

/**
	rule2 : Remove unnecessary plain states
		if simplestate, is not final nor initial, has only one outgoing transition
		with trigger = #tick
*/
Boolean rule2applies(State s):
	switch {
		case isSimpleState(s) && !s.isFinal && !s.isInitial &&
			isOneOutTransition(s) && isOutTransitionTick(s.outgoingTransitions.get(0)):
				true
		default : false
	}
;

Void rule2(State s):
	let incomingTrans = s.incomingTransitions.copyList():
	let outgoingTrans = s.outgoingTransitions.first():
	let effects = outgoingTrans.effects:
	// bend transitions
	incomingTrans.setTargetState(outgoingTrans.targetState) ->
	// append effects
	incomingTrans.addEffects(effects) ->
	
	// if s is initial .. the new target needs to be initial
	if s.isInitial then
		outgoingTrans.targetState.setIsInitial(true) ->

	// remove state and outgoing transition
	outgoingTrans.removeTransition() ->
	s.parentRegion.states.remove(s)
;

/**
 *	rule3 : remove unnecessary plain states 
 *		if incoming and outgoing transitions have the same trigger (not immediate)
 */
Boolean rule3applies(State s):
	switch {
		case isSimpleState(s) && s.hasNumberOfIncomingTrans(1) && s.hasNumberOfOutgoingTrans(1) 
		&& s.hasOnlyMatchingTriggerTrans() : 
			 true
		default : false
	}
;

Void rule3(State s):
	let in = s.incomingTransitions.get(0):
	let out = s.outgoingTransitions.get(0):
	out.setSourceState(in.sourceState) ->
	out.setDelay(in.delay + out.delay) ->
	if s.isInitial then
		out.targetState.setIsInitial(true) ->
	removeTransition(in) ->
	s.removeStateFromRegion()
;


/**
	rule4: Remove simple final states if there is more than one and bend their transitions
		to one simple final state
*/
Boolean rule4applies(State s):
	switch {
		case hasMultipleSimpleFinalSubStates(s) : 
			true
		default: false
	}
;

Void rule4(State s):
	let regions = (List[Region]) s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	regions.handleRule4()	
;

Void handleRule4(Region r):
	let simpleFinals = r.states.select(e|e.isSimpleState() && e.isFinal):
	// keep the first one and bend transitions there
	let firstFinal = simpleFinals.first():
	let simpleWithoutFirst = simpleFinals.withoutFirst():
	simpleWithoutFirst.handleRule4rec(firstFinal)
;

Void handleRule4rec(State s, State to):
	let incomings = s.incomingTransitions.copyList():
	incomings.bendAndRemove(to)
;

Void bendAndRemove(Transition t, State to):
	let oldTarget = t.targetState:
	t.setTargetState(to) ->
	oldTarget.removeStateFromRegion()
;

/**
	rule5 : Remove unnecessary normal terminations
		macro state with no final states and outgoing transition
		care: do not remove loopstates
*/
Boolean rule5applies(State s):
	switch {
		case !isSimpleState(s) && hasOutNormalTransitions(s) && !hasFinalSubState(s) && !hasOnlySelfLoop(s):
				true
		default: false
	}
;

Void rule5(State s):
	let outTrans = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION
		&& (s.isInitial || e.sourceState != e.targetState)).copyList():
	outTrans.removeTransAndPossiblyState()
;

Void removeTransAndPossiblyState(Transition t):
	let target = t.targetState:
	t.removeTransition() ->
	if(target.incomingTransitions.isEmpty) then
		removeStateFromRegion(target)
;

/**
	rule6 : remove unnecessary macro states
		if no outgoing weak/strong abortions, no signals or variables, 
		is no parallel macro state, has a parent macro state 
*/
Boolean rule6applies(State s):
	switch {
		// TODO check if just test for interfaceDecls or signals and vars is enough
		case !hasOutWeakTransitions(s) && !hasOutStrongTransitions(s) && !isSimpleState(s) &&
			!hasSignalsVariables(s) && hasParentMacroState(s) && !isParallelMacroState(s):
				true
		default: false
	}
;

Void rule6(State s, List[State] states):
	let r = s.regions.first():
	let initial = findInitialState(r):
	let finalMacros = r.states.select(e|!isSimpleState(e) && e.isFinal):
	let finalSimples = r.states.select(e|isSimpleState(e) && e.isFinal):
	let incomingTrans = s.incomingTransitions.copyList():
	let normalTerms = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	
	// do not make states without incoming transitions or only one selfloop noninitial
	if (!incomingTrans.isEmpty) then
		(if (!s.hasOnlySelfLoop()) then
			initial.setIsInitial(false)) ->
			
	// reroute all incoming transitions to the initial state
	incomingTrans.setTargetState(initial) ->
	initial.incomingTransitions.addAll(incomingTrans) ->
		
	// if normal termination exist 
	(s.outgoingTransitions.size == 1) ?
	(
	// final macros become nonfinal 
	finalMacros.setIsFinal(false) ->
	// final simples become nonfinal
	finalSimples.setIsFinal(false) ->
	
	finalSimples.createWeakAbortTo(s.outgoingTransitions.get(0).targetState) ->
	if !normalTerms.isEmpty then
		finalMacros.copyNormalTransitionFrom(normalTerms.get(0))
	)
	: s
	
	// copy whole stuff 
	->
	(let copyStates = r.states.copyList():
	s.parentRegion.states.addAll(copyStates) ->
	// add the inner states to the list, as there might be new optimization potential
	//states.addAll(copyStates)
	states.addToFrontOfList(copyStates)
	) 
	
	->
	
	// remove old normal termination and old state
	if (!normalTerms.isEmpty) then
		normalTerms.removeTransition() ->
	s.removeStateFromRegion()
;

/**
	rule7 : remove macrostates which have only two substates
		if
*/
Boolean rule7applies(State s):
	switch {
		// TODO hasParent necessary?
		case !isSimpleState(s) && s.hasParentMacroState() && s.hasNumberOfSubStates(1):
				true
		default: false
	}
;

Void rule7(State s):
	// make sure in case of multiple regions no nullpointer is thrown
	let parentReg = s.parentRegion:
	let incomingT = s.incomingTransitions.copyList():
	let outgoingT = s.outgoingTransitions.copyList():
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	(let found = states.get(0):
	 parentReg.states.add(found) ->
	 incomingT.setTargetState(found) ->
	 outgoingT.setSourceState(found)
	) ->
	s.removeStateFromRegion()
; 

/**
	rule8 : test the final character of a macrostate
		if final, is macrostate, has no final states as children 
*/
Boolean rule8applies(State s):
	switch {
		case !isSimpleState(s) && s.isFinal && !s.hasFinalSubState():
				true
		default: false
	}
;

Void rule8(State s):
	s.setIsFinal(false)
;



/*
	Predicates
*/

Boolean isConditional(State s):
	s.type == StateType::CONDITIONAL
;

Boolean isOneOutTransition(State s):
	s.outgoingTransitions.size == 1
;

Boolean isTransitionWithout(Transition t):
	t.trigger == null && t.effects.size == 0
;

Boolean isOutTransitionTick(Transition t):
	// TODO add "tick"
	t.isImmediate && true
;

Boolean hasOnlySelfLoop(State s):
	let self = s.incomingTransitions.select(e|e.targetState == e.sourceState):
	self.size > 0 && self.size == s.outgoingTransitions.size
;

Boolean hasNumberOfSubStates(State s, Integer number):
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	states.size == number
;

Boolean hasOutTransitions(State s):
	!s.outgoingTransitions.isEmpty
;

Boolean hasNumberOfOutgoingTrans(State s, Integer n):
	s.outgoingTransitions.size == n
;

Boolean hasNumberOfIncomingTrans(State s, Integer n):
	s.incomingTransitions.size == n
;

Boolean hasOutWeakTransitions(State s):
	let weaks = s.outgoingTransitions.select(e|e.type == TransitionType::WEAKABORT):
	weaks.size > 0
;

// only use after checking for existing transitions
Boolean hasOnlyMatchingTriggerTrans(State s):
	let in = s.incomingTransitions.get(0):
	let out = s.outgoingTransitions.get(0):
	// incoming trans may not have any effect
	(in.effects.isEmpty) ?
		in.compareTrigger(out)
		:
		false	
;

Boolean hasOutNormalTransitions(State s):
	let normals = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	normals.size > 0
;

Boolean hasOutStrongTransitions(State s):
	let strongs = s.outgoingTransitions.select(e|e.type == TransitionType::STRONGABORT):
	strongs.size > 0 
;

Boolean hasInterfaceDeclaration(State s):
	s// TODO s.interfaceDecls.size == 0
;

Boolean hasFinalSubState(State s):
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	!states.select(e|e.isFinal).isEmpty
;

Void collectStates(Region r, List[State] states):
	states.addAll(r.states)
;


Boolean hasMultipleSimpleFinalSubStates(State s):
	let regions = s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	!regions.isEmpty
;

Boolean hasParentMacroState(State s):
	s.parentRegion.parentState != null
;

Boolean isParallelMacroState(State s):
	s.regions.size > 1	
;

/*
	convinient methods
*/
State findInitialState(Region r):
	let initials = r.states.select(e|e.isInitial):
	if initials.isEmpty then
	 (let s = new State:
	 let sig = new Signal:
	 sig.setName("fail") ->
	 s.setLabel("here i fail") ->
	 s.signals.add(sig) ->
	 r.states.add(s) ->
	 initials.add(s) ) ->
	initials.get(0)
;

/*
	creation methods
*/
Void createWeakAbortTo(State from, State to):
	let t = new Transition:
	from.outgoingTransitions.add(t) ->
	t.setSourceState(from) ->
	t.setTargetState(to) ->
	to.incomingTransitions.add(t) ->
	
	
	t.setType(TransitionType::WEAKABORT) ->
	t.setIsImmediate(true)
	// todo t.setTrigger tick
;

Void copyNormalTransitionFrom(State from, Transition t):
	/*let newT = (Transition) clone(t):
	newT.setType(TransitionType::NORMALTERMINATION) ->
	newT.setSourceState(from) ->
	from.outgoingTransitions.add(newT)
*/

	let newT = new Transition:
	newT.setSourceState(from) ->
	newT.setType(t.type) ->
	newT.setTrigger((Expression) clone(t.trigger)) -> 
	newT.setEffects((List[Effect]) clone(t.effects)) ->
	newT.setTargetState(t.targetState) ->
	from.outgoingTransitions.add(newT) ->
	t.targetState.incomingTransitions.add(newT)
	
;

Void addEffects(Transition t, List[Effect] effects):
	// make sure to clone! as it's containment
	t.effects.addAll(clone(effects))
; 

List[Transition] copyList(List[Transition] list):
	let copy = {}:
	copy.addAll(list)
;

Void removeTransition(Transition t):
	let source = t.sourceState:
	let target = t.targetState:
	t.setTargetState(null) ->
	t.setSourceState(null) ->
	source.outgoingTransitions.remove(t) ->
	target.incomingTransitions.remove(t)
;

// remove a state from the region
Void removeStateFromRegion(State state):
	let parent = state.parentRegion:
 	state.outgoingTransitions.removeAll(state.outgoingTransitions) ->
 	state.incomingTransitions.removeAll(state.incomingTransitions) ->
 	parent.states.remove(state)
 	->
 	// todo verify
 	if parent.states.isEmpty then
 		parent.parentState.regions.remove(parent)
 	
;
  
 // clears bodycontents of all child states of State s.
Void clearBodyReferences(State s):
	let states = (Set[State]) s.eAllContents.select(e| State.isInstance(e) && ((State)e).bodyReference != null):
	states.add(s) ->
	states.setBodyReference(null)
;
  
Void addToFrontOfList(List list, List list2):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.addToFrontOfList(java.util.List, java.util.List)
;

Void debug(EObject obj):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.debug(org.eclipse.emf.ecore.EObject)
;

Void debug(Region r):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.debug(org.eclipse.emf.ecore.EObject)
;

Void debug(State s):
	JAVA de.cau.cs.kieler.kies.transformation.util.TransformationUtil.debug(org.eclipse.emf.ecore.EObject)
;

Boolean compareTrigger(Action t1, Action t2):
	JAVA de.cau.cs.kieler.kies.transformation.util.TransformationUtil.compareTrigger(de.cau.cs.kieler.synccharts.Action, 
	de.cau.cs.kieler.synccharts.Action) 
;
