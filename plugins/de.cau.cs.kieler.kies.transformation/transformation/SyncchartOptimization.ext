import synccharts;
import annotations;
import kexpressions;
import utilities;
import esterel;
import ecore;

extension KiesUtil;
extension org::eclipse::xtend::util::stdlib::cloning;

/**
 * 
 * Global Variables:
 *		* recursive : should the rules be applied recursively?
 * 		* rule1-8 : should ruleX be considered?
 * ALL these have to be provided by the calling facade!
 *
 */ 

/* 
 	Main algorithm
 	
 	rule 2 & 3 just need to be applied to simplestates
 	rule 7 & 8 can just be applied if the State still exists
*/
Boolean ruleAll(List[State] states):

	if states.size > 0 then 
	(
		let s = states.first():
		switch{
			case ((boolean) GLOBALVAR rule1) && rule1applies(s) : 
				rule1(s)
			case ((boolean) GLOBALVAR rule2) && s.isSimpleState() && rule2applies(s) :
				rule2(s)
			case ((boolean) GLOBALVAR rule3) && s.isSimpleState() && rule3applies(s) :
				rule3(s)
			case ((boolean) GLOBALVAR rule4) && rule4applies(s):
				rule4(s)
			case ((boolean) GLOBALVAR rule5) && rule5applies(s) : 
				rule5(s)
			case ((boolean) GLOBALVAR rule6) && rule6applies(s) :
				rule6(s, states)
			case s.parentRegion != null && ((boolean) GLOBALVAR rule7) && rule7applies(s) :
				rule7(s)
			case s.parentRegion != null && ((boolean) GLOBALVAR rule8) && rule8applies(s) :
				rule8(s)
			default :
			// this state is finished - clear the body references and remove state
			(s.clearBodyReferences() -> states.remove(states.first()) -> ruleAll(states))
		} 		
	) ->
	
	recursiveRule(states)
;

/**
 * Recursive rule used to specify wheter the control flow should be passed
 * back to the java implementation or if xtend should keep on transforming
 */
Void recursiveRule(List[State] states):
	 if ((boolean) GLOBALVAR recursive) && states.size > 0 then
		ruleAll(states)
;


/** !- 
	(rule1) : Remove unnecessary conditional state 
		if conditional, one plain outgoing transition
*/
Boolean rule1applies(State s):
	switch {
		case isConditional(s) && hasNumberOfOutgoingTrans(s, 1) : 
			(isTransitionWithoutTaE(s.outgoingTransitions.get(0)) ? true : false)
		default : false
	}
;

Void rule1(State s):
	let targetState = s.outgoingTransitions.get(0).targetState:
	let incomingTrans = s.incomingTransitions.copyListTrans():
	// bend transition to new target
	incomingTrans.setTargetState(targetState) ->
	s.outgoingTransitions.get(0).removeTransition() ->
	// remove conditional state
	s.removeStateFromRegion()
;

/** !- 
	(rule2) : Remove unnecessary plain states
		if simplestate, is not final nor initial, has only one outgoing transition
		with trigger = #tick
*/
Boolean rule2applies(State s):
	switch {
		case isSimpleState(s) && !s.isFinal && !s.isInitial &&
			hasNumberOfOutgoingTrans(s, 1) && isImmediateTransition(s.outgoingTransitions.get(0)) && 
			isTransitionWithoutT(s.outgoingTransitions.get(0)):
				true
		default : false
	}
;

Void rule2(State s):
	let incomingTrans = s.incomingTransitions.copyListTrans():
	let outgoingTrans = s.outgoingTransitions.first():
	let effects = outgoingTrans.effects:
	// bend transitions
	incomingTrans.setTargetState(outgoingTrans.targetState) ->
	// append effects
	incomingTrans.addEffects(effects) ->
	
	// if s is initial .. the new target needs to be initial
	if s.isInitial then
		outgoingTrans.targetState.setIsInitial(true) ->

	// remove state and outgoing transition
	outgoingTrans.removeTransition() ->
	s.parentRegion.states.remove(s)
;

/** !- 
 *	(rule3) : remove unnecessary plain states 
 *		if incoming and outgoing transitions have the same trigger (not immediate)
 */
Boolean rule3applies(State s):
	switch {
		case isSimpleState(s) && s.hasNumberOfIncomingTrans(1) && s.hasNumberOfOutgoingTrans(1) 
		&& s.hasOnlyMatchingTriggerTrans() : 
			 true
		default : false
	}
;

Void rule3(State s):
	let in = s.incomingTransitions.get(0):
	let out = s.outgoingTransitions.get(0):
	out.setSourceState(in.sourceState) ->
	out.setDelay(in.delay + out.delay) ->
	if s.isInitial then
		out.targetState.setIsInitial(true) ->
	removeTransition(in) ->
	s.removeStateFromRegion()
;


/** !- 
	(rule4) : Remove simple final states if there is more than one and bend their transitions
		to one simple final state
*/
Boolean rule4applies(State s):
	switch {
		case hasMultipleSimpleFinalSubStates(s) : 
			true
		default: false
	}
;

Void rule4(State s):
	let regions = (List[Region]) s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	regions.handleRule4()	
;

Void handleRule4(Region r):
	let simpleFinals = r.states.select(e|e.isSimpleState() && e.isFinal):
	// keep the first one and bend transitions there
	let firstFinal = simpleFinals.first():
	let simpleWithoutFirst = simpleFinals.withoutFirst():
	simpleWithoutFirst.handleRule4rec(firstFinal)
;

Void handleRule4rec(State s, State to):
	let incomings = s.incomingTransitions.copyListTrans():
	incomings.bendAndRemove(to)
;

Void bendAndRemove(Transition t, State to):
	let oldTarget = t.targetState:
	t.setTargetState(to) ->
	oldTarget.removeStateFromRegion()
;

/** !- 
	(rule5) : Remove unnecessary normal terminations
		macro state with no final states and outgoing transition
		care: do not remove loopstates
*/
Boolean rule5applies(State s):
	switch {
		case !isSimpleState(s) && hasOutNormalTransitions(s) && !hasFinalSubState(s) && !hasOnlySelfLoop(s):
				true
		default: false
	}
;

Void rule5(State s):
	let outTrans = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION
		&& (s.isInitial || e.sourceState != e.targetState)).copyListTrans():
	outTrans.removeTransAndPossiblyState()
;

Void removeTransAndPossiblyState(Transition t):
	let target = t.targetState:
	t.removeTransition() ->
	if(target.incomingTransitions.isEmpty) then
		removeStateFromRegion(target)
;

/** !-
	(rule6) : remove unnecessary macro states
		if no outgoing weak/strong abortions, no signals or variables, 
		is no parallel macro state, has a parent macro state 
*/
Boolean rule6applies(State s):
	switch {
		// TODO check if just test for interfaceDecls or signals and vars is enough
		case !hasOutWeakTransitions(s) && !hasOutStrongTransitions(s) && !isSimpleState(s) &&
			!hasSignalsVariables(s) && hasParentMacroState(s) && !isParallelMacroState(s):
				true
		default: false
	}
;

Void rule6(State s, List[State] states):
	let r = s.regions.first():
	let initial = findInitialState(r):
	let finalMacros = r.states.select(e|!isSimpleState(e) && e.isFinal):
	let finalSimples = r.states.select(e|isSimpleState(e) && e.isFinal):
	let incomingTrans = s.incomingTransitions.copyListTrans():
	let normalTerms = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	
	// do not make states without incoming transitions or only one selfloop noninitial
	if (!incomingTrans.isEmpty) then
		(if (!s.hasOnlySelfLoop()) then
			initial.setIsInitial(false)) ->
			
	// reroute all incoming transitions to the initial state
	incomingTrans.setTargetState(initial) ->
	initial.incomingTransitions.addAll(incomingTrans) ->
		
	// if normal termination exist 
	(s.outgoingTransitions.size == 1) ?
	(
	// final macros become nonfinal 
	finalMacros.setIsFinal(false) ->
	// final simples become nonfinal
	finalSimples.setIsFinal(false) ->
	
	finalSimples.createImmediateWeakAbortTo(s.outgoingTransitions.get(0).targetState) ->
	if !normalTerms.isEmpty then
		finalMacros.copyNormalTransitionFrom(normalTerms.get(0))
	)
	: s
	
	// copy whole stuff 
	->
	(let copyStates = r.states.copyListTrans():
	s.parentRegion.states.addAll(copyStates) ->
	// add the inner states to the list, as there might be new optimization potential
	//states.addAll(copyStates)
	states.addToFrontOfList(copyStates)
	) 
	
	->
	
	// remove old normal termination and old state
	if (!normalTerms.isEmpty) then
		normalTerms.removeTransition() ->
	s.removeStateFromRegion()
;

/** !- 
	(rule7) : remove macrostates which have only two substates
*/
Boolean rule7applies(State s):
	switch {
		// TODO hasParent necessary?
		case !isSimpleState(s) && s.hasParentMacroState() && s.hasNumberOfSubStates(1):
				true
		default: false
	}
;

Void rule7(State s):
	// make sure in case of multiple regions no nullpointer is thrown
	let parentReg = s.parentRegion:
	let incomingT = s.incomingTransitions.copyListTrans():
	let outgoingT = s.outgoingTransitions.copyListTrans():
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	(let found = states.get(0):
	 parentReg.states.add(found) ->
	 incomingT.setTargetState(found) ->
	 outgoingT.setSourceState(found)
	) ->
	s.removeStateFromRegion()
; 

/** !- 
	(rule8) : test the final character of a macrostate
		if final, is macrostate, has no final states as children 
*/
Boolean rule8applies(State s):
	switch {
		case !isSimpleState(s) && s.isFinal && !s.hasFinalSubState():
				true
		default: false
	}
;

Void rule8(State s):
	s.setIsFinal(false)
;
