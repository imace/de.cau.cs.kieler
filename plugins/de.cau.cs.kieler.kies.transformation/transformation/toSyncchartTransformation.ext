import ecore;
import annotations;
import kexpressions;
import synccharts;
import utilities; 
import esterel; 

extension feature;
extension org::eclipse::xtend::util::stdlib::cloning;
 
 
/*
 * Some notes: 
 * - keep in mind to add states to their parents first, so potential transitions 
 *   generate a notification which is handled
 * - if the parent state has a label, do not overwrite it
 * - if automatic recursion is desired, use the recursiveRule()
 * - remember to pass the GLOBALVAR "recursive" to the XtendFacade
 * - add / remove bodytext!
 * - DO NOT use states.addAll{s1, s2}. this does NOT trigger the listener for unique ids!
 */
 
 
/*
 
   */ 
   
  Void sandbox(State s):
  let t = new Transition:
  let e = new Effect:
  let de = new DelayExpr:
 // ((synccharts::Action)t).setLabel("foobat") ->
  // addSelfLoop(s)->
	
s	
  ;




Void recursiveRule(State s, emf::EObject e):
	((boolean) GLOBALVAR recursive) ? rule(s, e) : s
	-> s
;
 
// just dummy for xtend 
Void rule(State s, emf::EObject noneed):
	s.setLabel("Not Supported yet: " + noneed.metaType)
;
 

// rule for Program, forwards the first module
Void rule(State s, Program p):
 	let m = ((emf::EObject) s.bodyReference):
 	let mo = (Program) castToEMF(m):	
	rule(s, mo.modules.get(0))
;

/*
 * rule 1 (module)
 */ 
Void rule(State s, Module m):
	let statement = m.body.statements.get(0):
	removeBodyText(s) ->
	// always set label here!
	s.setLabel(m.name) ->
	//s.setIsInitial(true) ->
	//s.setIsFinal(true) ->
	// TODO set singals
	if(!m.interface.intSignalDecls.isEmpty) then
		m.interface.intSignalDecls.extractSignals(s) ->	
	// TODO set body content
	setJavaBodyContents(s, statement) ->
	//appendNextTransformation(newState, statement)
	recursiveRule(s, statement)
;

/*
 * rule 2 (nothing)
 */ 
Void rule(State s, Nothing n):
	let nState = new State:
	let r = new Region:
	s.removeBodyText() ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Nothing State") ->
	r.states.add(nState) ->
	nState.setIsFinal(true) ->
	nState.setIsInitial(true)
;

/*
 * rule 3 (halt)
 */
Void rule(State s, Halt h):
	let r = new Region:
	let ns = new State:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Halt State") ->
	r.states.add(ns) ->
	ns.setIsInitial(true)
	
;
 
/*
 * rule 4 (pause)
 */
Void rule(State s, Pause p):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	// setup states
	s.removeBodyText() ->
	s.setLabelIfEmpty("Pause State") ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	// add transition
	t.setType(TransitionType::WEAKABORT) ->
	t.connectTransition(initS, finalS)
;

 /*
 * rule 5 (abort)
 */
Void rule(State s, Abort a):
	ruleAbort(s, a)
;
 
// helping rule, to allow usual aborts as well as weak aborts to be handled
Void ruleAbort(State s, Abort a):
  	let r = new Region:
 	let initState = new State:
 	let caseStates = {}:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	removeBodyText(s) ->
 	(WeakAbort.isInstance(a) ? s.setLabelIfEmpty("Weak Abort State") : s.setLabelIfEmpty("Abort State")) ->
 	// add new state
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	// connect initial and final state with of a normal termination
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	toFinalTrans.setPriority(1) ->
	initState.setIsInitial(true) ->
	finalState.setIsFinal(true) ->
	
	// just an instance or cases? 
 	(AbortInstance.isInstance(a.body) ?
	 	handleAbortCaseSingle(r, initState, 1, 
	 		((AbortInstance)a.body).delay,
	 		((AbortInstance)a.body).statement,
	 		WeakAbort.isInstance(a)) 
 	:
 		(toFinalTrans.setPriority(((AbortCase)a.body).cases.size + 1) ->
 		// handle cases (only for ABRO currently)
	 	handleAbortCases(r, initState, 1, ((AbortCase)a.body).cases, WeakAbort.isInstance(a)))
	) -> 	
	// handle abort's body statement
	toFinalTrans.connectTransition(initState, finalState) ->
	setJavaBodyContents(initState, a.statement) ->
	recursiveRule(initState, a.statement)
;
		
Void handleAbortCases(Region parent, State source, Integer prio, List[AbortCaseSingle] cases, boolean weak):
	(cases.size > 1) ?
		(handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement, weak) ->
		handleAbortCases(parent, source, prio + 1, cases.withoutFirst(), weak))
		:
		handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement, weak)
;

Void handleAbortCaseSingle(Region parent, State source, Integer prio, DelayExpr expr, Statement body, boolean weak):
	let caseState = new State:
	let trans = new Transition:
	caseState.setIsFinal(true) ->
	parent.states.add(caseState) ->
	
	// create and add transition
	if !weak then trans.setType(TransitionType::STRONGABORT) ->
	trans.setPriority(prio) ->
	
	// handle delayexpr
	trans.addDelayToTrigger(expr) ->
		
	trans.connectTransition(source, caseState) ->
	// care! the "do" body of about might be null
	if (body != null) then
		// set body text 
		(setJavaBodyContents(caseState, body)  ->
		recursiveRule(caseState, body))
;

/*
 * rule 6 (weak abort)
 */
// TODO

/*
 * rule 7 (assign)
 */
 Void rule(State s, esterel::Assignment assign):
 	let r = new Region:
 	let initS = new State:
 	let finalS = new State:
 	let t = new Transition:
 	let sa = new synccharts::Assignment:
 	s.removeBodyText() ->
 	// setup states
 	s.setLabelIfEmpty("Assign State") ->
 	s.regions.add(r) ->
 	initS.setIsInitial(true) ->
 	finalS.setIsFinal(true) ->
 	r.states.add(initS) ->
 	r.states.add(finalS) ->
 	// init transition
 	t.connectTransition(initS, finalS) ->

 	sa.setVariable(assign.var) ->
 	
 	if (assign.expr != null) then
 		(sa.setExpression(((Expression) clone(assign.expr)).convertEsterelExpression())) ->
 		
 	//add assignment to the transition
 	t.effects.add(sa)
 ;

/*
 * rule 8 (await)
 */
Void rule(State s, Await a):
 	let r = new Region :
 	let initState = new State:
 	let caseStates = {}:
	removeBodyText(s) ->
 	s.setLabelIfEmpty("Await State") ->
 	// add state
 	s.regions.add(r) ->
 	initState.setIsInitial(true) ->
 	r.states.add(initState) ->

 	// just one instance or cases?
	AwaitInstance.isInstance(a.body)?
		handleAwaitCaseSingle(r, initState, 1, 
			((AwaitInstance)a.body).delay, 
			((AwaitInstance)a.body).statement)
	:
		handleAwaitCases(r, initState, 1, ((AwaitCase)a.body).cases)
;
 
// as abort and await cases are equal, we use AbortCaseSingles 
Void handleAwaitCases(Region r, State previous, Integer prio, List[AbortCaseSingle] cases):
	handleAbortCases(r, previous, prio, cases, true)
;

Void handleAwaitCaseSingle(Region r, State previous, Integer prio, DelayExpr expr, Statement body):
	handleAbortCaseSingle(r, previous, prio, expr, body, true)
;


 /*
  * rule 10 & 11 (do upto & watching)
  */
 Void rule(State s, Do d):
 	// end is either DoUpto or DoWatching and just effects the outgoing context.
 	// hence we transform the "do" statement here and then decide
 	let r = new Region :
 	let initState = new State:
	removeBodyText(s) ->
	s.regions.add(r) ->
	r.states.add(initState) ->
	initState.setIsInitial(true) ->
 	
 	// handle end
 	((DoUpto.isInstance(d.end)) ? 
 		handleDoUpto(s, initState, r, (DoUpto) castToEMF(d.end) )
 		:
 		handleDoWatching(s, initState, r, (DoWatching) castToEMF(d.end) )
 	 ) ->
 		
 	// recursive
 	initState.setJavaBodyContents(d.statement) ->
 	initState.recursiveRule(d.statement)
 ;

 /*
  * rule 10 (doupto)
  */
Void handleDoUpto(State parent, State previous, Region parentR, DoUpto du):
	let finalS = new State:
	let t = new Transition:
	
	parent.setLabelIfEmpty("Doupto State") ->
	parentR.states.add(finalS) ->
	finalS.setIsFinal(true) ->
	
	t.setType(TransitionType::WEAKABORT) ->
	t.connectTransition(previous, finalS) ->
	t.addDelayToTrigger(du.expr)
;


 /*
  * rule 11 (do watching)
  */
Void handleDoWatching(State parent, State previous, Region parentR, DoWatching dw):
	let abortF = new State:
	let normalF = new State:
	let abortT = new Transition:
	let normalT = new Transition:
	
	// setup
	parent.setLabelIfEmpty("Dowatching State") ->
	parentR.states.add(abortF) ->
	parentR.states.add(normalF) ->
	normalF.setId("_") ->
	normalF.setIsFinal(true) ->
	abortF.setIsFinal(true) ->
	
	// transitions
	abortT.setType(TransitionType::WEAKABORT) ->
	normalT.setType(TransitionType::NORMALTERMINATION) ->
	abortT.connectTransition(previous, abortF) ->
	normalT.connectTransition(previous, normalF) ->
	
	abortT.addDelayToTrigger(dw.delay) ->
	
	// if timeout
	if (dw.end != null) then
		(abortF.setJavaBodyContents(dw.end.statement) ->
		abortF.recursiveRule(dw.end.statement) )
;


 /*
  * rule 12 (emit)
  */
Void rule(State s, Emit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Emit State") ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.signal) ->
	emission.setNewValue(convertEsterelExpression((Expression)clone(e.expr))) ->
	emitTrans.effects.add(emission) ->
	// add transition to state
	emitTrans.connectTransition(initS, finalS)
;

/*
 * rule 13 (every)
 */
Void rule(State s, EveryDo e):
	let r = new Region:
	let initS = new State:
	let everyS = new State:
	let initT = new Transition:
	let everyT = new Transition:
	s.removeBodyText() ->
	// setup states
	s.setLabelIfEmpty("Every State") ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(everyS) ->
	initS.setIsInitial(true) ->
	// init transitions
	initT.setType(TransitionType::WEAKABORT) ->
	everyT.setType(TransitionType::WEAKABORT) ->
	initT.connectTransition(initS, everyS) ->
	everyT.connectTransition(everyS, everyS) ->
	// add delays
	initT.addDelayToTrigger(e.delay) ->
	everyT.addDelayToTrigger(e.delay) ->
	// recursive
	everyS.setJavaBodyContents(e.statement) ->
	everyS.recursiveRule(e.statement)
;

/*
 * rule 14 (if)
 */
Void rule(State s, IfTest ift):
	let r = new Region:
	let initS = new State:
	// priority for possible else case
	let maxprio = 2 + ift.elsif.size:
	s.removeBodyText() ->
	s.setLabelIfEmpty("If State") ->

	s.regions.add(r) ->
	r.states.add(initS) ->
	initS.setIsInitial(true) ->

	// first if
	handleIfSingle(r, initS, 1, ift.expr, (ift.thenPart != null) ? ift.thenPart.statement : null) ->
	
	// possible else ifs
	if (!ift.elsif.isEmpty) then
		handleElseIfParts(r, initS, 2, ift.elsif) ->
	
	// possible else
	if (ift.elsePart != null) then
		handleIfSingle(r, initS, maxprio, null, ift.elsePart.statement)
	
;

Void handleElseIfParts(Region parent, State previous, Integer prio, List[ElsIf] elses):
	handleIfSingle(parent, previous, prio, elses.first().expr, 
		(elses.first().thenPart != null) ? elses.first().thenPart.statement : null) ->
	if(elses.size > 1) then
		handleElseIfParts(parent, previous, prio+1, elses.withoutFirst())
;

Void handleIfSingle(Region parent, State previous, Integer prio, Expression e, Statement s):
	let ifS = new State:
	let ifT = new Transition:
	parent.states.add(ifS) ->
	ifS.setIsFinal(true) ->
	
	// setup transition
	if (e != null) then
	( castToEcore(e) ->
		ifT.setTrigger(convertEsterelExpression((Expression) clone(e)))) ->
	ifT.connectTransition(previous, ifS) ->
	ifT.setPriority(prio) ->
	
	// if thenpart, recursive
	if (s != null) then
		(ifS.setJavaBodyContents(s) ->
		ifS.recursiveRule(s)) ->
		
	// create artificial nothing
	if (s == null) then 
		(let n = new Nothing:
		rule(ifS, n))
;


/*
 * rule 15 (localsignal)
 */
Void rule(State s, LocalSignalDecl ls):
	let r = new Region:
	let sigS = new State:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Localsignal State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(sigS) ->
	sigS.setIsInitial(true) ->
	sigS.setIsFinal(true) ->
	
	ls.signalList.extractLocalSignals(s) ->
	
	// recursive
	sigS.setJavaBodyContents(ls.statement) ->
	sigS.recursiveRule(ls.statement)
;


/*
 * rule 16 (localvariable)
 */
Void rule(State s, LocalVariable v):
	let r = new Region:
	let varS = new State:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Localvariable State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(varS) ->
	varS.setIsInitial(true) ->
	varS.setIsFinal(true) ->
	
	// add variables to state
	v.var.varDecls.extractLocalVariables(s) ->
	
	// recursive
	varS.setJavaBodyContents( v.statement) ->
	varS.recursiveRule(v.statement)
;


/*
 * rule 17 (loop) & rule 18 (loop each)
 */
Void rule(State s, Loop l):
	let r = new Region:
	let loopState = new State:
 	let selfTrans = new Transition:
 	removeBodyText(s) ->
 	// setup state
	(LoopEach.isInstance(l.end) ? s.setLabelIfEmpty("LoopEach State") 
			: s.setLabelIfEmpty("Loop_State")) ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	// setup transition
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.connectTransition(loopState, loopState) ->
 	
 	if LoopEach.isInstance(l.end) then
 		(selfTrans.setType(TransitionType::STRONGABORT) ->
 		 s) -> selfTrans.addDelayToTrigger(((LoopDelay)l.end).delay) ->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
	recursiveRule(loopState, l.body.statement)
 ;
 

 /* 
  * rule 19 (parallel)
  */
Void rule(State s, Parallel p):
	removeBodyText(s) ->
	s.setLabelIfEmpty("Parallel State") -> 
	
	// important to copy the list here! otherwise esterel resource gets destroyed
 	ruleParallelRecursive(s, p.list.copyList())
;

Void ruleParallelRecursive(State parent, List[Statement] statements):
	// if inner parallel, extract the statements
	(Parallel.isInstance(statements.first()) ? 
		(
		statements.addAll(((Parallel)statements.first()).list) ->
		statements.remove(statements.first()) ->
		ruleParallelRecursive(parent, statements)
		)
	: 
		// else create this state and add it to the parallel region
		(
		let r = new Region:
		let s = new State:
		parent.regions.add(r) ->
		r.states.add(s) ->
		// add this to parallel
		s.setIsFinal(true) ->
		s.setIsInitial(true) ->
		
		if(statements.size > 1) then
			ruleParallelRecursive(parent, statements.withoutFirst()) ->
		
		setJavaBodyContents(s, statements.first()) ->
		recursiveRule(s, statements.first())
		)
	)	
;

 /* 
  * rule 20 (present)
  */
Void rule(State s, Present p):
	let r = new Region:
	let pS = new State:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Present State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(pS) ->
	pS.setIsInitial(true) ->
	
	(PresentEventBody.isInstance(p.body) ? 
		// handle present ... then ... form
		(let event = ((PresentEventBody)p.body).event.expression:
		let thenPart = ((PresentEventBody)p.body).thenPart:  
		handleIfSingle(r, pS, 1, event, thenPart != null ? thenPart.statement : null) 
		)
		:
		// handle present cases
		handlePresentCases(r, pS, 1, ((PresentCaseList)p.body).cases)
	) ->
	
	if p.elsePart != null then
		// TODO change 50! calculate the correct maximal priority
		handleIfSingle(r, pS, 50, null, p.elsePart.statement)
;

Void handlePresentCases(Region parent, State previous, Integer prio, List[PresentCase] cases):
	(cases.size > 1) ?
		(handlePresentCaseSingle(parent, previous, prio, cases.first().event.expression, cases.first().statement) ->
		handlePresentCases(parent, previous, prio, cases.withoutFirst()))
		:
		(handlePresentCaseSingle(parent, previous, prio, cases.first().event.expression, cases.first().statement)
	)
;

// TODO check if this is redundant to if single
Void handlePresentCaseSingle(Region parent, State previous, Integer prio, Expression e, Statement st):
	let newS = new State:
	let t = new Transition:
	// setup
	parent.states.add(newS) ->
	t.setPriority(prio) ->
	t.setTrigger(convertEsterelExpression((Expression) clone(e))) ->
	
	t.connectTransition(previous, newS) ->
	
	// recursive
	newS.setJavaBodyContents(st) ->
	newS.recursiveRule(st)
;


/*
 * rule 22 (call)
 */
Void rule(State s, ProcCall c):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	let textEffect = new TextEffect:
	// setup
	s.removeBodyText() ->
	s.setLabelIfEmpty("Call State") ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	t.connectTransition(initS, finalS) ->
	
	// create call statement
	textEffect.setCode(c.createCallStatement()) ->
	t.effects.add(textEffect) 
	
;

String createCallStatement(ProcCall c):
	let s = new String:
	"call " + c.proc.name + "(todo" + ")" + "(todo" + ")"   
;


/*
 * rule 23 (sequence)
 */
 Void rule(State s, Sequence seq):
 	let r = new Region:
 	let initial = new State:
 	let list = (List[Statement]){}:
 	s.removeBodyText() ->
 	// create initial state
	s.setLabelIfEmpty("Sequence State") ->
	s.regions.add(r) ->
	initial.setIsInitial(true) ->
	r.states.add(initial) ->
	
	// as the grammar generates nested sequences, we flatten it first
	// this is important to conserve order!
	seq.flattenSequence(list) ->
	
	// call recursively
	ruleSequenceRecursive(r, initial, list.withoutFirst()) ->
	 
	// process body of first sequence state
	setJavaBodyContents(initial, list.first()) ->
	recursiveRule(initial, list.first())
	
;

Void flattenSequence(Statement s, List list):
	Sequence.isInstance(s) ? (
		(Sequence)s).list.flattenSequence(list) 
		:
		(list.add(s))
;

Void ruleSequenceRecursive(Region region, State previous, List[Statement] statements):
	let s = new State:
	let t = new Transition:
	// create the new state and add to the sequence chain
	region.states.add(s) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	t.connectTransition(previous, s) ->
		
	(((statements.size > 1) ? 
	// if more than 1 element we have to handle another one
	ruleSequenceRecursive(region, s, statements.withoutFirst())  
	: 
	// else finished and the last one is a final state!
	s.setIsFinal(true)))
	
	->
	setJavaBodyContents(s, statements.first()) ->
	recursiveRule(s, statements.first())
;


/*
 * rule 24 (suspend)
 */
Void rule(State s, Suspend sus):
	let r = new Region:
	let susState = new State:
	let act = new Action:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Suspend State") ->
	s.regions.add(r) ->
	r.states.add(susState) ->
	
	// setup
	susState.setIsInitial(true) ->
	susState.setIsFinal(true) ->
	// add suspension
	act.addDelayToTrigger(sus.delay) ->
	susState.setSuspensionTrigger(act) ->
	
	// recursive
	susState.setJavaBodyContents(sus.statement) ->
	susState.recursiveRule(sus.statement)
	
;

/*
 * rule 25 (sustain)
 */
Void rule(State s, Sustain sus):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let initT = new Transition:
	let sustT = new Transition:
	let emission = new Emission:
	
	s.removeBodyText() ->
	s.setLabelIfEmpty("Sustain State") ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	
	// setup transitions
	initT.connectTransition(initS, finalS) ->
	sustT.connectTransition(finalS, finalS) ->
	emission.setSignal(sus.signal) ->
	emission.setNewValue(convertEsterelExpression((Expression) clone(sus.dataExpr))) ->
	initT.effects.add(emission) ->
	sustT.effects.add((Emission) clone(emission))
;


 /* 
  * rule 26 (trap)
  */
Void rule(State s, Trap t):
	let r = new Region: 
	let trapS = new State:
	let finalS = new State:
	let normalT = new Transition:
	let haltS = new State:
	let haltT = new Transition:
	let haltSig = new Signal:
	
	s.removeBodyText() ->
	s.setLabelIfEmpty("Trap State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(trapS) ->
	r.states.add(finalS) ->
	r.states.add(haltS) ->
	
	// normal termination
	finalS.setIsFinal(true) ->
	normalT.setType(TransitionType::NORMALTERMINATION) ->
	normalT.setPriority(3) ->
	normalT.connectTransition(trapS, finalS) ->
	
	// halt due to higher trap
	trapS.setIsInitial(true) ->
	// new signal to halt execution if higher trap fires
	haltSig.setName("traphalt") ->
	haltSig.addSignalToState(s) ->
	haltT.connectTransition(trapS, haltS) ->
	// immediate transition with traphalt signal
	haltT.setIsImmediate(true) ->
	haltT.setPriority(1) ->
	(let vo = new ValuedObjectReference:
	vo.setValuedObject(haltSig) ->
	haltT.setTrigger(vo)) ->
	
	// setup exit state
	(let handleState = new State:
	 let handleExpr = new OperatorExpression:
	 let handleT = new Transition:
	 // setup state
	 handleState.setLabel("Trap Handler State") ->
	 handleState.setIsFinal(true) ->
	 r.states.add(handleState) ->
	 // transition
	 handleExpr.setOperator(OperatorType::OR) ->
	 handleT.setIsImmediate(true) ->
	 handleT.setPriority(2) ->
	 handleT.connectTransition(trapS, handleState) ->
	 // collect traps 
	 t.trapDeclList.collectTraps(handleExpr) ->
	 handleT.setTrigger(handleExpr) ->
	 // create handler if existing
	 if !t.trapHandler.isEmpty then
	 	handleTrapHandler(handleState, t.trapHandler)
	) ->


	trapS.setJavaBodyContents(t.statement) ->
	trapS.recursiveRule(t.statement)
;

Void handleTrapHandler(State handleState, List[TrapHandler] handler):
	handleTrapHandlerSingle(handleState, handler.first()) ->
	if(handler.size > 1) then
		handleTrapHandler(handleState, handler.withoutFirst())
;

Void handleTrapHandlerSingle(State handleState, TrapHandler handler):
	let r = new Region:
	let initS = new State:
	let macroS = new State:
	let macroT = new Transition:
	let finalS = new State:
	let finalT = new Transition:
	handleState.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(macroS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	
	// finalState setup
	finalS.setIsFinal(true) ->
	finalT.setIsImmediate(true) ->
	finalT.setPriority(2) ->
	finalT.connectTransition(initS, finalS) ->
	
	// macroState setup
	macroS.setIsFinal(true) ->
	macroT.setIsImmediate(true) ->
	macroT.setPriority(1) ->
	macroT.connectTransition(initS, macroS) ->
	macroT.setTrigger(convertEsterelExpression((Expression) clone(handler.trapExpr))) ->
	
	// recursive
	macroS.setJavaBodyContents(handler.statement) ->
	macroS.recursiveRule(handler.statement) 
;


 /* 
  * rule 27 (exit)
  * TODO: add traphalts of possible parent traps
  */
Void rule(State s, Exit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Exit State") ->
	initS.setIsInitial(true) ->
	
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.trap) ->
	emission.setNewValue(convertEsterelExpression((Expression)clone(e.dataExpr))) ->
	emitTrans.effects.add(emission) ->
	// add transition to state
	emitTrans.connectTransition(initS, finalS)
;

 /* 
  * rule 28 (weak abort)
  * 
  */
Void rule(State s, WeakAbort wa):
	ruleAbort(s, wa)
;


/*
	omit the block, theres a parallel in it!
*/
Void rule(State s, Block b):
	rule(s, (Parallel) b.statement)
;


 /*
  * #################################################################################
  * 
  * Convenient methods
  * 
  */


// extracts the expression and immediate information of a esterel::DelayExpr
// and adds them to the synccharts::Transition
Void addDelayToTrigger(Action t, DelayExpr delay):
	if delay.isImmediate then t.setIsImmediate(true) ->
	// clone the expression as in should stay in esterel model too
	t.setTrigger((Expression)clone(delay.event.expr)) ->
	if delay.expr != null then
		t -> // TODO not yet supported, as synccharts do not offer a delay expression! 
	t		
;

// extracts all signals from InterfaceSignalDecl and adds them to the state
Void extractSignals(InterfaceSignalDecl decl, State s):
	let clonedDecl = (InterfaceSignalDecl) clone(decl):
	let copy = (List[Signal]) copyList(clonedDecl.signals):
	switch {
		case Input.isInstance(decl) : (copy.setIsInput(true) ->  copy.setIsOutput(false))
		case Output.isInstance(decl) : (copy.setIsInput(false) ->  copy.setIsOutput(true))
		case InputOutput.isInstance(decl) : (copy.setIsInput(true) ->  copy.setIsOutput(true))
   		default : decl //no information about input/output
	} ->
	if clonedDecl.signals.size > 0 then
		copy.addSignalToState(s)
;

// extract all variables 
Void extractLocalVariables(VariableDecl decl, State s):
	let vars = (List[IVariable]) clone(decl.variables):
	vars.addVariableToState(s)
; 

Void addVariableToState(kexpressions::Variable v, State s):
	s.variables.add(v)
;

// extracts all local signals
Void extractLocalSignals(LocalSignalList lsl, State s):
	if LocalSignal.isInstance(lsl) then
		(let copy = (List[ISignal]) clone(((LocalSignal)lsl).signal):
		copy.addSignalToState(s)
		)
;

// adds sig to the state, does some processing
Void addSignalToState(Signal sig, State st):
	st.signals.add(sig)
;

// connects a transition to the two passed states
Void connectTransition(Transition t, State source, State target):
	t.setSourceState(source) ->
	t.setTargetState(target) ->
	source.outgoingTransitions.add(t)
;

// removes ALL !! body text, set state type to NORMAL
Void removeBodyText(State s):
 	s.bodyText.removeAll(s.bodyText) ->
 	s.setBodyReference(null) ->
 	s.setType(StateType::NORMAL)
;

// only set the label if there's no previous label
Void setLabelIfEmpty(State s, String label):
	(s.label == null || s.label.trim().length == 0) ? 
		s.setLabel(label) : s
;

// collect all traps in an "or" expression
Void collectTraps(TrapDeclList traps, OperatorExpression expr):
 	traps.trapDecls.addTrapToExpression(expr)
;
// as trap just extends ISignal .. TrapDecl is unknown here
Void addTrapToExpression(ISignal trap, OperatorExpression expr):
	let ref = new ValuedObjectReference:
	ref.setValuedObject(trap) ->
	expr.subExpressions.add(ref)
;

/*
 * esterel provides additional expression constructs which need to be converted 
 * into a synccharts adequate form.
 * These are: - FunctionExpression (replaced by hostcode)
 *			  - TrapExpression (replaced by hostcode)
 * 			  - ConstantExpression (replaced by corresponding primitive type) (TODO)
 * 
 */
Expression convertEsterelExpression(Expression e):
	if e != null then 
		 convertEsterelExpressionRec(e) ->
	e
;
Expression convertEsterelExpressionRec(Expression e):
	let funcs = (Set[FunctionExpression]) e.eAllContents.select(e|FunctionExpression.isInstance(e)):
	let traps = (Set[TrapExpression]) e.eAllContents.select(e|TrapExpression.isInstance(e)):
	funcs.replaceWithCorrespondingExpression() ->
	traps.replaceWithCorrespondingExpression() ->
	e
;

Void replaceWithCorrespondingExpression(Expression e):
	let parent = (ComplexExpression) e.eContainer:
	parent.subExpressions.add(e.convertEsterelExpression()) ->
	parent.subExpressions.remove(e)
;

Expression convertEsterelExpressionRec(FunctionExpression fe):
	let textExpr = new TextExpression:
	textExpr.setCode(fe.funcion.name + "(todo" + ")") ->
	textExpr
;

Expression convertEsterelExpressionRec(TrapExpression te):
	let textExpr = new TextExpression:
	textExpr.setCode(te.trap.name + "(todo" + ")") ->
	textExpr
;


List copyList(List list):
	let copy = {}:
	copy.addAll(list)
;


 
emf::EObject castToEMF(emf::EObject o):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

ecore::EObject castToEcore(emf::EObject o):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

Void setJavaBodyContents(State s, emf::EObject o):
	JAVA  de.cau.cs.kieler.kies.transformation.util.TransformationUtil.setBodyReference(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;
