/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 *
 * Copyright 2009 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 *
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.sim.kiem.automated.views;

import java.util.LinkedList;
import java.util.List;

import de.cau.cs.kieler.sim.kiem.automated.views.ExecutionFilePanel.PanelData;

/**
 * The builder for converting the table to a Latex table. The table has a
 * multi-row, multi-column format.
 * 
 * @author soh
 * @kieler.rating 2010-02-09 proposed yellow
 */
public class LatexTableExporter extends AbstractTableExporter {

    /**
     * {@inheritDoc}
     */
    @Override
    public String exportData(final PanelData data) {
        // get basic data from panel
        String[][] tableData = data.getData();
        String[] headers = data.getHeaders();

        // get data for multi column headers
        List<List<String[]>> multiHeaders = getMultiHeaders(headers);
        String[] topHeaders = multiHeaders.get(0).get(0);
        List<String[]> bottomHeaders = multiHeaders.get(1);

        // create comment
        StringBuilder builder = new StringBuilder();
        builder.append("% generated by KIEM" + NEWLINE);
        builder.append("% required packages:" + NEWLINE);
        builder.append("% \\usepackage{multicol}" + NEWLINE);
        builder.append("% \\usepackage{multirow}" + NEWLINE);
        builder.append("\\begin{table}" + NEWLINE);

        // create basic table headers
        builder.append("\\begin{tabular}{| ");
        for (int i = 0; i < headers.length; i++) {
            builder.append("l | ");
        }
        builder.append("} \\hline" + NEWLINE);

        // create multi column information
        for (int i = 0; i < topHeaders.length; i++) {
            builder.append("\\multicolumn{" + bottomHeaders.get(i).length);
            builder.append("}{" + (i == 0 ? "|" : "") + "c|");
            builder.append("}{" + topHeaders[i] + "}" + NEWLINE);
            if (i != topHeaders.length - 1) {
                builder.append(" & ");
            }
        }
        builder.append("\\\\ \\hline" + NEWLINE);

        // add headers to table
        for (int i = 0; i < bottomHeaders.size(); i++) {
            String[] array = bottomHeaders.get(i);
            for (int j = 0; j < array.length; j++) {
                builder.append(array[j]);
                if (j != array.length - 1 || i != bottomHeaders.size() - 1) {
                    builder.append(" & ");
                }
            }
        }
        builder.append(" \\\\ \\hline" + NEWLINE);

        builder.append(buildTable(tableData));
        builder.append("\\end{tabular}" + NEWLINE);
        builder.append("\\end{table}" + NEWLINE);

        return builder.toString();
    }

    /**
     * Extract the two layers of headers.
     * 
     * @param headers
     *            the input headers
     * @return the list of headers, 0 is the top headers, 1 the bottom headers
     */
    private List<List<String[]>> getMultiHeaders(final String[] headers) {
        List<String> topHeaders = new LinkedList<String>();
        List<String[]> bottomHeaders = new LinkedList<String[]>();

        String currentPrefix = "";
        topHeaders.add("");
        List<String> currentBottomHeaders = new LinkedList<String>();
        for (String s : headers) {
            // split at the component split character
            String[] array = s.split(":");
            if (array.length == 1) {
                // the top level results that have no component
                currentBottomHeaders.add(s);
            } else {
                if (!currentPrefix.equals(array[0])) {
                    // found a new component
                    bottomHeaders.add(currentBottomHeaders
                            .toArray(new String[currentBottomHeaders.size()]));
                    currentBottomHeaders = new LinkedList<String>();
                    currentPrefix = array[0];
                    topHeaders.add(currentPrefix);
                }
                // add to the results of the same component
                currentBottomHeaders.add(array[1]);
            }
        }
        bottomHeaders.add(currentBottomHeaders
                .toArray(new String[currentBottomHeaders.size()]));

        // convert lists to the desired format
        String[] topHeaderArray = topHeaders.toArray(new String[topHeaders
                .size()]);
        List<String[]> topHeaderList = new LinkedList<String[]>();
        topHeaderList.add(topHeaderArray);

        // create the resulting list
        List<List<String[]>> result = new LinkedList<List<String[]>>();
        result.add(topHeaderList);
        result.add(bottomHeaders);

        return result;
    }

    /**
     * Convert one row into a formatted string.
     * 
     * @param row
     *            the row to convert
     * @return the formatted string
     */
    private String buildRow(final String[] row) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < row.length; i++) {
            builder.append(row[i]);
            if (i != row.length - 1) {
                builder.append(" & ");
            }
        }
        builder.append(" \\\\ \\hline" + NEWLINE);
        return builder.toString();
    }

    /**
     * Convert a table into a formatted string.
     * 
     * @param table
     *            the table to convert
     * @return the formatted string
     */
    private String buildTable(final String[][] table) {
        StringBuilder builder = new StringBuilder();

        String currentHead = table[0][0];
        List<String[]> group = new LinkedList<String[]>();
        group.add(table[0]);
        int i = 1;

        while (i < table.length) {
            group = new LinkedList<String[]>();
            while (i < table.length && table[i][0].equals(currentHead)) {
                // same model file, add to multi row group
                group.add(table[i]);
                i++;
            }
            if (group.size() > 1) {
                builder.append(buildMultiRow(group));
            } else {
                // only one model file used
                builder.append(buildRow(group.get(0)));
            }
            if (i < table.length) {
                currentHead = table[i][0];
            }
        }
        return builder.toString();
    }

    /**
     * Convert a list of rows to a multi row.
     * 
     * @param group
     *            the list of rows
     * @return the converted string
     */
    private String buildMultiRow(final List<String[]> group) {
        StringBuilder builder = new StringBuilder();
        builder.append("\\multirow{" + group.size() + "}{*}{");
        builder.append(group.get(0)[0] + "}");
        for (String[] array : group) {
            for (int i = 1; i < array.length; i++) {
                builder.append(" & " + array[i]);
            }
            builder.append(" \\\\ " + NEWLINE);
        }
        builder.append("\\hline" + NEWLINE);
        return builder.toString();
    }

}
