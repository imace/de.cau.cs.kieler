/*
 * generated by Xtext
 */
package de.cau.cs.kieler.synccharts.dsl.outline;

import java.util.List;

import org.eclipse.xtext.ui.common.editor.outline.ContentOutlineNode;
import org.eclipse.xtext.ui.common.editor.outline.transformer.AbstractDeclarativeSemanticModelTransformer;

import de.cau.cs.kieler.synccharts.Action;
import de.cau.cs.kieler.synccharts.Signal;
import de.cau.cs.kieler.synccharts.State;
import de.cau.cs.kieler.synccharts.Transition;

/**
 * customization of the default outline structure
 * 
 */
public class KitsTransformer extends
		AbstractDeclarativeSemanticModelTransformer {
	/**
	 * @modified oba
	 */
	// private Provider<ContentOutlineNode> contentOutlineNodeprovider =
	// getOutlineNodeProvider();
	List<ContentOutlineNode> myContentOutlineNodes;

	// private ILocationInFileProvider locationProvider;

	/**
	 * This method will be called by naming convention: - method name must be
	 * createNode - first param: subclass of EObject - second param:
	 * ContentOutlineNode
	 * 
	 */
	public ContentOutlineNode createNode(State semanticState,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(semanticState,
				parentNode);
		String myStateType = null;
		String myStateName = null;
		String myStateLabel = null;
		String nodeLabel = "";

		/**
		 * init myState "myStateLabel" --> init myState:"myStateLabel"
		 */
		if (semanticState.getType() != null
				&& semanticState.getType().getName() != "NORMAL") {
			myStateType = semanticState.getType().getName();
			nodeLabel = myStateType + " state";
		}
		if (semanticState.getLabel() != null
				&& !(semanticState.getLabel().trim().equals(""))) {
			myStateName = semanticState.getLabel();
			nodeLabel = nodeLabel + myStateName;
		} else {
			myStateName = "<no label>";
			nodeLabel = nodeLabel + myStateName;
			// if no label, note to it and add the corresponding id
			if (semanticState.getId() != null
					&& !(semanticState.getId().trim().equals(""))) {
				myStateLabel = semanticState.getId();
				nodeLabel = nodeLabel + " : \" " + myStateLabel + "\"";
			}
		}
		if (nodeLabel.trim().equals("")) {
			node.setLabel("anonymous state"); // congrats to the user
		}
		node.setLabel(nodeLabel);
		return node;
	}

	public ContentOutlineNode createNode(Action semanticAction,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(semanticAction,
				parentNode);

		String actionKeyword = "";
		// onexit "anExitAction" --> onExit : anExitAction
		if (semanticAction.eContainingFeature().getName() == "entryActions") {
			actionKeyword = "on entry";
			if (semanticAction.getTriggersAndEffects() != null) {
				actionKeyword = actionKeyword + " : "
						+ semanticAction.getTriggersAndEffects();
			}
		}
		if (semanticAction.eContainingFeature().getName() == "exitActions") {
			actionKeyword = "on exit";
			if (semanticAction.getTriggersAndEffects() != null) {
				actionKeyword = actionKeyword + " : "
						+ semanticAction.getTriggersAndEffects();
			}
		}
		if (semanticAction.eContainingFeature().getName() == "innerActions") {
			actionKeyword = "inner action";
			if (semanticAction.getTriggersAndEffects() != null) {
				actionKeyword = actionKeyword + " : "
						+ semanticAction.getTriggersAndEffects();
			}
		}
		if (semanticAction.eContainingFeature().getName() == "suspensionTrigger") {
			actionKeyword = "suspended";
			if (semanticAction.getTriggersAndEffects() != null) {
				actionKeyword = actionKeyword + " when "
						+ semanticAction.getTriggersAndEffects();
			}
		}
		if (semanticAction.isIsImmediate()) {
			actionKeyword = "# " + actionKeyword;
		}
		node.setLabel(actionKeyword);
		return node;
	}

	public ContentOutlineNode createNode(Transition semanticTransition,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(semanticTransition,
				parentNode);

		/**
		 * Example: A --> B; note: each transition has a type
		 */
		String transitionLabel = semanticTransition.getType().toString();

		/**
		 * from A
		 */
		if (semanticTransition.getSourceState() != null) {
			State semanticSource = semanticTransition.getSourceState();
			if (semanticSource.getLabel() != null
					&& !(semanticSource.getLabel().trim().equals("")))

			{
				transitionLabel = transitionLabel + " from "
						+ semanticTransition.getSourceState().getLabel();
			}
		}
		/**
		 * from A to B
		 */
		if (semanticTransition.getTargetState() != null) {
			State semanticTarget = semanticTransition.getTargetState();
			if (semanticTarget.getLabel() != null
					&& !(semanticTarget.getLabel().trim().equals(""))) {
				{
					transitionLabel = transitionLabel + " to "
							+ semanticTransition.getTargetState().getLabel();
					node.setLabel(transitionLabel);
				}
				return node;
			}
			if (semanticTarget.getId() != null
					&& !(semanticTarget.getId().trim().equals(""))) {
				transitionLabel = transitionLabel + " to "
						+ semanticTransition.getTargetState().getId();
				node.setLabel(transitionLabel);
			}
			return node;

		}
		node.setLabel(transitionLabel);
		return node;
	}

	public ContentOutlineNode createNode(Signal semanticSignal,
			ContentOutlineNode parentNode) {
		ContentOutlineNode node = super.newOutlineNode(semanticSignal,
				parentNode);

		String signalLabel = "";
		if (semanticSignal.isIsInput()) {
			signalLabel = "input " + semanticSignal.getName();
		}
		if (semanticSignal.isIsOutput()) {
			signalLabel = "output " + semanticSignal.getName();
		}
		// if (semanticSignal.isIsInputOutput()) {
		// signalLabel = "input output " + semanticSignal.getName();
		// }
		node.setLabel(signalLabel);
		return node;
	}

	/**
	 * This method will be called by naming convention: - method name must be
	 * getChildren - first param: subclass of EObject
	 */
	// public List<EObject> getChildren(State s) {
	// return s.eContents();
	// }
}
