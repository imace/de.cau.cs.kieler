«REM»
	A misc template file.
«ENDREM»

«IMPORT s»
«IMPORT expressions»

«EXTENSION templates::Extensions»


«REM»
	Consider complex expression 
«ENDREM»
«DEFINE expandedExpression FOR OperatorExpression-»
	«IF this.operator == OperatorType::EQ-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " == "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::LT-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " < "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::LEQ-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " <= "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::GT-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " > "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::GEQ-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " >= "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::NOT-»
		(!(«EXPAND expandedExpression FOR this.subExpressions.first()-»))
	«ENDIF-»
	«IF this.operator == OperatorType::VAL-»
		(VAL(«EXPAND expandedExpression FOR this.subExpressions.first()-»))
	«ENDIF-»
	«IF this.operator == OperatorType::PRE-»
		(PRE(«EXPAND expandedExpression FOR this.subExpressions.first()-»))
	«ENDIF-»
	«IF this.operator == OperatorType::NE-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " != "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::AND-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " && "-»
			«EXPAND expandedExpression FOR subExpression-»
		 «ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::OR-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " || "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::ADD-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " + "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::SUB-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " - "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::MULT-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " * "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::DIV-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " / "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
	«IF this.operator == OperatorType::MOD-»
		(«FOREACH  this.subExpressions AS subExpression SEPARATOR " % "-»
			«EXPAND expandedExpression FOR subExpression-»
		«ENDFOREACH-»)
	«ENDIF-»
«ENDDEFINE»
«DEFINE expandedExpression FOR SignalReference-»PRESENT(«this.signal.name-»)«ENDDEFINE»
«DEFINE expandedExpression FOR Expression-»
«ENDDEFINE»

«REM»
	Definition of the signaltype including all signals of the SyncChart.
	The list is a list of signals. 
«ENDREM»
«DEFINE generateSigType FOR List-»
	«IF !this.isEmpty-»
		typedef enum {
			«FOREACH this AS signal SEPARATOR ", "-»
				sig_«((Signal)signal).name-»
			«ENDFOREACH-»
		} signaltype;
	«ENDIF-»
«ENDDEFINE»

«REM»
	Definition of the signal array including all signals of the SyncChart.
	The list is a list of signals. 
«ENDREM»
«DEFINE generateSigArray FOR List-»
	const char *s2signame[] = {
		«FOREACH this AS signal SEPARATOR ", "-»
		"sig_«((Signal)signal).name-»"
		«ENDFOREACH-»
	};
«ENDDEFINE»

«REM»
	Template for a function to set inputs. 
«ENDREM»
«DEFINE generateInputSignal FOR Signal-»
	void «((Program)this.eContainer).name-»_INPUT_«this.name-»(«IF type!="ValueType::PURE"-»int val«ENDIF») {
		signals = signals | (1 << sig_«this.name»);
		«IF type!="ValueType::PURE"-»valSigInt[sig_«this.name-»]=val;«ENDIF»
	}
«ENDDEFINE»


«REM»
	Template for a function that generates outputs. 
«ENDREM»
«DEFINE generateOutputSignal FOR Signal»
	void «((Program)this.eContainer).name»_OUTPUT_«this.name»(int status){
		value = cJSON_CreateObject();
		cJSON_AddItemToObject(value, "present", status?cJSON_CreateTrue():cJSON_CreateFalse());
		«IF this.type == ValueType::INT-»
			cJSON_AddItemToObject(value, "value", cJSON_CreateNumber(VAL(sig_«this.name»)));
		«ENDIF-»
		cJSON_AddItemToObject(output, "«this.name»", value);
	}
«ENDDEFINE»


«REM»
	Template for a function that checks if a signal is set. For each signal it will be
	generated an if statement.
	The list is a list of signals. 
«ENDREM»
«DEFINE generateCallOutputs FOR List-»
	void callOutputs() {
		«FOREACH this AS signal-»
				  «IF ((Signal)signal).isOutput-»				  
					if(signals & (1 << sig_«((Signal)signal).name-»)) {
						«((Program)((Signal)signal).eContainer).name»_OUTPUT_«((Signal)signal).name-»(«IF ((Signal)signal).type!=ValueType::PURE»valSigInt[sig_«((Signal)signal).name»]«ENDIF»);
					}	
				«ENDIF-»
		«ENDFOREACH-»
		signals=0;
	}
«ENDDEFINE»
«DEFINE generateCallOutputsSim FOR List-»
	void callOutputs() {
		«FOREACH this AS signal-»
			«IF !((Signal)signal).isInput-»
				«((Program)((Signal)signal).eContainer).name»_OUTPUT_«((Signal)signal).name-»(signals & (1 << sig_«((Signal)signal).name-»));
			«ENDIF-»
		«ENDFOREACH-»
		signals=0;
	}
«ENDDEFINE»

«DEFINE generateReset FOR Program-»
	void reset() {
		signals = 0;
	}
«ENDDEFINE»

«REM»
	Reset funktion which initializes the signals. 
«ENDREM»
«DEFINE generateInitialize FOR Program-»
	int «((String)(GLOBALVAR name))»_reset() {
		RESET();
		/* initialize all valued integer signals */
		«FOREACH allSignals(this) AS signal-»
			«IF ((Signal)signal).type == ValueType::PURE-»
				valSigInt[sig_«((Signal)signal).name»] = «EXPAND getIntegerSignalValue FOR (Signal)signal-»;
			«ENDIF-»
		«ENDFOREACH-»
		return 0;
	}
«ENDDEFINE»