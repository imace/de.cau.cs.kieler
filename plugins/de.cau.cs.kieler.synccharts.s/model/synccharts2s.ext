import synccharts;
import annotations;
import expressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension helper;
extension transitions2Instructions;
extension haltInstruction;
extension termInstruction;
extension pauseInstruction;
extension gotoInstruction;
////////////////////////////////////////////

//-----------------------------------------------------------------------------
//     SyncChart - 2 - S    TRANSFORMATION    
//     @author: tam
//-----------------------------------------------------------------------------
  
//Start Model Transformation here.
create s::Program this transform(synccharts::Region root):
	addAllStatesToMappingList(root) ->
	computeThreadPriorities(root.innerStates.first()) ->
	this.setName(root.innerStates.first().id) ->
	// TODO: mit echter main thread prio ersetzen
	this.setPriority(setIntValue(getMainTreadPriority(root.innerStates.first()))) -> 
	this.setStates(getAllStates(root.innerStates.first())) ->
	this.setSignals(getStateSignals(root.innerStates.first()))
;


// Initialize the mapping lists with all states.
// After that you can use state.getSingleTraceTarget("S")
// to geht the s::State from a synccharts::State
// Start: ----------------------------------------------
Void addAllStatesToMappingList(synccharts::Region region):
	region.innerStates.addAllStatesToMappingList()
;

Void addAllStatesToMappingList(synccharts::State state):
	if state.regions.isEmpty then
		state.transform()
	else (
		state.transform() ->
		state.regions.addAllStatesToMappingList()
	)
;
// End: ------------------------------------------------

// Computation of the priority list like is was done in codegen.sc.
// Start: ----------------------------------------------
cached List computeThreadPriorities(synccharts::State rootState):
	JAVA Helper.computeThreadPriorities(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of a state. The state is not represented as weak
// or strong but by the real nature of the given state.
int getRealThreadPriority(synccharts::State state):
	JAVA Helper.getRealThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of the main thread.
cached int getMainTreadPriority(synccharts::State rootState):
	if rootState.regions.size == 1 then
		getRealThreadPriority(getInitialState(rootState))
	else
		getRealThreadPriority(rootState)
;
// End: ------------------------------------------------

//-------------------- - - - - - - ---------------------------------


// builds a state for s
s::State buildState(String name, List[s::Signal] signals, List[s::Instruction] instructions):
	let state = new s::State:
		state.setName(name) ->
		state.setSignals(signals) ->
		state.setInstructions(instructions)
;

// adds a state to a list of states
List[s::State] addStateToList(s::State state, List[s::State] states):
	states.add(state)
;

// returns a list including all states of the SyncChart
// the parameter has to be the root state of the SyncChart
List[s::State] getAllStates(synccharts::State state):
	let outList = {}:
	let putState = (s::State)state.getSingleTraceTarget("S"):
		putInstructions(putState, getStateInstructions(state)) ->
		if state.regions.isEmpty then (
			if state.parentRegion.parentState != null then
				outList.add(putState)
			else 
				null
			)
		else (
			//TODO: FORK und FORKE...
			(
			if state.parentRegion.parentState != null then
				outList.add(putState)
			else 
				null 
			)
			-> 
			outList.addAll(state.regions.getStatesOfRegion())
			)
		->
		outList
;

s::State putInstructions(s::State state, List[s::Instruction] instructions):
	state.instructions.addAll(instructions)
;

List[s::Instruction] getStateInstructions(synccharts::State state):
	let outList = {}:
		
		
		// TODO: # strong Transitions
		// TODO: onEntry actions
		// TODO: PRIO(weak)
		// TODO: # weak Transitions
		//////////// _intern ///////////
		// TODO: PRIO(strong)
		// TODO: normal termination
		// TODO: Label for join?
		// TODO: PAUSE
		// TODO: host code?
		// TODO: all strong transitions
		// TODO: onInside actions
		// TODO: PRIO(weak)
		// TODO: all weak transitions
		// TODO: GOTO(_intern)
		
		outList.add(getPauseInstruction(state)) ->
		// All transitions with Trigger
		outList.addAll(state.outgoingTransitions.getTransitionInstruction()) ->
		outList.addAll(getTermInstruction(state)) ->
		outList.add(getGotoInstruction(state)) ->
		outList
;

// returns a list of all states of a region
List[s::State] getStatesOfRegion(synccharts::Region region):
	let outList = {}:
	outList.addAll(region.innerStates.getAllStates()) ->
	// TODO: remove transform (not critical)
	outList.addAll(region.innerStates.transform()) ->
	outList
;



// transforms a SyncChart state into a S state
create s::State this transform(synccharts::State state):
	createTrace(this,state,"SyncCharts","S") ->
	createTrace(this,state,"SyncCharts","S_intern") ->
	createTrace(this,state,"SyncCharts","S_main") ->
	createTrace(this,state,"SyncCharts","S_main_intern") ->
	if state.regions.isEmpty then
		this.setName("L" + getStatePathAsName(state)) 
	else 
		this.setName("L_main" + getStatePathAsName(state))
	->
	if !state.signals.isEmpty then
		this.setSignals(state.signals.transform())
	else
		null
;

// Transforms a SyncCharts signal into a s Signal 
create s::Signal this transform(expressions::Signal signal):
	let sigType = new PrimitiveSignalType:
	createTrace(this,signal,"SyncCharts","S") ->
	// TODO: auch fÃ¼r complex
		sigType.setPrimitiveType(PrimitiveType::Pure) ->
		this.setName(signal.name) ->
		this.setType(sigType)
;

List[s::Signal] getStateSignals(synccharts::State state):
	state.signals.transform()
;