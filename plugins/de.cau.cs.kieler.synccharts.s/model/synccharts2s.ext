import synccharts;
import annotations;
import expressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension helper;
extension priorities;
extension transitions2Instructions;
extension haltInstruction;
extension termInstruction;
extension pauseInstruction;
extension gotoInstruction;
extension forkInstruction;
extension joinInstruction;
////////////////////////////////////////////

//-----------------------------------------------------------------------------
//     SyncChart - 2 - S    TRANSFORMATION    
//     @author: tam
//-----------------------------------------------------------------------------
  
//Start Model Transformation here.
create s::Program this transform(synccharts::Region root):
	addAllStatesToMappingList(root) ->
	computeThreadPriorities(root.innerStates.first()) ->
	this.setName(root.innerStates.first().id) ->
	this.setPriority(setIntValue(getMainTreadPriority(root.innerStates.first()))) -> 
	this.setStates(getAllStates(root.innerStates.first())) ->
	this.setSignals(getStateSignals(root.innerStates.first()))
;


// Initialize the mapping lists with all states.
// After that you can use state.getSingleTraceTarget("S")
// to geht the s::State from a synccharts::State
// Start: ----------------------------------------------
Void addAllStatesToMappingList(synccharts::Region region):
	region.innerStates.addAllStatesToMappingList()
;

Void addAllStatesToMappingList(synccharts::State state):
	state.transform() ->
	state.transformMain() ->
	state.transformIntern() ->
	state.transformMainIntern() ->
	state.regions.addAllStatesToMappingList()
;
// End: ------------------------------------------------

// Computation of the priority list like is was done in codegen.sc.
cached List computeThreadPriorities(synccharts::State rootState):
	JAVA Helper.computeThreadPriorities(de.cau.cs.kieler.synccharts.State)
;


// builds a state for s
s::State buildState(String name, List[s::Signal] signals, List[s::Instruction] instructions):
	let state = new s::State:
		state.setName(name) ->
		state.setSignals(signals) ->
		state.setInstructions(instructions)
;

// adds a state to a list of states
List[s::State] addStateToList(s::State state, List[s::State] states):
	states.add(state)
;

// returns a list including all states of the SyncChart
// the parameter has to be the root state of the SyncChart
List[s::State] getAllStates(synccharts::State state):
	let outList = {}:
	let putState = (s::State)state.getSingleTraceTarget("S"):
	let putStateIntern = (s::State)state.getSingleTraceTarget("S_intern"):
		(
			if state.parentRegion.parentState != null then (
				(
					if state.regions.isEmpty then (
						putInstructions(putState, getStateSurfInstructions(state)) ->
						putInstructions(putStateIntern, getStateDepthInstructions(state))
					) else (
						putInstructions(putState, getStateMainInstructions(state))
					)
				)
				->
				outList.add(putState) ->
				if state.regions.isEmpty then (
					outList.add(putStateIntern)
				) else (
					null
				)
				
			) else (
				null
			)
		)
		
		->
			
		(
			if !state.regions.isEmpty then (
				outList.addAll(state.regions.getStatesOfRegion()) ->
				if state.parentRegion.parentState != null then (
					let putStateHierarchy = (s::State)state.getSingleTraceTarget("S_main"):
					let putStateHierarchyIntern = (s::State)state.getSingleTraceTarget("S_main_intern"):
					putInstructions(putStateHierarchy, getStateSurfInstructions(state)) ->
					putInstructions(putStateHierarchyIntern, getStateDepthInstructions(state)) ->
					outList.add(putStateHierarchy) ->
					outList.add(putStateHierarchyIntern)
				) else (
					null
				)
			) else (
				null
			)
		)
		-> 
		outList
;

s::State putInstructions(s::State state, List[s::Instruction] instructions):
	state.instructions.addAll(instructions)
;

List[s::Instruction] getStateSurfInstructions(synccharts::State state):
	let outList = {}:
		// # strong Transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isImmediate && t.isStrongAbort()).getTransitionInstruction()) ->
		// TODO: onEntry actions
		// PRIO(weak)
		outList.addAll(getWeakStatePrio(state)) ->
		
		// # weak Transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isImmediate && t.isWeakAbort()).getTransitionInstruction()) ->
		//////////// _intern ///////////
		// PRIO(strong)
		outList.addAll(getRealStatePrio(state)) ->
		// normal termination
		outList.addAll(state.outgoingTransitions.select(t|t.isNormalTermination()).getJoinInstruction()) ->
		outList
;

List[s::Instruction] getStateDepthInstructions(synccharts::State state):
	let outList = {}:
		info(state.id) ->
		// PAUSE
		outList.addAll(getPauseInstruction(state)) ->
		// TODO: host code
		// all strong transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isStrongAbort()).getTransitionInstruction()) ->
		// TODO: onInside actions
		// PRIO(weak)
		outList.addAll(getWeakStatePrio(state)) ->
		// all weak transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isWeakAbort()).getTransitionInstruction()) ->
		// instructions for states without outgoing transitions
		outList.addAll(getTermInstruction(state)) ->
		outList.addAll(getHaltInstruction(state)) ->
		// GOTO(_intern): return to the return adress if no transition is taken
		outList.addAll(getGotoReturnInstruction(state)) ->
		// return value - a list with all instructions for a state
		outList
;

List[s::Instruction] getStateMainInstructions(synccharts::State state):
	let outList = {}:
		outList.addAll(getForkInstructions(state)) ->
		outList
;

// returns a list of all states of a region
List[s::State] getStatesOfRegion(synccharts::Region region):
	let outList = {}:
	outList.addAll(region.innerStates.getAllStates()) ->
	// TODO: remove transform (not critical)
	outList.addAll(region.innerStates.transform()) ->
	outList
;



// transforms a SyncChart state into a S state
create s::State this transform(synccharts::State state):
	createTrace(this,state,"SyncCharts","S") ->
	this.setName("L" + getStatePathAsName(state)) ->
	if !state.signals.isEmpty then
		this.setSignals(state.signals.transform())
	else
		null
;

// transforms a SyncChart state into a S state
create s::State this transformIntern(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_intern") ->
	this.setName("L" + getStatePathAsName(state) + "_intern")
;

// transforms a SyncChart state into a S state
create s::State this transformMain(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_main") ->
	this.setName("L" + getStatePathAsName(state) + "_main")
;

// transforms a SyncChart state into a S state
create s::State this transformMainIntern(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_main_intern") ->
	this.setName("L" + getStatePathAsName(state) + "_main_intern")
;


// Transforms a SyncCharts signal into a s Signal 
create s::Signal this transform(expressions::Signal signal):
	let sigType = new PrimitiveSignalType:
	createTrace(this,signal,"SyncCharts","S") ->
	// TODO: auch fÃ¼r complex
		sigType.setPrimitiveType(PrimitiveType::Pure) ->
		this.setName(signal.name) ->
		this.setType(sigType)
;

List[s::Signal] getStateSignals(synccharts::State state):
	state.signals.transform()
;