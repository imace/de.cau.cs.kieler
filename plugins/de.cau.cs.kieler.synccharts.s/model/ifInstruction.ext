import synccharts;
import annotations;
import expressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension gotoInstruction;
extension priorities;
////////////////////////////////////////////

List[Instruction] getIfInstruction(Transition transition):
	let out = {}:
	let ifInstr = new If:
	createIf(ifInstr, transition) ->
	out.add(ifInstr) ->
	out
;

//TODO: other Expressions!

Void createIf(If ifInstr, Transition transition) :
 	//TODO: for complex expression this code needs to be changed...
 	//Couldn't find property 'signal' for type expressions::OperatorExpression
 	
	//let triggerSignal = ((SignalReference)transition.trigger).signal:
	let targetState = transition.targetState:
		//present.setSignal((s::Signal) (trigger.getSingleTraceTarget("S")))-> // OLD
		ifInstr.setExpression(createExpression(transition.trigger)) ->
		ifInstr.instructions.addAll(getReducedPrio(transition)) ->
		ifInstr.instructions.addAll(getGotoInstruction(transition.targetState))
;


Expression createExpression(ValuedObjectReference valuedObjectReference) :
	let newValuedObjectReference = new ValuedObjectReference :
	let triggerSignal = ((ValuedObjectReference)valuedObjectReference).valuedObject :
	newValuedObjectReference.setValuedObject((Signal)triggerSignal.getSingleTraceTarget("S")) ->
	newValuedObjectReference
;

Expression createExpression(OperatorExpression operatorExpression) :
 	let newOperatorExpression = new OperatorExpression :
		newOperatorExpression.setOperator(operatorExpression.operator) ->
		newOperatorExpression.subExpressions.addAll(
			createExpression(operatorExpression.subExpressions)
		) ->
	newOperatorExpression
;

List[OperatorExpression] createExpression(List[OperatorExpression] operatorExpressionList) :
   let firstExpression = operatorExpressionList.first() :
   let newOperatorExpressionList = {} :
   newOperatorExpressionList.add(firstExpression.createExpression()) ->
   if (operatorExpressionList.size > 1) then
       newOperatorExpressionList.addAll(
        	createExpression(operatorExpressionList.withoutFirst())
       )
   else
   		null ->
   newOperatorExpressionList
;


Expression createExpression(Expression expression) :
   info("!!!!!!!!!!!!! SHOULD NOT HAPPEN !!!!!!!!!!!!!!!! [1]") ->
   // should not be executed [1]
   null
;

