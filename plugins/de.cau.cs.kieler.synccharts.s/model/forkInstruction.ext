import synccharts;
import annotations;
import kexpressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension model::helper;
extension model::priorities;
////////////////////////////////////////////

List[Instruction] getForkInstructions(synccharts::State state):
	let out = {}:
	let forke = new Fork:
			out.addAll(state.regions.transform()) ->
		if !state.regions.isEmpty then (
			forke.setThread((s::State)state.getSingleTraceTarget("S_main_surface")) ->
			out.add(forke)
		)
		else
			null
		->
		out
;

create s::Fork this transform(Region region):
//	let intValue = new s::IntValue:
	this.setThread((s::State)getInitialState(region).getSingleTraceTarget("S_surface")) ->
//	intValue.setValue(getRealThreadPriority(getInitialState(region))) ->
	this.setPriority(getRealThreadPriority(getInitialState(region)))
;
