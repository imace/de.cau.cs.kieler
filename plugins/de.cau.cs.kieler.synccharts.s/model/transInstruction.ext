import synccharts;
import annotations;
import kexpressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension model::helper;
extension model::priorities;
////////////////////////////////////////////

List[Instruction] getGotoInstruction(synccharts::State state):
	let out = {}:
	let trans = new Trans:
		(
			if state.isHierarchical() then (
				let abort = new Abort:
					out.add(abort) ->
					out.addAll(getRealStatePrio(state))
			) else (
				null
			)
		)
		->
		trans.setContinuation((s::Thread)state.getSingleTraceTarget("S_surface"))->
		out.add(trans)
		->
		out
;

// depth return
List[Instruction] getGotoReturnInstruction(synccharts::State state):
	let out = {}:
	let trans = new Trans:
	if !(state.isFinal || state.outgoingTransitions.isEmpty) then (
		(
			if state.isHierarchical() then
				trans.setContinuation((s::Thread)state.getSingleTraceTarget("S_main_depth"))
			else
				trans.setContinuation((s::State)state.getSingleTraceTarget("S_depth"))
		)
		->
		out.add(trans)
	)
	else
		null
	->
	out
;