grammar de.cau.cs.kieler.synccharts.TransitionLabel with org.eclipse.xtext.common.Terminals

generate transitionlabel "http://kieler.cs.cau.de/synccharts/actionlabel"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/synccharts" as synccharts


Action returns synccharts::Action:
	isImmediate?='#' (delay=INT)? (trigger=BooleanExpression)? ("/" (effects+=Effect)*)?; 		

Effect returns synccharts::Effect: 
	Emission | Assignment | HostCode;
		
Emission returns synccharts::Emission:
	signal=[synccharts::Signal] ("(" newValue=PrimaryExpression ")")?;

Assignment returns synccharts::Assignment:
	variable=[synccharts::Variable] ":=" expression=PrimaryExpression;

SignalReference returns synccharts::SignalReference:
	signal = [synccharts::Signal];

//SignalReference :
//	signal = [Signal];
	
VariableReference returns synccharts::VariableReference:
	variable = [synccharts::Variable];

IntValue: 
	value=INT;
FloatValue:
    value=Float;
BooleanValue:
    value=Boolean;
Value:
	IntValue | FloatValue | BooleanValue;

//Signal:
//	"signal" name = ID;
	
//Variable:
//	"variable" name = ID;

// make sure the Float rule does not shadow the built-in INT rule
terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
terminal Boolean returns ecore::EBoolean : "true" | "false";

HostCode returns synccharts::HostCode:
	//"'"code=STRING"'";
	//("(" type=ID ")")? 
	code=STRING; 	
	
ValOperation returns synccharts::ComplexExpression:
	operator=ValOperator subExpressions+=SignalReference;

ValueExpression returns synccharts::Expression:
	IntValue | FloatValue | ValOperation | VariableReference;

CompareOperation returns synccharts::Expression:
	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	

NotOperation returns synccharts::ComplexExpression:
	operator=NotOperator subExpressions+=BooleanExpression;

NotOrNormalExpression returns synccharts::Expression:
	NotOperation | BooleanExpression;

AndOperation returns synccharts::Expression:
	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;

OrOperation returns synccharts::Expression:
	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;

// TODO: get rid of parentheses
BooleanExpression returns synccharts::Expression:
	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;

PrimaryExpression returns synccharts::Expression:
	//ValueExpression | BooleanExpression;
	BooleanExpression;
	
enum OperatorType returns synccharts::OperatorType:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";

enum ValOperator returns synccharts::OperatorType:
	VAL="?";

enum CompareOperator returns synccharts::OperatorType:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
	
enum NotOperator returns synccharts::OperatorType:
	NOT="not";

enum OperatorOr returns synccharts::OperatorType:
	OR="or";

enum OperatorAnd returns synccharts::OperatorType:
	AND="and";