/******************************************************************************
 * KIELER - Kiel Integrated Environment for Layout for the Eclipse RCP
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright ${year} by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 ******************************************************************************/

/******************************************************************************
 * Namenueberlegungen fuer die neue Sprache:
 * RTSYS - ReTyped Synccharts
 * RTSYS - ReTouched Synccharts
 * RTSYS - ReTentive Language for Synccharts
 * RTSYS - RevisiTing Synccharts
 * RTSYS - Rational Text for Synccharts // alle anderen waren irrational:p
 * RTSYS - Recasting Synccharts (ReKasting fuer KIEL?) //unsmypatisch
 * RTSYS - Recapulated Synccharts (ReKapulated fuer KIEL?) //uebertrieben
 * RVH - Rational and Visionary Handling of Synccharts //Vision find ich passend:) 
 * SEWINCH -Simple Way of Editing Synccharts // Sevinc halam -- DA Name?
 * KITTY - KIeler TexTual sYnccharts // ssssuessss 
 ******************************************************************************/
grammar de.cau.cs.kieler.synccharts.dsl.RetypingSynccharts with org.eclipse.xtext.common.Terminals
generate retypingSynccharts "http://www.cau.de/cs/kieler/synccharts/dsl/RetypingSynccharts"
//import "platform:/resource/de.cau.cs.kieler.synccharts.labelparser/src-gen/de/cau/cs/kieler/synccharts/TransitionLabel.ecore" as transitionlabel
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

State :
	(isInitial?='init')?(isFinal?='final')? 
	(stateKind=StateType)? // if pseudo, the keyword becomes 'cond' etc instead of 'pseudo'
	('state')? // optional keyword, cf.Meeting_Textu alSyntax-II
	(stateName=ID)? //optional ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
	(label=STRING)? 
	(stateContent=StateContent)?
	(outgoingTransitions+=Transition)*
;
StateContent:
	'{'
//	(regions+=Region)*
	(		(exitActions+=ExitAction )
		| 	(entryActions+=EntryAction)
		| 	(innerAction+=InnerAction)
		| 	(signalsAndVariables+=ValuedObject)
		|	(innerStates+=State	('||' parallelStates+=State)*)
	)+	
	'}'
;
enum StateType	:
	PSEUDO | REFERENCE='reference' | TEXTUAL='textual'
; 
////Effect:
////	effectID=STRING
////;
EntryAction returns Action:// transitionlabel::Action :
	'onentry' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;  //do we need both in one list: triggersAndEffects?

ExitAction returns Action :
	'onexit' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 

InnerAction returns Action :
	'oninner' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 

//ValuedObject:
//	Signal | Variable
//;
//Signal:
//	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
//	type=ValueType name=ID (':=' initialValue=ID)? 
//	//combineOperator=CombineOperator 
//;
////enum CombineOperator :
////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
////;
//Variable:
//	type=ValueType name=ID (':=' initialValue=ID)? 
//;
//enum ValueType:
//	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
//;	
Transition:
	(sourceStateName=ID)? 
	transitionType=TransitionType 
	(targetStateName=ID | declaredTargetState=declaredTargetState)  
	('with' transitionLabel=[Action])?
//			(isHistory?='history')?
//			
//		( 	(delay=INT) (trigger=ID)
////		|	(delay=INT) ('/'effects+=ID)				
//		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
//		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
//		|   ((trigger=ID) | ('/'effects+=ID))
//		| 	(trigger=ID) ('/'effects+=ID)
//		)	
//)?
;
enum TransitionType :
	STRONGABORT='o->' | WEAKABORT='-->' | NORMALTERMINATION='>->'
;	
declaredTargetState returns State:
	(isInitial?='init')? (isFinal?='final')? 'state' 
	(declaredStateType=StateType)? declaredStateName=ID
;

//=======================================================================================================//
Action :
	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
	(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 		

Effect : 
	Emission | Assignment | HostCode;

Emission :
	signal=[Signal] ("(" newValue=PrimaryExpression ")")?;

Assignment :
	variable=[Variable] ":=" expression=PrimaryExpression;

SignalReference:
	reference = [Signal];
	
VariableReference:
	reference = [Variable];
ValuedObject:
	Signal | Variable
;
Signal:
	"input" name = ID (':=' initialValue=ID)?";";

Variable:
	"var" name = ID (':=' initialValue=ID)?";";

IntValue: 
	value=INT;
FloatValue:
    value=Float;
BooleanValue:
    value=Boolean;
Value:
	IntValue | FloatValue | BooleanValue;

// make sure the Float rule does not shadow the built-in INT rule
terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
terminal Boolean returns ecore::EBoolean : "true" | "false";

HostCode:
	//"'"code=STRING"'";
	//("(" type=ID ")")? 
	code=STRING; 	
	
Operator :
	operatorKind=OperatorKind;

ValOperation returns Expression:
	operator=ValOperator subExpressions+=SignalReference;

ValueExpression returns Expression:
	IntValue | FloatValue | ValOperation | VariableReference;

CompareOperation returns Expression:
	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	

NotOperation returns Operations:
	operators=NotOperator subExpressions+=BooleanExpression;

NotOrNormalExpression returns Expression:
	NotOperation | BooleanExpression;

AndOperation returns Expression:
	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;

OrOperation returns Expression:
	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;

// TODO: get rid of parentheses
BooleanExpression returns Expression:
	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;

PrimaryExpression returns Expression:
	//ValueExpression | BooleanExpression;
	BooleanExpression;
	
enum OperatorKind :
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";

enum ValOperator returns OperatorKind:
	VAL="?";

enum CompareOperator returns OperatorKind:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
	
enum NotOperator returns OperatorKind:
	NOT="not";

enum OperatorOr returns OperatorKind:
	OR="or";

enum OperatorAnd returns OperatorKind:
	AND="and";
