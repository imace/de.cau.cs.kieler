/*
 * generated by Xtext
 */
package de.cau.cs.kieler.synccharts.dsl.scoping;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.IScopedElement;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.ScopedElement;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.cau.cs.kieler.synccharts.dsl.retypingSynccharts.State;
import de.cau.cs.kieler.synccharts.dsl.retypingSynccharts.Transition;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class RetypingSyncchartsScopeProvider extends
		AbstractDeclarativeScopeProvider {

	public class ScopingScopeProvider extends AbstractDeclarativeScopeProvider {

		public IScope scope_Transition_targetState(Transition context,
				EReference reference) {
			State owner = org.eclipse.xtext.EcoreUtil2.getContainerOfType(
					context, State.class);
			return createScope(owner);
		}

		/*
		 * public IScope scope_ReferenceValue_value(NestedReferenceValue
		 * context, EReference reference) { Member member =
		 * context.getOwner().getValue(); if (member instanceof Owner) return
		 * createScope(((Owner) member).getMembers()); return IScope.NULLSCOPE;
		 * }
		 */

		private IScope createScope(State state) {
			// can be written more functional with google collections
			// List<IScopedElement> elements = new
			// ArrayList<IScopedElement>(state.size());
			// elements.add(ScopedElement.create(state.getId(), state));
			// return new SimpleScope(elements);
			return (IScope) ScopedElement.create(state.getName(), state);
		}
	}
}
