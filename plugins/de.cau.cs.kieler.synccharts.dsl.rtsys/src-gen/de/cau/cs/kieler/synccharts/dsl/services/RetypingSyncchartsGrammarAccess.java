/*
* generated by Xtext
*/

package de.cau.cs.kieler.synccharts.dsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;

import org.eclipse.xtext.service.GrammarProvider;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class RetypingSyncchartsGrammarAccess implements IGrammarAccess {
	
	
	public class StateElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "State");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cIsInitialAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cIsInitialInitKeyword_0_0_0 = (Keyword)cIsInitialAssignment_0_0.eContents().get(0);
		private final Assignment cIsFinalAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cIsFinalFinalKeyword_0_1_0 = (Keyword)cIsFinalAssignment_0_1.eContents().get(0);
		private final Assignment cStateKindAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cStateKindStateTypeEnumRuleCall_0_2_0 = (RuleCall)cStateKindAssignment_0_2.eContents().get(0);
		private final Keyword cStateKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStateNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStateNameIDTerminalRuleCall_2_0 = (RuleCall)cStateNameAssignment_2.eContents().get(0);
		private final Assignment cLabelAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLabelSTRINGTerminalRuleCall_3_0 = (RuleCall)cLabelAssignment_3.eContents().get(0);
		
		//State:
		//  (isInitial?="init"? isFinal?="final"? stateKind=StateType?) "state" stateName=ID
		//  label=STRING?; 
		//
		//  
		//	//!!!!!!!!!! DO NOT USE THE FOLLOWING RULE !!!!!!!!!! //
		//	 //!!!!!!!!!! ((isInitial?='init')|(isFinal?='final')|(stateKind=StateType)?)*   !!!!!!!!!! //
		//	 //!!!!!!!!!! DO NOT USE THE RULE ABOVE !!!!!!!!!! //
		//	 //((isInitial?='init')?(isFinal?='final')?(stateKind=StateType)?)* // if pseudo, the keyword becomes 'cond' etc instead of 'pseudo'
		//	 
		//	  // optional keyword, cf.Meeting_Textu alSyntax-II
		//	   //optionale ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
		//	  
		////	(stateContent=StateContent)?
		////	(outgoingTransitions+=Transition)*
		//
		////StateContent:
		////	'{'
		//////	(regions+=Region)*
		////	(		(exitActions+=ExitAction )
		////		| 	(entryActions+=EntryAction)
		////		| 	(innerAction+=InnerAction)
		////		| 	(signalsAndVariables+=ValuedObject)
		////		|	(innerStates+=State	('||' parallelStates+=State)*)
		////	)+	
		////	'}'
		////;
		public ParserRule getRule() { return rule; }

		//(isInitial?="init"? isFinal?="final"? stateKind=StateType?) "state" stateName=ID
		//label=STRING? 
		//	//!!!!!!!!!! DO NOT USE THE FOLLOWING RULE !!!!!!!!!! //
		//	 //!!!!!!!!!! ((isInitial?='init')|(isFinal?='final')|(stateKind=StateType)?)*   !!!!!!!!!! //
		//	 //!!!!!!!!!! DO NOT USE THE RULE ABOVE !!!!!!!!!! //
		//	 //((isInitial?='init')?(isFinal?='final')?(stateKind=StateType)?)* // if pseudo, the keyword becomes 'cond' etc instead of 'pseudo'
		//	 
		//	  // optional keyword, cf.Meeting_Textu alSyntax-II
		//	   //optionale ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
		//	  
		////	(stateContent=StateContent)?
		////	(outgoingTransitions+=Transition)*
		public Group getGroup() { return cGroup; }

		//isInitial?="init"? isFinal?="final"? stateKind=StateType?
		public Group getGroup_0() { return cGroup_0; }

		//isInitial?="init"?
		public Assignment getIsInitialAssignment_0_0() { return cIsInitialAssignment_0_0; }

		//"init"
		public Keyword getIsInitialInitKeyword_0_0_0() { return cIsInitialInitKeyword_0_0_0; }

		//isFinal?="final"?
		public Assignment getIsFinalAssignment_0_1() { return cIsFinalAssignment_0_1; }

		//"final"
		public Keyword getIsFinalFinalKeyword_0_1_0() { return cIsFinalFinalKeyword_0_1_0; }

		//stateKind=StateType?
		public Assignment getStateKindAssignment_0_2() { return cStateKindAssignment_0_2; }

		//StateType
		public RuleCall getStateKindStateTypeEnumRuleCall_0_2_0() { return cStateKindStateTypeEnumRuleCall_0_2_0; }

		//"state" 
		//	  // optional keyword, cf.Meeting_Textu alSyntax-II
		public Keyword getStateKeyword_1() { return cStateKeyword_1; }

		//stateName=ID
		public Assignment getStateNameAssignment_2() { return cStateNameAssignment_2; }

		//ID
		public RuleCall getStateNameIDTerminalRuleCall_2_0() { return cStateNameIDTerminalRuleCall_2_0; }

		//label=STRING?
		public Assignment getLabelAssignment_3() { return cLabelAssignment_3; }

		//STRING
		public RuleCall getLabelSTRINGTerminalRuleCall_3_0() { return cLabelSTRINGTerminalRuleCall_3_0; }
	}
	
	
	public class StateTypeElements implements IEnumRuleAccess {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "StateType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNORMALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNORMALNORMALKeyword_0_0 = (Keyword)cNORMALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPSEUDOEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPSEUDOCondKeyword_1_0 = (Keyword)cPSEUDOEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cREFERENCEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cREFERENCEReferenceKeyword_2_0 = (Keyword)cREFERENCEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cTEXTUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cTEXTUALTextualKeyword_3_0 = (Keyword)cTEXTUALEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum StateType:
		//  NORMAL | PSEUDO="cond" | REFERENCE="reference" | TEXTUAL="textual"; 
		////StateContent:
		////	'{'
		//////	(regions+=Region)*
		////	(		(exitActions+=ExitAction )
		////		| 	(entryActions+=EntryAction)
		////		| 	(innerAction+=InnerAction)
		////		| 	(signalsAndVariables+=ValuedObject)
		////		|	(innerStates+=State	('||' parallelStates+=State)*)
		////	)+	
		////	'}'
		////;
		//  	 
		//	            
		// 
		////////Effect:
		////////	effectID=STRING
		////////;
		////EntryAction returns Action:// transitionlabel::Action :
		////	'onentry' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;  //do we need both in one list: triggersAndEffects?
		////
		////ExitAction returns Action :
		////	'onexit' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 
		////
		////InnerAction returns Action :
		////	'oninner' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 
		////
		//////ValuedObject:
		//////	Signal | Variable
		//////;
		//////Signal:
		//////	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
		//////	type=ValueType name=ID (':=' initialValue=ID)? 
		//////	//combineOperator=CombineOperator 
		//////;
		////////enum CombineOperator :
		////////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
		////////;
		//////Variable:
		//////	type=ValueType name=ID (':=' initialValue=ID)? 
		//////;
		//////enum ValueType:
		//////	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
		//////;	
		////Transition:
		////	(sourceStateName=ID)? 
		////	transitionType=TransitionType 
		////	(targetStateName=ID | declaredTargetState=declaredTargetState)  
		////	('with' transitionLabel=[Action])?
		//////			(isHistory?='history')?
		//////			
		//////		( 	(delay=INT) (trigger=ID)
		////////		|	(delay=INT) ('/'effects+=ID)				
		//////		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
		//////		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
		//////		|   ((trigger=ID) | ('/'effects+=ID))
		//////		| 	(trigger=ID) ('/'effects+=ID)
		//////		)	
		//////)?
		////;
		////enum TransitionType :
		////	STRONGABORT='o->' | WEAKABORT='-->' | NORMALTERMINATION='>->'
		////;	
		////declaredTargetState returns State:
		////	(isInitial?='init')? (isFinal?='final')? 'state' 
		////	(declaredStateType=StateType)? declaredStateName=ID
		////;
		////
		//////=======================================================================================================//
		////Action :
		////	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
		////	(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 		
		////
		////Effect : 
		////	Emission | Assignment | HostCode;
		////
		////Emission :
		////	signal=[Signal] ("(" newValue=PrimaryExpression ")")?;
		////
		////Assignment :
		////	variable=[Variable] ":=" expression=PrimaryExpression;
		////
		////SignalReference:
		////	reference = [Signal];
		////	
		////VariableReference:
		////	reference = [Variable];
		////ValuedObject:
		////	Signal | Variable
		////;
		////Signal:
		////	"input" name = ID (':=' initialValue=ID)?";";
		////
		////Variable:
		////	"var" name = ID (':=' initialValue=ID)?";";
		////
		////IntValue: 
		////	value=INT;
		////FloatValue:
		////    value=Float;
		////BooleanValue:
		////    value=Boolean;
		////Value:
		////	IntValue | FloatValue | BooleanValue;
		////
		////// make sure the Float rule does not shadow the built-in INT rule
		////terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
		////terminal Boolean returns ecore::EBoolean : "true" | "false";
		////
		////HostCode:
		////	//"'"code=STRING"'";
		////	//("(" type=ID ")")? 
		////	code=STRING; 	
		////	
		////Operator :
		////	operatorKind=OperatorKind;
		////
		////ValOperation returns Expression:
		////	operator=ValOperator subExpressions+=SignalReference;
		////
		////ValueExpression returns Expression:
		////	IntValue | FloatValue | ValOperation | VariableReference;
		////
		////CompareOperation returns Expression:
		////	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	
		////
		////NotOperation returns Operations:
		////	operators=NotOperator subExpressions+=BooleanExpression;
		////
		////NotOrNormalExpression returns Expression:
		////	NotOperation | BooleanExpression;
		////
		////AndOperation returns Expression:
		////	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;
		////
		////OrOperation returns Expression:
		////	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
		////
		////// TODO: get rid of parentheses
		////BooleanExpression returns Expression:
		////	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;
		////
		////PrimaryExpression returns Expression:
		////	//ValueExpression | BooleanExpression;
		////	BooleanExpression;
		////	
		////enum OperatorKind :
		////	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";
		////
		////enum ValOperator returns OperatorKind:
		////	VAL="?";
		////
		////enum CompareOperator returns OperatorKind:
		////	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
		////	
		////enum NotOperator returns OperatorKind:
		////	NOT="not";
		////
		////enum OperatorOr returns OperatorKind:
		////	OR="or";
		////
		////enum OperatorAnd returns OperatorKind:
		////	AND="and";
		public EnumRule getRule() { return rule; }

		//NORMAL | PSEUDO="cond" | REFERENCE="reference" | TEXTUAL="textual" 
		////StateContent:
		////	'{'
		//////	(regions+=Region)*
		////	(		(exitActions+=ExitAction )
		////		| 	(entryActions+=EntryAction)
		////		| 	(innerAction+=InnerAction)
		////		| 	(signalsAndVariables+=ValuedObject)
		////		|	(innerStates+=State	('||' parallelStates+=State)*)
		////	)+	
		////	'}'
		////;
		//  	 
		//	            
		// 
		////////Effect:
		////////	effectID=STRING
		////////;
		////EntryAction returns Action:// transitionlabel::Action :
		////	'onentry' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;  //do we need both in one list: triggersAndEffects?
		////
		////ExitAction returns Action :
		////	'onexit' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 
		////
		////InnerAction returns Action :
		////	'oninner' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 
		////
		//////ValuedObject:
		//////	Signal | Variable
		//////;
		//////Signal:
		//////	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
		//////	type=ValueType name=ID (':=' initialValue=ID)? 
		//////	//combineOperator=CombineOperator 
		//////;
		////////enum CombineOperator :
		////////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
		////////;
		//////Variable:
		//////	type=ValueType name=ID (':=' initialValue=ID)? 
		//////;
		//////enum ValueType:
		//////	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
		//////;	
		////Transition:
		////	(sourceStateName=ID)? 
		////	transitionType=TransitionType 
		////	(targetStateName=ID | declaredTargetState=declaredTargetState)  
		////	('with' transitionLabel=[Action])?
		//////			(isHistory?='history')?
		//////			
		//////		( 	(delay=INT) (trigger=ID)
		////////		|	(delay=INT) ('/'effects+=ID)				
		//////		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
		//////		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
		//////		|   ((trigger=ID) | ('/'effects+=ID))
		//////		| 	(trigger=ID) ('/'effects+=ID)
		//////		)	
		//////)?
		////;
		////enum TransitionType :
		////	STRONGABORT='o->' | WEAKABORT='-->' | NORMALTERMINATION='>->'
		////;	
		////declaredTargetState returns State:
		////	(isInitial?='init')? (isFinal?='final')? 'state' 
		////	(declaredStateType=StateType)? declaredStateName=ID
		////;
		////
		//////=======================================================================================================//
		////Action :
		////	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
		////	(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 		
		////
		////Effect : 
		////	Emission | Assignment | HostCode;
		////
		////Emission :
		////	signal=[Signal] ("(" newValue=PrimaryExpression ")")?;
		////
		////Assignment :
		////	variable=[Variable] ":=" expression=PrimaryExpression;
		////
		////SignalReference:
		////	reference = [Signal];
		////	
		////VariableReference:
		////	reference = [Variable];
		////ValuedObject:
		////	Signal | Variable
		////;
		////Signal:
		////	"input" name = ID (':=' initialValue=ID)?";";
		////
		////Variable:
		////	"var" name = ID (':=' initialValue=ID)?";";
		////
		////IntValue: 
		////	value=INT;
		////FloatValue:
		////    value=Float;
		////BooleanValue:
		////    value=Boolean;
		////Value:
		////	IntValue | FloatValue | BooleanValue;
		////
		////// make sure the Float rule does not shadow the built-in INT rule
		////terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
		////terminal Boolean returns ecore::EBoolean : "true" | "false";
		////
		////HostCode:
		////	//"'"code=STRING"'";
		////	//("(" type=ID ")")? 
		////	code=STRING; 	
		////	
		////Operator :
		////	operatorKind=OperatorKind;
		////
		////ValOperation returns Expression:
		////	operator=ValOperator subExpressions+=SignalReference;
		////
		////ValueExpression returns Expression:
		////	IntValue | FloatValue | ValOperation | VariableReference;
		////
		////CompareOperation returns Expression:
		////	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	
		////
		////NotOperation returns Operations:
		////	operators=NotOperator subExpressions+=BooleanExpression;
		////
		////NotOrNormalExpression returns Expression:
		////	NotOperation | BooleanExpression;
		////
		////AndOperation returns Expression:
		////	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;
		////
		////OrOperation returns Expression:
		////	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
		////
		////// TODO: get rid of parentheses
		////BooleanExpression returns Expression:
		////	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;
		////
		////PrimaryExpression returns Expression:
		////	//ValueExpression | BooleanExpression;
		////	BooleanExpression;
		////	
		////enum OperatorKind :
		////	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";
		////
		////enum ValOperator returns OperatorKind:
		////	VAL="?";
		////
		////enum CompareOperator returns OperatorKind:
		////	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
		////	
		////enum NotOperator returns OperatorKind:
		////	NOT="not";
		////
		////enum OperatorOr returns OperatorKind:
		////	OR="or";
		////
		////enum OperatorAnd returns OperatorKind:
		////	AND="and";
		public Alternatives getAlternatives() { return cAlternatives; }

		//NORMAL
		public EnumLiteralDeclaration getNORMALEnumLiteralDeclaration_0() { return cNORMALEnumLiteralDeclaration_0; }

		//"NORMAL"
		public Keyword getNORMALNORMALKeyword_0_0() { return cNORMALNORMALKeyword_0_0; }

		//PSEUDO="cond"
		public EnumLiteralDeclaration getPSEUDOEnumLiteralDeclaration_1() { return cPSEUDOEnumLiteralDeclaration_1; }

		//"cond"
		public Keyword getPSEUDOCondKeyword_1_0() { return cPSEUDOCondKeyword_1_0; }

		//REFERENCE="reference"
		public EnumLiteralDeclaration getREFERENCEEnumLiteralDeclaration_2() { return cREFERENCEEnumLiteralDeclaration_2; }

		//"reference"
		public Keyword getREFERENCEReferenceKeyword_2_0() { return cREFERENCEReferenceKeyword_2_0; }

		//TEXTUAL="textual"
		public EnumLiteralDeclaration getTEXTUALEnumLiteralDeclaration_3() { return cTEXTUALEnumLiteralDeclaration_3; }

		//"textual"
		public Keyword getTEXTUALTextualKeyword_3_0() { return cTEXTUALTextualKeyword_3_0; }
	}
	
	private StateElements pState;
	private StateTypeElements unknownRuleStateType;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public RetypingSyncchartsGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//State:
	//  (isInitial?="init"? isFinal?="final"? stateKind=StateType?) "state" stateName=ID
	//  label=STRING?; 
	//
	//  
	//	//!!!!!!!!!! DO NOT USE THE FOLLOWING RULE !!!!!!!!!! //
	//	 //!!!!!!!!!! ((isInitial?='init')|(isFinal?='final')|(stateKind=StateType)?)*   !!!!!!!!!! //
	//	 //!!!!!!!!!! DO NOT USE THE RULE ABOVE !!!!!!!!!! //
	//	 //((isInitial?='init')?(isFinal?='final')?(stateKind=StateType)?)* // if pseudo, the keyword becomes 'cond' etc instead of 'pseudo'
	//	 
	//	  // optional keyword, cf.Meeting_Textu alSyntax-II
	//	   //optionale ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
	//	  
	////	(stateContent=StateContent)?
	////	(outgoingTransitions+=Transition)*
	//
	////StateContent:
	////	'{'
	//////	(regions+=Region)*
	////	(		(exitActions+=ExitAction )
	////		| 	(entryActions+=EntryAction)
	////		| 	(innerAction+=InnerAction)
	////		| 	(signalsAndVariables+=ValuedObject)
	////		|	(innerStates+=State	('||' parallelStates+=State)*)
	////	)+	
	////	'}'
	////;
	public StateElements getStateAccess() {
		return (pState != null) ? pState : (pState = new StateElements());
	}
	
	public ParserRule getStateRule() {
		return getStateAccess().getRule();
	}

	//enum StateType:
	//  NORMAL | PSEUDO="cond" | REFERENCE="reference" | TEXTUAL="textual"; 
	////StateContent:
	////	'{'
	//////	(regions+=Region)*
	////	(		(exitActions+=ExitAction )
	////		| 	(entryActions+=EntryAction)
	////		| 	(innerAction+=InnerAction)
	////		| 	(signalsAndVariables+=ValuedObject)
	////		|	(innerStates+=State	('||' parallelStates+=State)*)
	////	)+	
	////	'}'
	////;
	//  	 
	//	            
	// 
	////////Effect:
	////////	effectID=STRING
	////////;
	////EntryAction returns Action:// transitionlabel::Action :
	////	'onentry' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;  //do we need both in one list: triggersAndEffects?
	////
	////ExitAction returns Action :
	////	'onexit' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 
	////
	////InnerAction returns Action :
	////	'oninner' (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 
	////
	//////ValuedObject:
	//////	Signal | Variable
	//////;
	//////Signal:
	//////	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
	//////	type=ValueType name=ID (':=' initialValue=ID)? 
	//////	//combineOperator=CombineOperator 
	//////;
	////////enum CombineOperator :
	////////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
	////////;
	//////Variable:
	//////	type=ValueType name=ID (':=' initialValue=ID)? 
	//////;
	//////enum ValueType:
	//////	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
	//////;	
	////Transition:
	////	(sourceStateName=ID)? 
	////	transitionType=TransitionType 
	////	(targetStateName=ID | declaredTargetState=declaredTargetState)  
	////	('with' transitionLabel=[Action])?
	//////			(isHistory?='history')?
	//////			
	//////		( 	(delay=INT) (trigger=ID)
	////////		|	(delay=INT) ('/'effects+=ID)				
	//////		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
	//////		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
	//////		|   ((trigger=ID) | ('/'effects+=ID))
	//////		| 	(trigger=ID) ('/'effects+=ID)
	//////		)	
	//////)?
	////;
	////enum TransitionType :
	////	STRONGABORT='o->' | WEAKABORT='-->' | NORMALTERMINATION='>->'
	////;	
	////declaredTargetState returns State:
	////	(isInitial?='init')? (isFinal?='final')? 'state' 
	////	(declaredStateType=StateType)? declaredStateName=ID
	////;
	////
	//////=======================================================================================================//
	////Action :
	////	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
	////	(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 		
	////
	////Effect : 
	////	Emission | Assignment | HostCode;
	////
	////Emission :
	////	signal=[Signal] ("(" newValue=PrimaryExpression ")")?;
	////
	////Assignment :
	////	variable=[Variable] ":=" expression=PrimaryExpression;
	////
	////SignalReference:
	////	reference = [Signal];
	////	
	////VariableReference:
	////	reference = [Variable];
	////ValuedObject:
	////	Signal | Variable
	////;
	////Signal:
	////	"input" name = ID (':=' initialValue=ID)?";";
	////
	////Variable:
	////	"var" name = ID (':=' initialValue=ID)?";";
	////
	////IntValue: 
	////	value=INT;
	////FloatValue:
	////    value=Float;
	////BooleanValue:
	////    value=Boolean;
	////Value:
	////	IntValue | FloatValue | BooleanValue;
	////
	////// make sure the Float rule does not shadow the built-in INT rule
	////terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
	////terminal Boolean returns ecore::EBoolean : "true" | "false";
	////
	////HostCode:
	////	//"'"code=STRING"'";
	////	//("(" type=ID ")")? 
	////	code=STRING; 	
	////	
	////Operator :
	////	operatorKind=OperatorKind;
	////
	////ValOperation returns Expression:
	////	operator=ValOperator subExpressions+=SignalReference;
	////
	////ValueExpression returns Expression:
	////	IntValue | FloatValue | ValOperation | VariableReference;
	////
	////CompareOperation returns Expression:
	////	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	
	////
	////NotOperation returns Operations:
	////	operators=NotOperator subExpressions+=BooleanExpression;
	////
	////NotOrNormalExpression returns Expression:
	////	NotOperation | BooleanExpression;
	////
	////AndOperation returns Expression:
	////	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;
	////
	////OrOperation returns Expression:
	////	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
	////
	////// TODO: get rid of parentheses
	////BooleanExpression returns Expression:
	////	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;
	////
	////PrimaryExpression returns Expression:
	////	//ValueExpression | BooleanExpression;
	////	BooleanExpression;
	////	
	////enum OperatorKind :
	////	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";
	////
	////enum ValOperator returns OperatorKind:
	////	VAL="?";
	////
	////enum CompareOperator returns OperatorKind:
	////	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
	////	
	////enum NotOperator returns OperatorKind:
	////	NOT="not";
	////
	////enum OperatorOr returns OperatorKind:
	////	OR="or";
	////
	////enum OperatorAnd returns OperatorKind:
	////	AND="and";
	public StateTypeElements getStateTypeAccess() {
		return (unknownRuleStateType != null) ? unknownRuleStateType : (unknownRuleStateType = new StateTypeElements());
	}
	
	public EnumRule getStateTypeRule() {
		return getStateTypeAccess().getRule();
	}

	//terminal ID:
	//  "^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//  "0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//  "\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" |
	//  "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//  "/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//  "//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//  (" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//  .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
