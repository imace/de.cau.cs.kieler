/*
* generated by Xtext
*/
package de.cau.cs.kieler.synccharts.dsl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.synccharts.dsl.services.RetypingSyncchartsGrammarAccess;

import com.google.inject.Inject;

public class RetypingSyncchartsParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private RetypingSyncchartsGrammarAccess grammarAccess;
		
	public RetypingSyncchartsGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_Group(this, this, 0, inst);
			case 1: return new StateContent_Group(this, this, 1, inst);
			case 2: return new EntryAction_Group(this, this, 2, inst);
			case 3: return new ExitAction_Group(this, this, 3, inst);
			case 4: return new InnerAction_Group(this, this, 4, inst);
			case 5: return new Transition_Group(this, this, 5, inst);
			case 6: return new DeclaredTargetState_Group(this, this, 6, inst);
			case 7: return new Action_Group(this, this, 7, inst);
			case 8: return new Effect_Alternatives(this, this, 8, inst);
			case 9: return new Emission_Group(this, this, 9, inst);
			case 10: return new Assignment_Group(this, this, 10, inst);
			case 11: return new SignalReference_ReferenceAssignment(this, this, 11, inst);
			case 12: return new VariableReference_ReferenceAssignment(this, this, 12, inst);
			case 13: return new ValuedObject_Alternatives(this, this, 13, inst);
			case 14: return new Signal_Group(this, this, 14, inst);
			case 15: return new Variable_Group(this, this, 15, inst);
			case 16: return new IntValue_ValueAssignment(this, this, 16, inst);
			case 17: return new FloatValue_ValueAssignment(this, this, 17, inst);
			case 18: return new BooleanValue_ValueAssignment(this, this, 18, inst);
			case 19: return new Value_Alternatives(this, this, 19, inst);
			case 20: return new HostCode_CodeAssignment(this, this, 20, inst);
			case 21: return new Operator_OperatorKindAssignment(this, this, 21, inst);
			case 22: return new ValOperation_Group(this, this, 22, inst);
			case 23: return new ValueExpression_Alternatives(this, this, 23, inst);
			case 24: return new CompareOperation_Group(this, this, 24, inst);
			case 25: return new NotOperation_Group(this, this, 25, inst);
			case 26: return new NotOrNormalExpression_Alternatives(this, this, 26, inst);
			case 27: return new AndOperation_Group(this, this, 27, inst);
			case 28: return new OrOperation_Group(this, this, 28, inst);
			case 29: return new BooleanExpression_Alternatives(this, this, 29, inst);
			case 30: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 30, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule State ****************
 *
 * State:
 *   isInitial?="init"? isFinal?="final"? stateKind=StateType? "state"? stateName=ID?
 *   label=STRING? stateContent=StateContent? outgoingTransitions+=Transition*; 
 * 
 *   
 * 	 
 * 	  // if pseudo, the keyword becomes 'cond' etc instead of 'pseudo'
 * 	   // optional keyword, cf.Meeting_Textu alSyntax-II
 * 	   //optional ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
 *
 **/

// isInitial?="init"? isFinal?="final"? stateKind=StateType? "state"? stateName=ID?
// label=STRING? stateContent=StateContent? outgoingTransitions+=Transition* 
// 	 
// 	  // if pseudo, the keyword becomes 'cond' etc instead of 'pseudo'
// 	   // optional keyword, cf.Meeting_Textu alSyntax-II
// 	   //optional ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
protected class State_Group extends GroupToken {
	
	public State_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getStateAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_OutgoingTransitionsAssignment_7(parent, this, 0, inst);
			case 1: return new State_StateContentAssignment_6(parent, this, 1, inst);
			case 2: return new State_LabelAssignment_5(parent, this, 2, inst);
			case 3: return new State_StateNameAssignment_4(parent, this, 3, inst);
			case 4: return new State_StateKeyword_3(parent, this, 4, inst);
			case 5: return new State_StateKindAssignment_2(parent, this, 5, inst);
			case 6: return new State_IsFinalAssignment_1(parent, this, 6, inst);
			case 7: return new State_IsInitialAssignment_0(parent, this, 7, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStateRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// isInitial?="init"?
protected class State_IsInitialAssignment_0 extends AssignmentToken  {
	
	public State_IsInitialAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getIsInitialAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isInitial",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isInitial");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getStateAccess().getIsInitialInitKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// isFinal?="final"?
protected class State_IsFinalAssignment_1 extends AssignmentToken  {
	
	public State_IsFinalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getIsFinalAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_IsInitialAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isFinal",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isFinal");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getStateAccess().getIsFinalFinalKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// stateKind=StateType?
protected class State_StateKindAssignment_2 extends AssignmentToken  {
	
	public State_StateKindAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getStateKindAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_IsFinalAssignment_1(parent, this, 0, inst);
			case 1: return new State_IsInitialAssignment_0(parent, this, 1, inst);
			default: return parent.createParentFollower(this, index, index - 2, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("stateKind",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("stateKind");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getStateAccess().getStateKindStateTypeEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "state"?
protected class State_StateKeyword_3 extends KeywordToken  {
	
	public State_StateKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getStateAccess().getStateKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_StateKindAssignment_2(parent, this, 0, inst);
			case 1: return new State_IsFinalAssignment_1(parent, this, 1, inst);
			case 2: return new State_IsInitialAssignment_0(parent, this, 2, inst);
			default: return parent.createParentFollower(this, index, index - 3, inst);
		}	
	}	
		
}

// stateName=ID?
protected class State_StateNameAssignment_4 extends AssignmentToken  {
	
	public State_StateNameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getStateNameAssignment_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_StateKeyword_3(parent, this, 0, inst);
			case 1: return new State_StateKindAssignment_2(parent, this, 1, inst);
			case 2: return new State_IsFinalAssignment_1(parent, this, 2, inst);
			case 3: return new State_IsInitialAssignment_0(parent, this, 3, inst);
			default: return parent.createParentFollower(this, index, index - 4, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("stateName",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("stateName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStateAccess().getStateNameIDTerminalRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// label=STRING?
protected class State_LabelAssignment_5 extends AssignmentToken  {
	
	public State_LabelAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getLabelAssignment_5();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_StateNameAssignment_4(parent, this, 0, inst);
			case 1: return new State_StateKeyword_3(parent, this, 1, inst);
			case 2: return new State_StateKindAssignment_2(parent, this, 2, inst);
			case 3: return new State_IsFinalAssignment_1(parent, this, 3, inst);
			case 4: return new State_IsInitialAssignment_0(parent, this, 4, inst);
			default: return parent.createParentFollower(this, index, index - 5, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("label",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("label");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStateAccess().getLabelSTRINGTerminalRuleCall_5_0();
			return obj;
		}
		return null;
	}

}

// stateContent=StateContent?
protected class State_StateContentAssignment_6 extends AssignmentToken  {
	
	public State_StateContentAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getStateContentAssignment_6();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("stateContent",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("stateContent");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStateContentRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateAccess().getStateContentStateContentParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new State_LabelAssignment_5(parent, next, actIndex, consumed);
			case 1: return new State_StateNameAssignment_4(parent, next, actIndex, consumed);
			case 2: return new State_StateKeyword_3(parent, next, actIndex, consumed);
			case 3: return new State_StateKindAssignment_2(parent, next, actIndex, consumed);
			case 4: return new State_IsFinalAssignment_1(parent, next, actIndex, consumed);
			case 5: return new State_IsInitialAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 6, consumed);
		}	
	}	
}

// outgoingTransitions+=Transition*
protected class State_OutgoingTransitionsAssignment_7 extends AssignmentToken  {
	
	public State_OutgoingTransitionsAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateAccess().getOutgoingTransitionsAssignment_7();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("outgoingTransitions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("outgoingTransitions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTransitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateAccess().getOutgoingTransitionsTransitionParserRuleCall_7_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new State_OutgoingTransitionsAssignment_7(parent, next, actIndex, consumed);
			case 1: return new State_StateContentAssignment_6(parent, next, actIndex, consumed);
			case 2: return new State_LabelAssignment_5(parent, next, actIndex, consumed);
			case 3: return new State_StateNameAssignment_4(parent, next, actIndex, consumed);
			case 4: return new State_StateKeyword_3(parent, next, actIndex, consumed);
			case 5: return new State_StateKindAssignment_2(parent, next, actIndex, consumed);
			case 6: return new State_IsFinalAssignment_1(parent, next, actIndex, consumed);
			case 7: return new State_IsInitialAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 8, consumed);
		}	
	}	
}


/************ end Rule State ****************/


/************ begin Rule StateContent ****************
 *
 * StateContent:
 *   "{" (exitActions+=ExitAction|entryActions+=EntryAction|innerAction+=InnerAction|
 *   signalsAndVariables+=ValuedObject|innerStates+=State ("||" parallelStates+=State)*
 *   )+ "}"; 
 * 
 * 	
 * //	(regions+=Region)*
 *
 **/

// "{" (exitActions+=ExitAction|entryActions+=EntryAction|innerAction+=InnerAction|
// signalsAndVariables+=ValuedObject|innerStates+=State ("||" parallelStates+=State)*
// )+ "}" 
// 	
// //	(regions+=Region)*
protected class StateContent_Group extends GroupToken {
	
	public StateContent_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getStateContentAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_RightCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStateContentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{" 
// 	
// //	(regions+=Region)*
protected class StateContent_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public StateContent_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getStateContentAccess().getLeftCurlyBracketKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// (exitActions+=ExitAction|entryActions+=EntryAction|innerAction+=InnerAction|
// signalsAndVariables+=ValuedObject|innerStates+=State ("||" parallelStates+=State)*
// )+ 
// //	(regions+=Region)*
protected class StateContent_Alternatives_1 extends AlternativesToken {

	public StateContent_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getStateContentAccess().getAlternatives_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_ExitActionsAssignment_1_0(parent, this, 0, inst);
			case 1: return new StateContent_EntryActionsAssignment_1_1(parent, this, 1, inst);
			case 2: return new StateContent_InnerActionAssignment_1_2(parent, this, 2, inst);
			case 3: return new StateContent_SignalsAndVariablesAssignment_1_3(parent, this, 3, inst);
			case 4: return new StateContent_Group_1_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}

// exitActions+=ExitAction
protected class StateContent_ExitActionsAssignment_1_0 extends AssignmentToken  {
	
	public StateContent_ExitActionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateContentAccess().getExitActionsAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExitAction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("exitActions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("exitActions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExitActionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateContentAccess().getExitActionsExitActionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateContent_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new StateContent_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// entryActions+=EntryAction
protected class StateContent_EntryActionsAssignment_1_1 extends AssignmentToken  {
	
	public StateContent_EntryActionsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateContentAccess().getEntryActionsAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EntryAction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entryActions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entryActions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEntryActionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateContentAccess().getEntryActionsEntryActionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateContent_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new StateContent_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// innerAction+=InnerAction
protected class StateContent_InnerActionAssignment_1_2 extends AssignmentToken  {
	
	public StateContent_InnerActionAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateContentAccess().getInnerActionAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InnerAction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("innerAction",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("innerAction");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInnerActionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateContentAccess().getInnerActionInnerActionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateContent_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new StateContent_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// signalsAndVariables+=ValuedObject
protected class StateContent_SignalsAndVariablesAssignment_1_3 extends AssignmentToken  {
	
	public StateContent_SignalsAndVariablesAssignment_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateContentAccess().getSignalsAndVariablesAssignment_1_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValuedObject_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signalsAndVariables",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signalsAndVariables");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValuedObjectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateContentAccess().getSignalsAndVariablesValuedObjectParserRuleCall_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateContent_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new StateContent_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// innerStates+=State ("||" parallelStates+=State)*
protected class StateContent_Group_1_4 extends GroupToken {
	
	public StateContent_Group_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getStateContentAccess().getGroup_1_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_Group_1_4_1(parent, this, 0, inst);
			case 1: return new StateContent_InnerStatesAssignment_1_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// innerStates+=State
protected class StateContent_InnerStatesAssignment_1_4_0 extends AssignmentToken  {
	
	public StateContent_InnerStatesAssignment_1_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateContentAccess().getInnerStatesAssignment_1_4_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("innerStates",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("innerStates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStateRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateContentAccess().getInnerStatesStateParserRuleCall_1_4_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateContent_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new StateContent_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("||" parallelStates+=State)*
protected class StateContent_Group_1_4_1 extends GroupToken {
	
	public StateContent_Group_1_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getStateContentAccess().getGroup_1_4_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_ParallelStatesAssignment_1_4_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "||"
protected class StateContent_VerticalLineVerticalLineKeyword_1_4_1_0 extends KeywordToken  {
	
	public StateContent_VerticalLineVerticalLineKeyword_1_4_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getStateContentAccess().getVerticalLineVerticalLineKeyword_1_4_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_Group_1_4_1(parent, this, 0, inst);
			case 1: return new StateContent_InnerStatesAssignment_1_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parallelStates+=State
protected class StateContent_ParallelStatesAssignment_1_4_1_1 extends AssignmentToken  {
	
	public StateContent_ParallelStatesAssignment_1_4_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStateContentAccess().getParallelStatesAssignment_1_4_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new State_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parallelStates",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parallelStates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStateRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateContentAccess().getParallelStatesStateParserRuleCall_1_4_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateContent_VerticalLineVerticalLineKeyword_1_4_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




// "}"
protected class StateContent_RightCurlyBracketKeyword_2 extends KeywordToken  {
	
	public StateContent_RightCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getStateContentAccess().getRightCurlyBracketKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateContent_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule StateContent ****************/


/************ begin Rule EntryAction ****************
 *
 * EntryAction returns Action:
 *   "onentry" trigger=PrimaryExpression? ("/" effects+=Effect*)?;  
 * ////Effect:
 * ////	effectID=STRING
 * ////;
 *     // transitionlabel::Action :
 * 	          //do we need both in one list: triggersAndEffects?
 *
 **/

// "onentry" trigger=PrimaryExpression? ("/" effects+=Effect*)? // transitionlabel::Action :
protected class EntryAction_Group extends GroupToken {
	
	public EntryAction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEntryActionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EntryAction_Group_2(parent, this, 0, inst);
			case 1: return new EntryAction_TriggerAssignment_1(parent, this, 1, inst);
			case 2: return new EntryAction_OnentryKeyword_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEntryActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "onentry" // transitionlabel::Action :
protected class EntryAction_OnentryKeyword_0 extends KeywordToken  {
	
	public EntryAction_OnentryKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntryActionAccess().getOnentryKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// trigger=PrimaryExpression?
protected class EntryAction_TriggerAssignment_1 extends AssignmentToken  {
	
	public EntryAction_TriggerAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEntryActionAccess().getTriggerAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("trigger",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEntryActionAccess().getTriggerPrimaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EntryAction_OnentryKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("/" effects+=Effect*)?
protected class EntryAction_Group_2 extends GroupToken {
	
	public EntryAction_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEntryActionAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EntryAction_EffectsAssignment_2_1(parent, this, 0, inst);
			case 1: return new EntryAction_SolidusKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class EntryAction_SolidusKeyword_2_0 extends KeywordToken  {
	
	public EntryAction_SolidusKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntryActionAccess().getSolidusKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EntryAction_TriggerAssignment_1(parent, this, 0, inst);
			case 1: return new EntryAction_OnentryKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// effects+=Effect*
protected class EntryAction_EffectsAssignment_2_1 extends AssignmentToken  {
	
	public EntryAction_EffectsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEntryActionAccess().getEffectsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("effects",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEntryActionAccess().getEffectsEffectParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EntryAction_EffectsAssignment_2_1(parent, next, actIndex, consumed);
			case 1: return new EntryAction_SolidusKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EntryAction ****************/


/************ begin Rule ExitAction ****************
 *
 * ExitAction returns Action:
 *   "onexit" trigger=PrimaryExpression? ("/" effects+=Effect*)?;    //do we need both in one list: triggersAndEffects?
 *
 **/

// "onexit" trigger=PrimaryExpression? ("/" effects+=Effect*)?
protected class ExitAction_Group extends GroupToken {
	
	public ExitAction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getExitActionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExitAction_Group_2(parent, this, 0, inst);
			case 1: return new ExitAction_TriggerAssignment_1(parent, this, 1, inst);
			case 2: return new ExitAction_OnexitKeyword_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExitActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "onexit"
protected class ExitAction_OnexitKeyword_0 extends KeywordToken  {
	
	public ExitAction_OnexitKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExitActionAccess().getOnexitKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// trigger=PrimaryExpression?
protected class ExitAction_TriggerAssignment_1 extends AssignmentToken  {
	
	public ExitAction_TriggerAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getExitActionAccess().getTriggerAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("trigger",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExitActionAccess().getTriggerPrimaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExitAction_OnexitKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("/" effects+=Effect*)?
protected class ExitAction_Group_2 extends GroupToken {
	
	public ExitAction_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getExitActionAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExitAction_EffectsAssignment_2_1(parent, this, 0, inst);
			case 1: return new ExitAction_SolidusKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class ExitAction_SolidusKeyword_2_0 extends KeywordToken  {
	
	public ExitAction_SolidusKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExitActionAccess().getSolidusKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExitAction_TriggerAssignment_1(parent, this, 0, inst);
			case 1: return new ExitAction_OnexitKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// effects+=Effect*
protected class ExitAction_EffectsAssignment_2_1 extends AssignmentToken  {
	
	public ExitAction_EffectsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getExitActionAccess().getEffectsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("effects",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExitActionAccess().getEffectsEffectParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExitAction_EffectsAssignment_2_1(parent, next, actIndex, consumed);
			case 1: return new ExitAction_SolidusKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ExitAction ****************/


/************ begin Rule InnerAction ****************
 *
 * InnerAction returns Action:
 *   "oninner" trigger=PrimaryExpression? ("/" effects+=Effect*)?;  
 * 
 *       
 * 	       
 * 
 * //ValuedObject:
 * //	Signal | Variable
 * //;
 * //Signal:
 * //	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
 * //	type=ValueType name=ID (':=' initialValue=ID)? 
 * //	//combineOperator=CombineOperator 
 * //;
 * ////enum CombineOperator :
 * ////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
 * ////;
 * //Variable:
 * //	type=ValueType name=ID (':=' initialValue=ID)? 
 * //;
 * //enum ValueType:
 * //	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
 * //;
 *
 **/

// "oninner" trigger=PrimaryExpression? ("/" effects+=Effect*)?
protected class InnerAction_Group extends GroupToken {
	
	public InnerAction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getInnerActionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InnerAction_Group_2(parent, this, 0, inst);
			case 1: return new InnerAction_TriggerAssignment_1(parent, this, 1, inst);
			case 2: return new InnerAction_OninnerKeyword_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInnerActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "oninner"
protected class InnerAction_OninnerKeyword_0 extends KeywordToken  {
	
	public InnerAction_OninnerKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInnerActionAccess().getOninnerKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// trigger=PrimaryExpression?
protected class InnerAction_TriggerAssignment_1 extends AssignmentToken  {
	
	public InnerAction_TriggerAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInnerActionAccess().getTriggerAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("trigger",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInnerActionAccess().getTriggerPrimaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InnerAction_OninnerKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("/" effects+=Effect*)?
protected class InnerAction_Group_2 extends GroupToken {
	
	public InnerAction_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getInnerActionAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InnerAction_EffectsAssignment_2_1(parent, this, 0, inst);
			case 1: return new InnerAction_SolidusKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class InnerAction_SolidusKeyword_2_0 extends KeywordToken  {
	
	public InnerAction_SolidusKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInnerActionAccess().getSolidusKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InnerAction_TriggerAssignment_1(parent, this, 0, inst);
			case 1: return new InnerAction_OninnerKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// effects+=Effect*
protected class InnerAction_EffectsAssignment_2_1 extends AssignmentToken  {
	
	public InnerAction_EffectsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInnerActionAccess().getEffectsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("effects",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInnerActionAccess().getEffectsEffectParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InnerAction_EffectsAssignment_2_1(parent, next, actIndex, consumed);
			case 1: return new InnerAction_SolidusKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule InnerAction ****************/


/************ begin Rule Transition ****************
 *
 * Transition:
 *   sourceStateName=ID? transitionType=TransitionType (targetStateName=ID|
 *   declaredTargetState=declaredTargetState) ("with" transitionLabel=[Action])?;  
 * 
 * //ValuedObject:
 * //	Signal | Variable
 * //;
 * //Signal:
 * //	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
 * //	type=ValueType name=ID (':=' initialValue=ID)? 
 * //	//combineOperator=CombineOperator 
 * //;
 * ////enum CombineOperator :
 * ////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
 * ////;
 * //Variable:
 * //	type=ValueType name=ID (':=' initialValue=ID)? 
 * //;
 * //enum ValueType:
 * //	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
 * //;	
 * 
 * 	 
 * 	 
 * 	      
 * 	  
 * //			(isHistory?='history')?
 * //			
 * //		( 	(delay=INT) (trigger=ID)
 * ////		|	(delay=INT) ('/'effects+=ID)				
 * //		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
 * //		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
 * //		|   ((trigger=ID) | ('/'effects+=ID))
 * //		| 	(trigger=ID) ('/'effects+=ID)
 * //		)	
 * //)?
 *
 **/

// sourceStateName=ID? transitionType=TransitionType (targetStateName=ID|
// declaredTargetState=declaredTargetState) ("with" transitionLabel=[Action])? 
// 	 
// 	 
// 	      
// 	  
// //			(isHistory?='history')?
// //			
// //		( 	(delay=INT) (trigger=ID)
// ////		|	(delay=INT) ('/'effects+=ID)				
// //		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
// //		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
// //		|   ((trigger=ID) | ('/'effects+=ID))
// //		| 	(trigger=ID) ('/'effects+=ID)
// //		)	
// //)?
protected class Transition_Group extends GroupToken {
	
	public Transition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTransitionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_Group_3(parent, this, 0, inst);
			case 1: return new Transition_Alternatives_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTransitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// sourceStateName=ID?
protected class Transition_SourceStateNameAssignment_0 extends AssignmentToken  {
	
	public Transition_SourceStateNameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getSourceStateNameAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("sourceStateName",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("sourceStateName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTransitionAccess().getSourceStateNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// transitionType=TransitionType
protected class Transition_TransitionTypeAssignment_1 extends AssignmentToken  {
	
	public Transition_TransitionTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getTransitionTypeAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_SourceStateNameAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("transitionType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("transitionType");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getTransitionAccess().getTransitionTypeTransitionTypeEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// targetStateName=ID|declaredTargetState=declaredTargetState
protected class Transition_Alternatives_2 extends AlternativesToken {

	public Transition_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTransitionAccess().getAlternatives_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_TargetStateNameAssignment_2_0(parent, this, 0, inst);
			case 1: return new Transition_DeclaredTargetStateAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// targetStateName=ID
protected class Transition_TargetStateNameAssignment_2_0 extends AssignmentToken  {
	
	public Transition_TargetStateNameAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getTargetStateNameAssignment_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_TransitionTypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("targetStateName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("targetStateName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTransitionAccess().getTargetStateNameIDTerminalRuleCall_2_0_0();
			return obj;
		}
		return null;
	}

}

// declaredTargetState=declaredTargetState
protected class Transition_DeclaredTargetStateAssignment_2_1 extends AssignmentToken  {
	
	public Transition_DeclaredTargetStateAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getDeclaredTargetStateAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredTargetState_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaredTargetState",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaredTargetState");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredTargetStateRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTransitionAccess().getDeclaredTargetStateDeclaredTargetStateParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Transition_TransitionTypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ("with" transitionLabel=[Action])?
protected class Transition_Group_3 extends GroupToken {
	
	public Transition_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTransitionAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_TransitionLabelAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "with"
protected class Transition_WithKeyword_3_0 extends KeywordToken  {
	
	public Transition_WithKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTransitionAccess().getWithKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_Alternatives_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// transitionLabel=[Action]
protected class Transition_TransitionLabelAssignment_3_1 extends AssignmentToken  {
	
	public Transition_TransitionLabelAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransitionAccess().getTransitionLabelAssignment_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transition_WithKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("transitionLabel",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("transitionLabel");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTransitionAccess().getTransitionLabelActionCrossReference_3_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTransitionAccess().getTransitionLabelActionCrossReference_3_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



/************ end Rule Transition ****************/


/************ begin Rule declaredTargetState ****************
 *
 * declaredTargetState returns State:
 *   isInitial?="init"? isFinal?="final"? "state" declaredStateType=StateType?
 *   declaredStateName=ID; 	
 *     
 * 	     
 * 	  
 * 
 * 
 * //=======================================================================================================//
 *
 **/

// isInitial?="init"? isFinal?="final"? "state" declaredStateType=StateType?
// declaredStateName=ID
protected class DeclaredTargetState_Group extends GroupToken {
	
	public DeclaredTargetState_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getDeclaredTargetStateAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredTargetState_DeclaredStateNameAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaredTargetStateRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// isInitial?="init"?
protected class DeclaredTargetState_IsInitialAssignment_0 extends AssignmentToken  {
	
	public DeclaredTargetState_IsInitialAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredTargetStateAccess().getIsInitialAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isInitial",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isInitial");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getDeclaredTargetStateAccess().getIsInitialInitKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// isFinal?="final"?
protected class DeclaredTargetState_IsFinalAssignment_1 extends AssignmentToken  {
	
	public DeclaredTargetState_IsFinalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredTargetStateAccess().getIsFinalAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredTargetState_IsInitialAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isFinal",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isFinal");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getDeclaredTargetStateAccess().getIsFinalFinalKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// "state"
protected class DeclaredTargetState_StateKeyword_2 extends KeywordToken  {
	
	public DeclaredTargetState_StateKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclaredTargetStateAccess().getStateKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredTargetState_IsFinalAssignment_1(parent, this, 0, inst);
			case 1: return new DeclaredTargetState_IsInitialAssignment_0(parent, this, 1, inst);
			default: return parent.createParentFollower(this, index, index - 2, inst);
		}	
	}	
		
}

// declaredStateType=StateType?
protected class DeclaredTargetState_DeclaredStateTypeAssignment_3 extends AssignmentToken  {
	
	public DeclaredTargetState_DeclaredStateTypeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredTargetStateAccess().getDeclaredStateTypeAssignment_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredTargetState_StateKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaredStateType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaredStateType");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getDeclaredTargetStateAccess().getDeclaredStateTypeStateTypeEnumRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// declaredStateName=ID
protected class DeclaredTargetState_DeclaredStateNameAssignment_4 extends AssignmentToken  {
	
	public DeclaredTargetState_DeclaredStateNameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredTargetStateAccess().getDeclaredStateNameAssignment_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredTargetState_DeclaredStateTypeAssignment_3(parent, this, 0, inst);
			case 1: return new DeclaredTargetState_StateKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaredStateName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaredStateName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDeclaredTargetStateAccess().getDeclaredStateNameIDTerminalRuleCall_4_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule declaredTargetState ****************/


/************ begin Rule Action ****************
 *
 * Action:
 *   trigger=PrimaryExpression? ("/" effects+=Effect*)?; 
 * 
 * //=======================================================================================================//
 *   
 * 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
 *
 **/

// trigger=PrimaryExpression? ("/" effects+=Effect*)? 
// 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
protected class Action_Group extends GroupToken {
	
	public Action_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group_1(parent, this, 0, inst);
			case 1: return new Action_TriggerAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// trigger=PrimaryExpression?
protected class Action_TriggerAssignment_0 extends AssignmentToken  {
	
	public Action_TriggerAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTriggerAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("trigger",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getTriggerPrimaryExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("/" effects+=Effect*)?
protected class Action_Group_1 extends GroupToken {
	
	public Action_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_EffectsAssignment_1_1(parent, this, 0, inst);
			case 1: return new Action_SolidusKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class Action_SolidusKeyword_1_0 extends KeywordToken  {
	
	public Action_SolidusKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getSolidusKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_TriggerAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// effects+=Effect*
protected class Action_EffectsAssignment_1_1 extends AssignmentToken  {
	
	public Action_EffectsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getEffectsAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("effects",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getEffectsEffectParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_EffectsAssignment_1_1(parent, next, actIndex, consumed);
			case 1: return new Action_SolidusKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Action ****************/


/************ begin Rule Effect ****************
 *
 * Effect:
 *   Emission|Assignment|HostCode;
 *
 **/

// Emission|Assignment|HostCode
protected class Effect_Alternatives extends AlternativesToken {

	public Effect_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getEffectAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_EmissionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Effect_AssignmentParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Effect_HostCodeParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Emission
protected class Effect_EmissionParserRuleCall_0 extends RuleCallToken {
	
	public Effect_EmissionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getEmissionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Emission_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEmissionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Assignment
protected class Effect_AssignmentParserRuleCall_1 extends RuleCallToken {
	
	public Effect_AssignmentParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getAssignmentParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// HostCode
protected class Effect_HostCodeParserRuleCall_2 extends RuleCallToken {
	
	public Effect_HostCodeParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getHostCodeParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HostCode_CodeAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(HostCode_CodeAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getHostCodeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Effect ****************/


/************ begin Rule Emission ****************
 *
 * Emission:
 *   signal=[Signal] ("(" newValue=PrimaryExpression ")")?;
 *
 **/

// signal=[Signal] ("(" newValue=PrimaryExpression ")")?
protected class Emission_Group extends GroupToken {
	
	public Emission_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_Group_1(parent, this, 0, inst);
			case 1: return new Emission_SignalAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEmissionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signal=[Signal]
protected class Emission_SignalAssignment_0 extends AssignmentToken  {
	
	public Emission_SignalAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getSignalAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" newValue=PrimaryExpression ")")?
protected class Emission_Group_1 extends GroupToken {
	
	public Emission_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Emission_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public Emission_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getLeftParenthesisKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_SignalAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// newValue=PrimaryExpression
protected class Emission_NewValueAssignment_1_1 extends AssignmentToken  {
	
	public Emission_NewValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getNewValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("newValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEmissionAccess().getNewValuePrimaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Emission_LeftParenthesisKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Emission_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public Emission_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getRightParenthesisKeyword_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_NewValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Emission ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment:
 *   variable=[Variable] ":=" expression=PrimaryExpression;
 *
 **/

// variable=[Variable] ":=" expression=PrimaryExpression
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_ExpressionAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// variable=[Variable]
protected class Assignment_VariableAssignment_0 extends AssignmentToken  {
	
	public Assignment_VariableAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getVariableAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ":="
protected class Assignment_ColonEqualsSignKeyword_1 extends KeywordToken  {
	
	public Assignment_ColonEqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getColonEqualsSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_VariableAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expression=PrimaryExpression
protected class Assignment_ExpressionAssignment_2 extends AssignmentToken  {
	
	public Assignment_ExpressionAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getExpressionAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getExpressionPrimaryExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_ColonEqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Assignment ****************/


/************ begin Rule SignalReference ****************
 *
 * SignalReference:
 *   reference=[Signal];
 *
 **/

// reference=[Signal]
protected class SignalReference_ReferenceAssignment extends AssignmentToken  {
	
	public SignalReference_ReferenceAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getReferenceAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reference",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reference");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceAccess().getReferenceSignalCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSignalReferenceAccess().getReferenceSignalCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule SignalReference ****************/


/************ begin Rule VariableReference ****************
 *
 * VariableReference:
 *   reference=[Variable];
 *
 **/

// reference=[Variable]
protected class VariableReference_ReferenceAssignment extends AssignmentToken  {
	
	public VariableReference_ReferenceAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getReferenceAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reference",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reference");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableReferenceAccess().getReferenceVariableCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getVariableReferenceAccess().getReferenceVariableCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule VariableReference ****************/


/************ begin Rule ValuedObject ****************
 *
 * ValuedObject:
 *   Signal|Variable;
 *
 **/

// Signal|Variable
protected class ValuedObject_Alternatives extends AlternativesToken {

	public ValuedObject_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValuedObjectAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValuedObject_SignalParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ValuedObject_VariableParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValuedObjectRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Signal
protected class ValuedObject_SignalParserRuleCall_0 extends RuleCallToken {
	
	public ValuedObject_SignalParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValuedObjectAccess().getSignalParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Signal_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Variable
protected class ValuedObject_VariableParserRuleCall_1 extends RuleCallToken {
	
	public ValuedObject_VariableParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValuedObjectAccess().getVariableParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Variable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ValuedObject ****************/


/************ begin Rule Signal ****************
 *
 * Signal:
 *   "input" name=ID (":=" initialValue=ID)? ";";
 *
 **/

// "input" name=ID (":=" initialValue=ID)? ";"
protected class Signal_Group extends GroupToken {
	
	public Signal_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_SemicolonKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "input"
protected class Signal_InputKeyword_0 extends KeywordToken  {
	
	public Signal_InputKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getInputKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_1 extends AssignmentToken  {
	
	public Signal_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InputKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// (":=" initialValue=ID)?
protected class Signal_Group_2 extends GroupToken {
	
	public Signal_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InitialValueAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Signal_ColonEqualsSignKeyword_2_0 extends KeywordToken  {
	
	public Signal_ColonEqualsSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getColonEqualsSignKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=ID
protected class Signal_InitialValueAssignment_2_1 extends AssignmentToken  {
	
	public Signal_InitialValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getInitialValueAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_ColonEqualsSignKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getInitialValueIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// ";"
protected class Signal_SemicolonKeyword_3 extends KeywordToken  {
	
	public Signal_SemicolonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getSemicolonKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_2(parent, this, 0, inst);
			case 1: return new Signal_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Signal ****************/


/************ begin Rule Variable ****************
 *
 * Variable:
 *   "var" name=ID (":=" initialValue=ID)? ";";
 *
 **/

// "var" name=ID (":=" initialValue=ID)? ";"
protected class Variable_Group extends GroupToken {
	
	public Variable_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_SemicolonKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "var"
protected class Variable_VarKeyword_0 extends KeywordToken  {
	
	public Variable_VarKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getVarKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Variable_NameAssignment_1 extends AssignmentToken  {
	
	public Variable_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_VarKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// (":=" initialValue=ID)?
protected class Variable_Group_2 extends GroupToken {
	
	public Variable_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_InitialValueAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Variable_ColonEqualsSignKeyword_2_0 extends KeywordToken  {
	
	public Variable_ColonEqualsSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getColonEqualsSignKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=ID
protected class Variable_InitialValueAssignment_2_1 extends AssignmentToken  {
	
	public Variable_InitialValueAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getInitialValueAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_ColonEqualsSignKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getInitialValueIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// ";"
protected class Variable_SemicolonKeyword_3 extends KeywordToken  {
	
	public Variable_SemicolonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getSemicolonKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group_2(parent, this, 0, inst);
			case 1: return new Variable_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Variable ****************/


/************ begin Rule IntValue ****************
 *
 * IntValue:
 *   value=INT;
 *
 **/

// value=INT
protected class IntValue_ValueAssignment extends AssignmentToken  {
	
	public IntValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getIntValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntValue ****************/


/************ begin Rule FloatValue ****************
 *
 * FloatValue:
 *   value=Float;
 *
 **/

// value=Float
protected class FloatValue_ValueAssignment extends AssignmentToken  {
	
	public FloatValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFloatValueAccess().getValueFloatTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule FloatValue ****************/


/************ begin Rule BooleanValue ****************
 *
 * BooleanValue:
 *   value=Boolean;
 *
 **/

// value=Boolean
protected class BooleanValue_ValueAssignment extends AssignmentToken  {
	
	public BooleanValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBooleanValueAccess().getValueBooleanTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanValue ****************/


/************ begin Rule Value ****************
 *
 * Value:
 *   IntValue|FloatValue|BooleanValue; 
 * 
 * 	        
 * 
 * // make sure the Float rule does not shadow the built-in INT rule
 *
 **/

// IntValue|FloatValue|BooleanValue 
// 
// 	        
// 
// // make sure the Float rule does not shadow the built-in INT rule
protected class Value_Alternatives extends AlternativesToken {

	public Value_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Value_IntValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Value_FloatValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Value_BooleanValueParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntValue
protected class Value_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public Value_IntValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getIntValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class Value_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public Value_FloatValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getFloatValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FloatValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanValue
protected class Value_BooleanValueParserRuleCall_2 extends RuleCallToken {
	
	public Value_BooleanValueParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getBooleanValueParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Value ****************/


/************ begin Rule HostCode ****************
 *
 * HostCode:
 *   code=STRING; 
 * 
 * 
 * 	//"'"code=STRING"'";
 * 	 //("(" type=ID ")")?
 *
 **/

// code=STRING 
// 	//"'"code=STRING"'";
// 	 //("(" type=ID ")")?
protected class HostCode_CodeAssignment extends AssignmentToken  {
	
	public HostCode_CodeAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getCodeAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHostCodeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("code",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("code");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getHostCodeAccess().getCodeSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule HostCode ****************/


/************ begin Rule Operator ****************
 *
 * Operator:
 *   operatorKind=OperatorKind;
 *
 **/

// operatorKind=OperatorKind
protected class Operator_OperatorKindAssignment extends AssignmentToken  {
	
	public Operator_OperatorKindAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOperatorAccess().getOperatorKindAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOperatorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operatorKind",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operatorKind");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getOperatorAccess().getOperatorKindOperatorKindEnumRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Operator ****************/


/************ begin Rule ValOperation ****************
 *
 * ValOperation returns Expression:
 *   operator=ValOperator subExpressions+=SignalReference;
 *
 **/

// operator=ValOperator subExpressions+=SignalReference
protected class ValOperation_Group extends GroupToken {
	
	public ValOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getValOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=ValOperator
protected class ValOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public ValOperation_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getValOperationAccess().getOperatorValOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=SignalReference
protected class ValOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public ValOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getValOperationAccess().getSubExpressionsSignalReferenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValOperation_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ValOperation ****************/


/************ begin Rule ValueExpression ****************
 *
 * ValueExpression returns Expression:
 *   IntValue|FloatValue|ValOperation|VariableReference;
 *
 **/

// IntValue|FloatValue|ValOperation|VariableReference
protected class ValueExpression_Alternatives extends AlternativesToken {

	public ValueExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_IntValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ValueExpression_FloatValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new ValueExpression_ValOperationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new ValueExpression_VariableReferenceParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntValue
protected class ValueExpression_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public ValueExpression_IntValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getIntValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class ValueExpression_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public ValueExpression_FloatValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getFloatValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FloatValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ValOperation
protected class ValueExpression_ValOperationParserRuleCall_2 extends RuleCallToken {
	
	public ValueExpression_ValOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getValOperationParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VariableReference
protected class ValueExpression_VariableReferenceParserRuleCall_3 extends RuleCallToken {
	
	public ValueExpression_VariableReferenceParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getVariableReferenceParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableReference_ReferenceAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ValueExpression ****************/


/************ begin Rule CompareOperation ****************
 *
 * CompareOperation returns Expression:
 *   ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator
 *   subExpressions+=ValueExpression);
 *
 **/

// ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator
// subExpressions+=ValueExpression)
protected class CompareOperation_Group extends GroupToken {
	
	public CompareOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompareOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ValueExpression
protected class CompareOperation_ValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public CompareOperation_ValueExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getValueExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValueExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// {Operation.subExpressions+=current} operator=CompareOperator subExpressions+=
// ValueExpression
protected class CompareOperation_Group_1 extends GroupToken {
	
	public CompareOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class CompareOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public CompareOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_ValueExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompareOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator=CompareOperator
protected class CompareOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public CompareOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getCompareOperationAccess().getOperatorCompareOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=ValueExpression
protected class CompareOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public CompareOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompareOperationAccess().getSubExpressionsValueExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompareOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CompareOperation ****************/


/************ begin Rule NotOperation ****************
 *
 * NotOperation returns Operations:
 *   operators=NotOperator subExpressions+=BooleanExpression;
 *
 **/

// operators=NotOperator subExpressions+=BooleanExpression
protected class NotOperation_Group extends GroupToken {
	
	public NotOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operators=NotOperator
protected class NotOperation_OperatorsAssignment_0 extends AssignmentToken  {
	
	public NotOperation_OperatorsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getOperatorsAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operators",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operators");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getNotOperationAccess().getOperatorsNotOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=BooleanExpression
protected class NotOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public NotOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNotOperationAccess().getSubExpressionsBooleanExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NotOperation_OperatorsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NotOperation ****************/


/************ begin Rule NotOrNormalExpression ****************
 *
 * NotOrNormalExpression returns Expression:
 *   NotOperation|BooleanExpression;
 *
 **/

// NotOperation|BooleanExpression
protected class NotOrNormalExpression_Alternatives extends AlternativesToken {

	public NotOrNormalExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_NotOperationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new NotOrNormalExpression_BooleanExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOperation
protected class NotOrNormalExpression_NotOperationParserRuleCall_0 extends RuleCallToken {
	
	public NotOrNormalExpression_NotOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getNotOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanExpression
protected class NotOrNormalExpression_BooleanExpressionParserRuleCall_1 extends RuleCallToken {
	
	public NotOrNormalExpression_BooleanExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getBooleanExpressionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NotOrNormalExpression ****************/


/************ begin Rule AndOperation ****************
 *
 * AndOperation returns Expression:
 *   NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd
 *   subExpression+=NotOrNormalExpression)*;
 *
 **/

// NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd
// subExpression+=NotOrNormalExpression)*
protected class AndOperation_Group extends GroupToken {
	
	public AndOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOrNormalExpression
protected class AndOperation_NotOrNormalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndOperation_NotOrNormalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getNotOrNormalExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOrNormalExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=
// NotOrNormalExpression)*
protected class AndOperation_Group_1 extends GroupToken {
	
	public AndOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_SubExpressionAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpression+=current}
protected class AndOperation_OperationSubExpressionAction_1_0 extends ActionToken  {

	public AndOperation_OperationSubExpressionAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperationSubExpressionAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationAccess().getOperationSubExpressionAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpression", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpression")) return null;
		return getDescr((EObject) val);
	}
}

// operator=OperatorAnd
protected class AndOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_OperationSubExpressionAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getAndOperationAccess().getOperatorOperatorAndEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpression+=NotOrNormalExpression
protected class AndOperation_SubExpressionAssignment_1_2 extends AssignmentToken  {
	
	public AndOperation_SubExpressionAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getSubExpressionAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndOperationAccess().getSubExpressionNotOrNormalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndOperation ****************/


/************ begin Rule OrOperation ****************
 *
 * OrOperation returns Expression:
 *   AndOperation ({Operation.subExpressions+=current} operator=OperatorOr
 *   subExpressions+=AndOperation)*; 
 * 
 *     
 * 	      
 * 
 * // TODO: get rid of parentheses
 *
 **/

// AndOperation ({Operation.subExpressions+=current} operator=OperatorOr
// subExpressions+=AndOperation)*
protected class OrOperation_Group extends GroupToken {
	
	public OrOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndOperation
protected class OrOperation_AndOperationParserRuleCall_0 extends RuleCallToken {
	
	public OrOperation_AndOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getAndOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=
// AndOperation)*
protected class OrOperation_Group_1 extends GroupToken {
	
	public OrOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class OrOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public OrOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator=OperatorOr
protected class OrOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getOrOperationAccess().getOperatorOperatorOrEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=AndOperation
protected class OrOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public OrOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrOperationAccess().getSubExpressionsAndOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrOperation ****************/


/************ begin Rule BooleanExpression ****************
 *
 * BooleanExpression returns Expression:
 *   BooleanValue|SignalReference|CompareOperation|"(" OrOperation ")"; 
 * 
 * // TODO: get rid of parentheses
 *
 **/

// BooleanValue|SignalReference|CompareOperation|"(" OrOperation ")" 
// 
// // TODO: get rid of parentheses
protected class BooleanExpression_Alternatives extends AlternativesToken {

	public BooleanExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_BooleanValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new BooleanExpression_SignalReferenceParserRuleCall_1(parent, this, 1, inst);
			case 2: return new BooleanExpression_CompareOperationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new BooleanExpression_Group_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BooleanValue
protected class BooleanExpression_BooleanValueParserRuleCall_0 extends RuleCallToken {
	
	public BooleanExpression_BooleanValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getBooleanValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SignalReference
protected class BooleanExpression_SignalReferenceParserRuleCall_1 extends RuleCallToken {
	
	public BooleanExpression_SignalReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getSignalReferenceParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SignalReference_ReferenceAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CompareOperation
protected class BooleanExpression_CompareOperationParserRuleCall_2 extends RuleCallToken {
	
	public BooleanExpression_CompareOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getCompareOperationParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CompareOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCompareOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "(" OrOperation ")"
protected class BooleanExpression_Group_3 extends GroupToken {
	
	public BooleanExpression_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_RightParenthesisKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class BooleanExpression_LeftParenthesisKeyword_3_0 extends KeywordToken  {
	
	public BooleanExpression_LeftParenthesisKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getLeftParenthesisKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// OrOperation
protected class BooleanExpression_OrOperationParserRuleCall_3_1 extends RuleCallToken {
	
	public BooleanExpression_OrOperationParserRuleCall_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getOrOperationParserRuleCall_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_LeftParenthesisKeyword_3_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class BooleanExpression_RightParenthesisKeyword_3_2 extends KeywordToken  {
	
	public BooleanExpression_RightParenthesisKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getRightParenthesisKeyword_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule BooleanExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns Expression:
 *   BooleanExpression; 
 * 
 *     
 * 	//ValueExpression | BooleanExpression;
 *
 **/

// BooleanExpression 
// 	//ValueExpression | BooleanExpression;
protected class PrimaryExpression_BooleanExpressionParserRuleCall extends RuleCallToken {
	
	public PrimaryExpression_BooleanExpressionParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBooleanExpressionParserRuleCall();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule PrimaryExpression ****************/

}
