import kaom;
import annotations;
import ecore;

extension org::eclipse::xtend::util::stdlib::io;          // debug printouts 
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
//extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
//extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
//extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)


Void flatten(Entity entity):
	let parent = entity.eContainer:
		entity.childPorts.incomingLinks.moveFlattenIncomingLink(entity.childEntities, (Entity)parent, entity) ->
		entity.childPorts.outgoingLinks.moveFlattenOutgoingLink(entity.childEntities,  (Entity)parent, entity) ->
		parent.childEntities.addAll(entity.childEntities) ->
		parent.childLinks.addAll(entity.childLinks) ->
		entity.childPorts.removePort() ->
		//debuginfo(entity.childPorts.getReferencingObjects()) ->
		parent.childEntities.remove(entity)
;

Void removePort(Port port):
	port.incomingLinks
;

Void moveFlattenOutgoingLink(Link link, List[Entity] innerEntities, Entity parent, Entity entity):
	if (!innerEntities.contains(link.target) && !innerEntities.childPorts.contains(link.target)) then (
		let sourcePort = link.source.incomingLinks.get(0).source :
		link.source.incomingLinks.remove(link) ->
		link.setSource(sourcePort) ->
		sourcePort.outgoingLinks.add(link)
	) else (
		link.eContainer.childLinks.remove(link)
	)
;

Void moveFlattenIncomingLink(Link link, List[Entity] innerEntities, Entity parent, Entity entity):	
	if (!innerEntities.contains(link.source) && !innerEntities.childPorts.contains(link.source)) then (
		let targetPort = link.target.outgoingLinks.get(0).target :
		link.target.outgoingLinks.remove(link) ->
		targetPort.incomingLinks.add(link) ->
		link.setTarget(targetPort)	
	) else (
		//link.source.outgoingLinks.remove(link)
		//link.target.incomingLinks.remove(link)->
		//debuginfo(link.getReferencingObjects())->
		link.eContainer.childLinks.remove(link)
	)
;

Void capsulate(List[Entity] target, List[Link] links, List[Port] ports):
	capsulate(target)
;

Void capsulate(List[Entity] target, List[Link] links):
	capsulate(target)
;

Void addStringAnnotation(Annotatable annotatable, String key, String value) :
    let annotation = new StringAnnotation :
    if (hasAnnotation(annotatable, key) == false)
        then (
		    annotation.setName(key) ->
		    annotation.setValue(value) ->
		    annotatable.annotations.add(annotation)
        )
        else null
;

Void addReferenceAnnotation(Annotatable annotatable, String key, Object value) :
    //let annotation = new ReferenceAnnotation :
    //if (hasAnnotation(annotatable, key) == false)
    //    then (
	//	    annotation.setName(key) ->
	//	    annotation.setObject(value) ->
	//	    annotatable.annotations.add(annotation)
    //    )
    //    else null
    JAVA de.cau.cs.kieler.kaom.ksbase.ptolemy.XtendUtils.addReferenceAnnotation(de.cau.cs.kieler.core.annotations.Annotatable, java.lang.String, java.lang.Object)
;

Void capsulate(List[Entity] target):
 let newEntity = new Entity:
 if (target.eContainer != null) then (
 	target.get(0).eContainer.childEntities.add(newEntity)->
 	target.moveTo(newEntity)->
 	target.outgoingLinks.moveOutgoingConnection(target, newEntity)->
 	target.childPorts.outgoingLinks.moveOutgoingConnection(target, newEntity)->
 	target.incomingLinks.moveIncomingConnection(target, newEntity)->
 	target.childPorts.incomingLinks.moveIncomingConnection(target, newEntity) ->
 	addStringAnnotation((Annotatable)newEntity, "language", "ptolemy") ->
 	addStringAnnotation((Annotatable)newEntity, "capsuleType", "withoutPorts")
 )
;

Void moveTo(Entity entity, Entity parent):
	entity.eContainer.childEntities.remove(entity) ->
	parent.childEntities.add(entity)
;

Void moveOutgoingConnection(Link link, List[Entity] innerEntities, Entity parent):
	if (!innerEntities.contains(link.target) && !innerEntities.childPorts.contains(link.target)) then (
		let newPort = new Port:
		let oldSource = link.source:
		let newConnection = new Link:
			parent.childPorts.add(newPort) ->
			addReferenceAnnotation((Annotatable)newConnection, "oldTarget", newPort) ->
			link.setSource(newPort) ->
			newPort.outgoingLinks.add(link) ->
			newPort.setName("inputPort") ->
			newConnection.setSource(oldSource) ->
			newConnection.setTarget(newPort) ->
			newPort.incomingLinks.add(newConnection) ->
			oldSource.outgoingLinks.add(newConnection) -> 
			parent.childLinks.add(newConnection) ->
			addStringAnnotation((Annotatable)newConnection, "language", "ptolemy")
	)
;

Void moveIncomingConnection(Link link, List[Entity] innerEntities, Entity parent):
	if (!innerEntities.contains(link.source) && !innerEntities.childPorts.contains(link.source)) then (
		let newPort = new Port:
		let oldTarget = link.target:
		let newConnection = new Link:
			parent.childPorts.add(newPort) ->
			addReferenceAnnotation((Annotatable)newConnection, "oldSource", newPort) ->
			link.setTarget(newPort) ->
			newPort.incomingLinks.add(link) ->
			newPort.setName("outputPort") ->
			newConnection.setSource(newPort) ->
			newConnection.setTarget(oldTarget) ->
			newPort.outgoingLinks.add(newConnection) ->
			oldTarget.incomingLinks.add(newConnection) ->
			parent.childLinks.add(newConnection) ->
			addStringAnnotation((Annotatable)newConnection, "language", "ptolemy")
	)
;

Boolean hasAnnotation(Annotatable annotatable, String key) :
    (annotatable.getAnnotation(key) != null)
;

Void toggleInputOutput(Entity entity) :
	if (!entity.hasAnnotation("capsuleType") || ((StringAnnotation)entity.getAnnotation("capsuleType")).value == "withoutPorts") then ( 
		entity.childPorts.outgoingLinks.moveLinkToInput(entity.childEntities, entity) ->
		entity.childPorts.incomingLinks.moveLinkToOutput(entity.childEntities, entity) ->
		if (!entity.hasAnnotation("capsuleType")) then (
			addStringAnnotation(entity, "capsuleType", "withPorts")
		) else (
			((StringAnnotation)entity.getAnnotation("capsuleType")).setValue("withPorts")
		)
	)
	else ( 
		entity.childEntities.select(e|((e.hasAnnotation("type")) && (((StringAnnotation)e.getAnnotation("type")).value == "inputPort"))).outgoingLinks.moveLinkToInputPort() ->
		entity.childEntities.select(e|((e.hasAnnotation("type")) && (((StringAnnotation)e.getAnnotation("type")).value == "outputPort"))).incomingLinks.moveLinkToOutputPort() ->
		if (!entity.hasAnnotation("capsuleType")) then (
			addStringAnnotation(entity, "capsuleType", "withoutPorts")
		) else (
			((StringAnnotation)entity.getAnnotation("capsuleType")).setValue("withoutPorts")
		)
	)
;

Void moveLinkToInputPort(Link link) :
	let oldSource = link.source:
	let newSource = ((ReferenceAnnotation)link.getAnnotation("oldSource")).object:
	//debuginfo((Linkable)((ReferenceAnnotation)link.getAnnotation("oldSource")).object) ->
	oldSource.childLinks.remove(link) ->
	oldSource.eContainer.childLinks.add(link) ->
  	link.setSource(newSource) ->
  	newSource.outgoingLinks.add(link) ->
  	oldSource.outgoingLinks.remove(link) ->
  	oldSource.eContainer.childEntities.remove(oldSource)	
;

Void moveLinkToOutputPort(Link link) :
	let oldTarget = link.target:
	let newTarget = ((ReferenceAnnotation)link.getAnnotation("oldTarget")).object:
	//debuginfo((Linkable)((ReferenceAnnotation)link.getAnnotation("oldSource")).object) ->
  	link.setTarget(newTarget) ->
  	newTarget.incomingLinks.add(link) ->
  	oldTarget.incomingLinks.remove(link) ->
  	oldTarget.eContainer.childEntities.remove(oldTarget)	
;

Void debuginfo(Object obj) :
	JAVA de.cau.cs.kieler.kaom.ksbase.ptolemy.XtendUtils.debug(java.lang.Object)
;

Void moveLinkToInput(Link link, List[Entity] innerEntities, Entity parent) :
	if (innerEntities.contains(link.target) || innerEntities.childPorts.contains(link.target)) then (
		let inputPort = new Entity :
		parent.childEntities.add(inputPort) ->
		parent.childLinks.remove(link) ->
		inputPort.childLinks.add(link) ->
		link.source.outgoingLinks.remove(link) ->
		inputPort.outgoingLinks.add(link) ->
		link.setSource(inputPort) ->
		inputPort.setName("input") ->
		addStringAnnotation((Annotatable)inputPort, "language", "ptolemy") ->
		addStringAnnotation((Annotatable)inputPort, "type", "inputPort")
	)
;

Void moveLinkToOutput(Link link, List[Entity] innerEntities, Entity parent) :
	if (innerEntities.contains(link.source) || innerEntities.childPorts.contains(link.source)) then (
		let outputPort = new Entity :
		parent.childEntities.add(outputPort) ->
		link.target.incomingLinks.remove(link) ->
		outputPort.incomingLinks.add(link) ->
		link.setTarget(outputPort) ->
		outputPort.setName("output") ->
		addStringAnnotation((Annotatable)outputPort, "language", "ptolemy") ->
		addStringAnnotation((Annotatable)outputPort, "type", "outputPort")
	)
;
