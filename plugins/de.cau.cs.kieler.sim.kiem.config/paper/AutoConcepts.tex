\chapter{Concepts}
\label{section:AutoConcepts}
This chapter presents the conceptual solution to the problems described in Chapter \ref{chapter:AutoTask}.

It will follow the same structure to make it easier to follow. This means that the chapter will start
by offering a few possible options for the user to set up an automated execution. It will continue
by providing alternatives of how DataComponents receive the necessary information prior to each run.
The next section explains how the actual control flow throughout the automation will be handled.
In the last section some possibilities for user-friendly output are presented.

\section{Setting up a Run}
\label{section:AutoConceptsSetup}
There are several possibilities of how to solve the problem of accumulating
large amounts of information prior to a long running action.

The first possibility would be to have the user enter the paths to the 
necessary files in text files, parse those files and start a run with
the parsed information. While this is a good method for performing
static runs from a console environment it has several disadvantages
inside the \ac{GUI} of an Eclipse \ac{RCA}:
\begin{itemize}
 \item Manually entered file names in a text file are prone to have erroneous information.
It is very hard to manually enter the correct file name of any file and the entered location
only works on one \ac{OS}. Aside from that it takes a long time to manually enter the possible vast
amount of files used.
 \item There is no way to quickly adjust the file if other models or execution files should be used.
 \item It also means more files cluttering up the workspace.
 \item It is not very intuitive and the user has to know the exact syntax that the execution needs.
\end{itemize}

Another approach is the selection of the files through a dialog.
Here the first option is to write a new dialog from scratch. While this option
ensures flexibility since only the elements that are really needed are on it in
exactly the way they are needed there are still some disadvantages:
\begin{itemize}
 \item It involves a lot of work since every widget has to be manually placed on the dialog.
 \item It involves even more work to get the layout of the dialog just right.
\end{itemize}

A more comprehensive approach would be to use one of the dialogs provided by Eclipse specifically the wizard type dialog.
Eclipse itself uses a host of wizards as explained in Section \ref{section:AutoTechWizards}.
The wizard has several advantages over the other methods explained above:
\index{Wizard}
\begin{itemize}
 \item Even inexperienced users can be guided to set up a valid execution run.
 \item The entered information is most likely valid since the wizard only displays valid files.
 \item It is quicker to program and easier to adjust than any of the other methods.
\end{itemize}


\section{Input for the Automation}
\label{section:AutoConceptsInput}
\index{DataComponent}
In order to send information to the DataComponents\footnote{Section \ref{section:IntroDataComponent}}
the first decision must consider the form of the information that will be supplied.
The chosen form is that of a list of (key, value) pairs. This format supplies the greatest
flexibility while still being very generic and simple to read and write on.
This list of properties will at least include the path to the model file\footnote{Section \ref{section:IntroModelFile}} in order
for components to be executed with several different model files without having
to alter the code between runs.

The next decision involves how the components are getting the information.The first possibility 
would be to have the component ask the plug-in for the information
in question. The upside of this would be that components are sure to get all the information
they need before the execution can start since they can keep asking for it. However this would
likely mean that the component has to poll multiple times as it has no knowledge about when
the required information will be available which constitutes additional workload. Furthermore
this situation would likely mean that multiple components might request information
at the same time. This means that there would be the need for substantial synchronization mechanisms
to ensure consistency of data.

Therefore the way chosen in this thesis is that the Execution Manager will inform interested components
about all properties that were accumulated and then starts the execution run. This ensures
that a run is started in any event and keeps communication between the components and the manager simple.

\section{Automate the Execution}
\label{section:AutoConceptsExecution}
As a basic control flow for the automation the following procedure is chosen:
\begin{enumerate}
 \item The automation will iterate over all supplied execution files. These are likely the most time consuming
to load which means loading an execution file multiple times should be avoided.
 \item With each execution file the automation will iterate over all model files. Model files are costly to load
as well however each load of an execution file would mean that all DataComponents would not be able to store their
saved properties either way which in turn means they would have to reload the model anyway. For this reason the model
files will be loaded once for every execution file.
 \item With each model file the automation will perform multiple runs. That means starting a run in the execution manager
and performing a certain number of steps and the stopping the execution again. With each run the components get the chance
to execute a few steps with different properties, for example trace files. These runs will be called iterations from this
point forward.
\end{enumerate}

Automating the execution itself requires the plug-in to interact with the Execution Manager.
There is already an \ac{API} defined for loading an execution file by supplying a path so that
is what will be used in this project.
Then it is necessary to initialize the execution and step through it using the \ac{API}
methods provided in the Execution Manager. For this the EventListener extension point\footnote{Section \ref{section:EventListener}} of the 
Execution Manager can also be used in order to determine when a step has finished executing and
a new one can be dispatched.
After the execution is finished all components should be called again to be given
a chance to provide information for the display in the next step. This information
will be gathered in the same form and way as described in Section \ref{section:AutoConceptsInput}.

\section{Output Execution Results}
\label{section:AutoConceptsOutput}
On the subject of displaying the information several options are available.

The first option would be to open a dialog once the execution has finished
and display the results in a tabular manner. This has the advantage that the
users attention is immediately caught when the run finishes. However pop-up boxes
should be used only when something very important happens and only with small messages
as they tend to interrupt the users work flow. Aside from that the user might want
to look at the results from the execution and compare them with the actual model.
An opened dialog is usually something sitting in front of the rest of the \ac{IDE}
and that user wants to get rid of as fast as possible.

The option taken in this project will utilize the view mechanism provided by Eclipse. As described
in Section \ref{section:ConfTechEclipse} a view is used to display content that was created
elsewhere. Therefore it is the logical choice for displaying the information created by the automated
execution. This approach ensures that the user can place the displayed results where he wants them to be.
It also makes it possible for the user to run an execution multiple times and compare the
results by having them displayed in multiple views or next to each other in the same view.
Another advantage of the view concept is that it provides a tool bar for adding actions.
The user might want to control the automated run during its execution or interact with
the displayed results. While a static dialog would have difficulties providing the control elements
for those actions a view can easily display them in the tool bar.
