\chapter{Code Changes in the Execution Manager}
\label{chapter:KiemChanges}
Although the project attempts to realize most of the objectives without
changing the Execution Manager itself minimal adaptations were necessary.
This mostly involves adding new methods to the \ac{API} in order to
gain access to previously hidden properties.

Also some changes had to be performed where properties were loaded from hard-coded 
default values. These were refined and will now only be used if the \ac{KIEMConfig} 
plug-in is not registered to supply previously saved properties.

However all changes that were made to the \ac{KIEM} plug-in were merely additions
and won't break any plug-ins relying on the old implementation.

\section{Schema Files and Interfaces}
\index{Extension point}
In order to provide additional functionality for other plug-ins we choose the extension
point mechanism described in Section \ref{section:ConfTechExtension}. This is done
is order to retain the old functionality of the plug-in while on the other hand giving
options to ask extending plug-ins for their contributions. 

The extension points are described in more details in the next sections. They consist
of a schema file for defining the extension point and an interface that contains the 
methods that extending components have to supply.

\subsection{Toolbar Contribution Provider}
\label{section:ToolbarContributionProvider}
\index{Toolbar Contribution Provider}
The purpose of the tool bar contribution provider is to allow other plug-ins to put
items onto the tool bar of the Execution Manager. 
There are two reasons for using the extension point mechanism
rather than making the tool bar available and have other plug-ins put their
contributions directly on it:
\begin{enumerate}
 \item At the moment the tool bar and all contributions are created dynamically. Switching
the entire native tool bar of the Execution Manager to adding the actions to the tool bar
through a predefined Eclipse extension point would require major code changes and
have major drawbacks.
 \item A programmatic approach gives control over the contributions to the Execution Manager.
This means that the order of the native Execution Manager buttons is always the same and in the
same place. It also means that the Execution Manager can choose to ignore contributions if the
tool bar gets too crowded.
\end{enumerate}
\listingjava
\showlistingex{code/IKiemToolbarContributor.txt}
{Java}
{The interface for ToolbarContributionProviders}
{list:IToolbarContributor}
{t}
The schema file for components that want to add contributions to the tool bar is quite simple.
It only requires them to implement the interface shown in Listing \ref{list:IToolbarContributor}.
The implementing class provides an array with all ControlContributions they want to add to the tool bar.
A ControlContribution for a tool bar can be almost any widget like for example Labels, Buttons or ComboBoxes.

When the Execution Manager starts to build the views tool bar it will perform the following steps:
\begin{enumerate}
 \item The contributors will be asked for the list of controls that they want to contribute.
 \item That list will be added to the Execution Manager's tool bar.
 \item After that the Execution Manager will add its own controls to the tool bar.
\end{enumerate}
This order causes the tool bar to have the native elements always in the same order.
The contributed elements will be added from left to right in the order that they occur in the array. However there
is no guarantee on the order in which the extending plug-ins are asked.
Figure \ref{fig:ToolbarWithContributions} shows the Execution Manager tool bar with the two combo boxes belonging to \ac{KIEMConfig}
contributed through the extension point. Figure \ref{fig:ToolbarWithoutContributions} shows the same tool bar without
the contributions.
\begin{figure}[H]
  \centering
  \includegraphics[scale=.4]{ToolbarWithContributions.jpg}
  \caption[The Execution Managers Tool bar with two contributed ComboBoxes]%
  {The Execution Managers Tool bar with two contributed ComboBoxes\protect}
  \label{fig:ToolbarWithContributions}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[scale=.4]{ToolbarWithoutContributions.jpg}
  \caption[The Execution Managers Tool bar without contributions]%
  {The Execution Managers Tool bar without contributions\protect}
  \label{fig:ToolbarWithoutContributions}
\end{figure}

\subsection{Configuration Provider}
\label{section:ConfigurationProvider}
\index{Configuration Provider}
\listingjava
\showlistingex{code/IKiemConfigurationProvider.txt}
{Java}
{The Interface of the Configuration Provider}
{list:IKiemConfigurationProvider}
{t}
The purpose of the configuration provider is to allow internal attributes of the
Execution Manager to be stored in another plug in. 

This is achieved by another extension point to allow any plug-in to listen to changes
in the Execution Manager's attributes. It also means that there may be multiple
plug-ins that provide values for properties and not all plug-ins may have the value for
a property needed by the Execution Manager. Through the plug-in mechanism the \ac{KIEM}
can ask all providers for values and choose the one he would like to use.

The two methods from the interface shown in Listing \ref{list:IKiemConfigurationProvider} work
in the following way:

\begin{description}
 \item \textbf{String changeProperty(String propertyId) throws KiemPropertyException} :

This method will be called by the Execution Manager whenever a property has to be loaded where
other plug-ins are encouraged to provide their value. When a plug-in is asked for a value it
can do one of two things:
 \begin{enumerate}
  \item It can either provide a value for the property. Any value is acceptable here, even \textit{null}.
If one plug-in provides any value at all the other plug-ins will not be asked. The reason behind this arrangement
is that the Execution Manager most likely can't decide which value has more validity anyway if more than one
plug-in answers.
  \item If it can not provide a value the declared Exception should be thrown in which case the Execution
Manager will move to the next plug-in. The reason for not using the \textit{null} value to encode no valid value
is that \textit{null} might be the intended value.
 \end{enumerate}

 \item \textbf{void propertyChanged(String propertyId, String value)} :

Notifies all listeners that a property was changed somewhere in the Execution Manager. This will be called for example
when the user changes the step duration through the input field on the Execution Managers tool bar.
\end{description}

\subsection{Event Listener}
\label{section:EventListener}
\index{Event Listener}
\listingjava
\showlistingex{code/IKiemEventListener.txt}
{Java}
{The Interface of the Event Listener}
{list:IKiemEventListener}
{t}
The main purpose of the Event Manager is to inform DataComponents of events
happening in the Execution Manager during execution. This behavior has been modified to include 
events that occur while the execution is not running. This modification lead to the 
creation of another extension point in order to allow other plug-ins to be notified
on any of these events as well. The classes implementing the interface 
(see List \ref{list:IKiemEventListener}) required by this extension point will be notified
on any event that happens inside the Execution Manager.

\begin{description}
 \item \textbf{int provideEventOfInterest()} : This method is directly derived from the method with 
the same name in the AbstractDataComponent class of the \ac{KIEM} plug-in. It is called by the
EventManager to determine which events the implementing class is interested in.
This is done to improve efficiency and not flooding components with events they are not interested in.

Based on the response, the EventManager puts the component into lists along with the DataComponentWrappers
already inside.
 \item \textbf{void notifyEvent(KiemEvent event)} : This method is called by the EventManager when 
something happens inside the Execution Manager that the implementing classes might be interested in.
\end{description}

\section{KIEMPlugin.java}
\label{section:ConfChangesKiemPlugin}
The main Activator class contains almost the entire \ac{API} of the \ac{KIEM}.
Therefore any additions to that has to performed in this class which means that
most of the adjustments were made here.

\subsection{Listener}
The following methods were added to communicate with the plug-ins registered through
the ConfigurationProvider extension point (see Section \ref{section:ConfigurationProvider}).
\begin{description}
 \item \textbf{notifyConfigurationProviders(String propertyId, String value)} : 

This method can be called by any class
inside the Execution Manager itself. It should be called when the user changes a property through any of
the elements on the \ac{GUI}. The method will then inform all listeners that the property identified by the
given identifier was changed to the new value.
 \item \textbf{String getPropertyValueFromProviders(String propertyId)} : 

This method allows the Execution Manager to
retrieve a previously saved value. The \ac{KIEM} will ask all plug-ins registered on the extension point if they
can provide a value for the given identifier. Plug-ins that can't provide the value will indicate this by throwing
an Exception. The \ac{KIEM} will then take the first value he receives without getting an Exception and assign it
to the internal property.
 \item \textbf{Integer getIntegerValueFromProviders(final String propertyId)} : 

This method is a convenience method for
the one described above. It will try to parse an integer from the retrieved String and return it or return null
if no integer could be parsed.
\end{description}

\subsection{Getters and Setters}
\listingjava
\showlistingex{code/getterSetter.txt}
{Java}
{Example of modified Getter and Setter}
{list:getterAndSetter}
{t}
An example for the use of the methods described in the last section can be found in the Getters and Setters for
the different properties in the Execution Manager (for an example see Figure \ref{list:getterAndSetter}). 
These were changed in order to use the new methods but are
still able to fall back on hard-coded default values if no configuration plug-in is registered.


\subsection{Open File}
\label{section:ConfKiemOpenFile}
\listingjava
\showlistingex{code/openFile.txt}
{Java}
{The head of the modified openFile() method}
{list:openFileMethod}
{t}
The method that takes care of loading an execution file was split. This was done to allow
other plug-ins to pass an IPath object directly to the method and perform a load of that file without
having to go through the \ac{UI}. This method was also shifted around a little in order to detect
missing execution files before the load enters the \ac{UI}Thread. This was necessary to make is possible for
the callers of the method to catch the resulting exception.
The method also had to be modified in order to be able to take files that are not inside the workspace
but were added through an extension point. The changed part of the openFile method is shown in 
Listing \ref{list:openFileMethod}.
The last change to that method concerns the event listener. When the user opens a file through the
Eclipse workspace without using the \ac{KIEMConfig} plug-in the plug-in still has to be informed.
This happens through the use of the Event Manager that notifies all listeners upon the successful
completion of the loading operation.


\section{KIEMView}
\label{section:ConfChangesKiemView}
The changes described in Section \ref{section:ConfChangesKiemPlugin} were mostly concerned with the
configuration management and loading of new execution files. This section will mostly deal with the changes
that were necessary to enable the adding of new items to the tool bar.

The tool bar of the Execution Manager is created in a programmatic way instead of through the use of the
corresponding Eclipse extension point. This means that the only way to place additional controls onto the tool bar
is to modify the code in order to make use of the Toolbar Contribution Provider extension point described
in Section \ref{section:ToolbarContributionProvider}. For the full code of the modified method see the
Appendix.
