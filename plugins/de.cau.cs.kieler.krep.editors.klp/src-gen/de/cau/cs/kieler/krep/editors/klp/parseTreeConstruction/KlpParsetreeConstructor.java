/*
* generated by Xtext
*/
package de.cau.cs.kieler.krep.editors.klp.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.krep.editors.klp.services.KlpGrammarAccess;

import com.google.inject.Inject;

public class KlpParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private KlpGrammarAccess grammarAccess;
		
	public KlpGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KLP_InstructionsAssignment(this, this, 0, inst);
			case 1: return new Line_Group(this, this, 1, inst);
			case 2: return new Instruction_Alternatives(this, this, 2, inst);
			case 3: return new Decl_Group(this, this, 3, inst);
			case 4: return new SetClk_Group(this, this, 4, inst);
			case 5: return new SetPC_Group(this, this, 5, inst);
			case 6: return new Prio_Group(this, this, 6, inst);
			case 7: return new Done_Group(this, this, 7, inst);
			case 8: return new Binop_Group(this, this, 8, inst);
			case 9: return new Jmp_Group(this, this, 9, inst);
			case 10: return new CJmp_Group(this, this, 10, inst);
			case 11: return new Move_Group(this, this, 11, inst);
			case 12: return new Label_NameAssignment(this, this, 12, inst);
			case 13: return new Reg_NameAssignment(this, this, 13, inst);
			case 14: return new Read_Alternatives(this, this, 14, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule KLP ****************
 *
 * KLP returns klp::KLP:
 *   instructions+=Line*;
 *
 **/

// instructions+=Line*
protected class KLP_InstructionsAssignment extends AssignmentToken  {
	
	public KLP_InstructionsAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getKLPAccess().getInstructionsAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getKLPRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("instructions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("instructions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLineRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getKLPAccess().getInstructionsLineParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new KLP_InstructionsAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule KLP ****************/


/************ begin Rule Line ****************
 *
 * Line returns klp::Line:
 *   (labels+=ID ":")* instruction=Instruction;
 *
 **/

// (labels+=ID ":")* instruction=Instruction
protected class Line_Group extends GroupToken {
	
	public Line_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLineAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_InstructionAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLineRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// (labels+=ID ":")*
protected class Line_Group_0 extends GroupToken {
	
	public Line_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLineAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_ColonKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// labels+=ID
protected class Line_LabelsAssignment_0_0 extends AssignmentToken  {
	
	public Line_LabelsAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLineAccess().getLabelsAssignment_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_Group_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("labels",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("labels");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getLineAccess().getLabelsIDTerminalRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class Line_ColonKeyword_0_1 extends KeywordToken  {
	
	public Line_ColonKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getLineAccess().getColonKeyword_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_LabelsAssignment_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// instruction=Instruction
protected class Line_InstructionAssignment_1 extends AssignmentToken  {
	
	public Line_InstructionAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLineAccess().getInstructionAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("instruction",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("instruction");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLineAccess().getInstructionInstructionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Line_Group_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule Line ****************/


/************ begin Rule Instruction ****************
 *
 * Instruction returns klp::Instruction:
 *   Decl|SetClk|SetPC|Prio|Done|Binop|Jmp|CJmp|Move;
 *
 **/

// Decl|SetClk|SetPC|Prio|Done|Binop|Jmp|CJmp|Move
protected class Instruction_Alternatives extends AlternativesToken {

	public Instruction_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getInstructionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_DeclParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Instruction_SetClkParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Instruction_SetPCParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Instruction_PrioParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Instruction_DoneParserRuleCall_4(parent, this, 4, inst);
			case 5: return new Instruction_BinopParserRuleCall_5(parent, this, 5, inst);
			case 6: return new Instruction_JmpParserRuleCall_6(parent, this, 6, inst);
			case 7: return new Instruction_CJmpParserRuleCall_7(parent, this, 7, inst);
			case 8: return new Instruction_MoveParserRuleCall_8(parent, this, 8, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Decl
protected class Instruction_DeclParserRuleCall_0 extends RuleCallToken {
	
	public Instruction_DeclParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getDeclParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Decl_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SetClk
protected class Instruction_SetClkParserRuleCall_1 extends RuleCallToken {
	
	public Instruction_SetClkParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getSetClkParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetClk_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SetClk_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSetClkRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SetPC
protected class Instruction_SetPCParserRuleCall_2 extends RuleCallToken {
	
	public Instruction_SetPCParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getSetPCParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetPC_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SetPC_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSetPCRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Prio
protected class Instruction_PrioParserRuleCall_3 extends RuleCallToken {
	
	public Instruction_PrioParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getPrioParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prio_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Prio_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrioRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Done
protected class Instruction_DoneParserRuleCall_4 extends RuleCallToken {
	
	public Instruction_DoneParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getDoneParserRuleCall_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Done_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Done_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDoneRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Binop
protected class Instruction_BinopParserRuleCall_5 extends RuleCallToken {
	
	public Instruction_BinopParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getBinopParserRuleCall_5();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Binop_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Binop_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBinopRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Jmp
protected class Instruction_JmpParserRuleCall_6 extends RuleCallToken {
	
	public Instruction_JmpParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getJmpParserRuleCall_6();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Jmp_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Jmp_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getJmpRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CJmp
protected class Instruction_CJmpParserRuleCall_7 extends RuleCallToken {
	
	public Instruction_CJmpParserRuleCall_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getCJmpParserRuleCall_7();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CJmp_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CJmp_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCJmpRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Move
protected class Instruction_MoveParserRuleCall_8 extends RuleCallToken {
	
	public Instruction_MoveParserRuleCall_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getMoveParserRuleCall_8();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Move_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Move_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMoveRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Instruction ****************/


/************ begin Rule Decl ****************
 *
 * Decl returns klp::Decl:
 *   scope=Scope reg=Reg;
 *
 **/

// scope=Scope reg=Reg
protected class Decl_Group extends GroupToken {
	
	public Decl_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getDeclAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_RegAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// scope=Scope
protected class Decl_ScopeAssignment_0 extends AssignmentToken  {
	
	public Decl_ScopeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclAccess().getScopeAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("scope",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("scope");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getDeclAccess().getScopeScopeEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// reg=Reg
protected class Decl_RegAssignment_1 extends AssignmentToken  {
	
	public Decl_RegAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclAccess().getRegAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclAccess().getRegRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Decl_ScopeAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Decl ****************/


/************ begin Rule SetClk ****************
 *
 * SetClk returns klp::SetClk:
 *   "SETCLK" reg=Reg clk=Reg;
 *
 **/

// "SETCLK" reg=Reg clk=Reg
protected class SetClk_Group extends GroupToken {
	
	public SetClk_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSetClkAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetClk_ClkAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSetClkRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "SETCLK"
protected class SetClk_SETCLKKeyword_0 extends KeywordToken  {
	
	public SetClk_SETCLKKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSetClkAccess().getSETCLKKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// reg=Reg
protected class SetClk_RegAssignment_1 extends AssignmentToken  {
	
	public SetClk_RegAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSetClkAccess().getRegAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSetClkAccess().getRegRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SetClk_SETCLKKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// clk=Reg
protected class SetClk_ClkAssignment_2 extends AssignmentToken  {
	
	public SetClk_ClkAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSetClkAccess().getClkAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("clk",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("clk");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSetClkAccess().getClkRegParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SetClk_RegAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule SetClk ****************/


/************ begin Rule SetPC ****************
 *
 * SetPC returns klp::SetPC:
 *   "SETPC" reg=Reg label=Label;
 *
 **/

// "SETPC" reg=Reg label=Label
protected class SetPC_Group extends GroupToken {
	
	public SetPC_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSetPCAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetPC_LabelAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSetPCRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "SETPC"
protected class SetPC_SETPCKeyword_0 extends KeywordToken  {
	
	public SetPC_SETPCKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSetPCAccess().getSETPCKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// reg=Reg
protected class SetPC_RegAssignment_1 extends AssignmentToken  {
	
	public SetPC_RegAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSetPCAccess().getRegAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSetPCAccess().getRegRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SetPC_SETPCKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// label=Label
protected class SetPC_LabelAssignment_2 extends AssignmentToken  {
	
	public SetPC_LabelAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSetPCAccess().getLabelAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Label_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("label",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("label");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSetPCAccess().getLabelLabelParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SetPC_RegAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule SetPC ****************/


/************ begin Rule Prio ****************
 *
 * Prio returns klp::Prio:
 *   "PRIO" reg=Reg? prio=INT;
 *
 **/

// "PRIO" reg=Reg? prio=INT
protected class Prio_Group extends GroupToken {
	
	public Prio_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPrioAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prio_PrioAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrioRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "PRIO"
protected class Prio_PRIOKeyword_0 extends KeywordToken  {
	
	public Prio_PRIOKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPrioAccess().getPRIOKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// reg=Reg?
protected class Prio_RegAssignment_1 extends AssignmentToken  {
	
	public Prio_RegAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPrioAccess().getRegAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrioAccess().getRegRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Prio_PRIOKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// prio=INT
protected class Prio_PrioAssignment_2 extends AssignmentToken  {
	
	public Prio_PrioAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPrioAccess().getPrioAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prio_RegAssignment_1(parent, this, 0, inst);
			case 1: return new Prio_PRIOKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("prio",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("prio");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPrioAccess().getPrioINTTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Prio ****************/


/************ begin Rule Done ****************
 *
 * Done returns klp::Done:
 *   "DONE" pc=Label?;
 *
 **/

// "DONE" pc=Label?
protected class Done_Group extends GroupToken {
	
	public Done_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getDoneAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Done_PcAssignment_1(parent, this, 0, inst);
			case 1: return new Done_DONEKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDoneRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "DONE"
protected class Done_DONEKeyword_0 extends KeywordToken  {
	
	public Done_DONEKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getDoneAccess().getDONEKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// pc=Label?
protected class Done_PcAssignment_1 extends AssignmentToken  {
	
	public Done_PcAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDoneAccess().getPcAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Label_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pc",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pc");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDoneAccess().getPcLabelParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Done_DONEKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Done ****************/


/************ begin Rule Binop ****************
 *
 * Binop returns klp::Binop:
 *   op=Operator to=Reg arg1=Read (arg2=Read|val=INT);
 *
 **/

// op=Operator to=Reg arg1=Read (arg2=Read|val=INT)
protected class Binop_Group extends GroupToken {
	
	public Binop_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBinopAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Binop_Alternatives_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBinopRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// op=Operator
protected class Binop_OpAssignment_0 extends AssignmentToken  {
	
	public Binop_OpAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBinopAccess().getOpAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getBinopAccess().getOpOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// to=Reg
protected class Binop_ToAssignment_1 extends AssignmentToken  {
	
	public Binop_ToAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBinopAccess().getToAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("to",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("to");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBinopAccess().getToRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Binop_OpAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// arg1=Read
protected class Binop_Arg1Assignment_2 extends AssignmentToken  {
	
	public Binop_Arg1Assignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBinopAccess().getArg1Assignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arg1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arg1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBinopAccess().getArg1ReadParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Binop_ToAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// arg2=Read|val=INT
protected class Binop_Alternatives_3 extends AlternativesToken {

	public Binop_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getBinopAccess().getAlternatives_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Binop_Arg2Assignment_3_0(parent, this, 0, inst);
			case 1: return new Binop_ValAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// arg2=Read
protected class Binop_Arg2Assignment_3_0 extends AssignmentToken  {
	
	public Binop_Arg2Assignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBinopAccess().getArg2Assignment_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arg2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arg2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBinopAccess().getArg2ReadParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Binop_Arg1Assignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// val=INT
protected class Binop_ValAssignment_3_1 extends AssignmentToken  {
	
	public Binop_ValAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBinopAccess().getValAssignment_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Binop_Arg1Assignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("val",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("val");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBinopAccess().getValINTTerminalRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Binop ****************/


/************ begin Rule Jmp ****************
 *
 * Jmp returns klp::Jmp:
 *   "JMP" label=Label;
 *
 **/

// "JMP" label=Label
protected class Jmp_Group extends GroupToken {
	
	public Jmp_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getJmpAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Jmp_LabelAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getJmpRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "JMP"
protected class Jmp_JMPKeyword_0 extends KeywordToken  {
	
	public Jmp_JMPKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJmpAccess().getJMPKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// label=Label
protected class Jmp_LabelAssignment_1 extends AssignmentToken  {
	
	public Jmp_LabelAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getJmpAccess().getLabelAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Label_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("label",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("label");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getJmpAccess().getLabelLabelParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Jmp_JMPKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Jmp ****************/


/************ begin Rule CJmp ****************
 *
 * CJmp returns klp::CJmp:
 *   cond=JumpKind reg=Read label=Label;
 *
 **/

// cond=JumpKind reg=Read label=Label
protected class CJmp_Group extends GroupToken {
	
	public CJmp_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCJmpAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CJmp_LabelAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCJmpRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// cond=JumpKind
protected class CJmp_CondAssignment_0 extends AssignmentToken  {
	
	public CJmp_CondAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCJmpAccess().getCondAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("cond",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cond");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getCJmpAccess().getCondJumpKindEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// reg=Read
protected class CJmp_RegAssignment_1 extends AssignmentToken  {
	
	public CJmp_RegAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCJmpAccess().getRegAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCJmpAccess().getRegReadParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CJmp_CondAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// label=Label
protected class CJmp_LabelAssignment_2 extends AssignmentToken  {
	
	public CJmp_LabelAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCJmpAccess().getLabelAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Label_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("label",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("label");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCJmpAccess().getLabelLabelParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CJmp_RegAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule CJmp ****************/


/************ begin Rule Move ****************
 *
 * Move returns klp::Move:
 *   type=MoveKind to=Reg (from=Read|val=INT);
 *
 **/

// type=MoveKind to=Reg (from=Read|val=INT)
protected class Move_Group extends GroupToken {
	
	public Move_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMoveAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Move_Alternatives_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMoveRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=MoveKind
protected class Move_TypeAssignment_0 extends AssignmentToken  {
	
	public Move_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveAccess().getTypeAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getMoveAccess().getTypeMoveKindEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// to=Reg
protected class Move_ToAssignment_1 extends AssignmentToken  {
	
	public Move_ToAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveAccess().getToAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("to",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("to");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMoveAccess().getToRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Move_TypeAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// from=Read|val=INT
protected class Move_Alternatives_2 extends AlternativesToken {

	public Move_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getMoveAccess().getAlternatives_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Move_FromAssignment_2_0(parent, this, 0, inst);
			case 1: return new Move_ValAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// from=Read
protected class Move_FromAssignment_2_0 extends AssignmentToken  {
	
	public Move_FromAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveAccess().getFromAssignment_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("from",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("from");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMoveAccess().getFromReadParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Move_ToAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// val=INT
protected class Move_ValAssignment_2_1 extends AssignmentToken  {
	
	public Move_ValAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveAccess().getValAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Move_ToAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("val",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("val");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMoveAccess().getValINTTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Move ****************/


/************ begin Rule Label ****************
 *
 * Label returns klp::Label:
 *   name=ID;
 *
 **/

// name=ID
protected class Label_NameAssignment extends AssignmentToken  {
	
	public Label_NameAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLabelAccess().getNameAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getLabelAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Label ****************/


/************ begin Rule Reg ****************
 *
 * Reg returns klp::Reg:
 *   name=ID;
 *
 **/

// name=ID
protected class Reg_NameAssignment extends AssignmentToken  {
	
	public Reg_NameAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRegAccess().getNameAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRegAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Reg ****************/


/************ begin Rule Read ****************
 *
 * Read returns klp::Read:
 *   pre?="pre" "(" reg=Reg ")"|reg=Reg; 
 *       
 *      
 *             
 *          
 *       
 *  
 * / *------------------------------------------------------------------
 * * LEXER RULES
 * *------------------------------------------------------------------* /
 *
 **/

// pre?="pre" "(" reg=Reg ")"|reg=Reg 
//       
//      
//             
//          
//       
//  
// / *------------------------------------------------------------------
// * LEXER RULES
// *------------------------------------------------------------------* /
protected class Read_Alternatives extends AlternativesToken {

	public Read_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getReadAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_Group_0(parent, this, 0, inst);
			case 1: return new Read_RegAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getReadRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// pre?="pre" "(" reg=Reg ")"
protected class Read_Group_0 extends GroupToken {
	
	public Read_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getReadAccess().getGroup_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_RightParenthesisKeyword_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// pre?="pre"
protected class Read_PreAssignment_0_0 extends AssignmentToken  {
	
	public Read_PreAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getReadAccess().getPreAssignment_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pre",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pre");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReadAccess().getPrePreKeyword_0_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class Read_LeftParenthesisKeyword_0_1 extends KeywordToken  {
	
	public Read_LeftParenthesisKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReadAccess().getLeftParenthesisKeyword_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_PreAssignment_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// reg=Reg
protected class Read_RegAssignment_0_2 extends AssignmentToken  {
	
	public Read_RegAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getReadAccess().getRegAssignment_0_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getReadAccess().getRegRegParserRuleCall_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Read_LeftParenthesisKeyword_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Read_RightParenthesisKeyword_0_3 extends KeywordToken  {
	
	public Read_RightParenthesisKeyword_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReadAccess().getRightParenthesisKeyword_0_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Read_RegAssignment_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// reg=Reg
protected class Read_RegAssignment_1 extends AssignmentToken  {
	
	public Read_RegAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getReadAccess().getRegAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reg_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getReadAccess().getRegRegParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}


/************ end Rule Read ****************/

}
