/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2012 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.sim.kart.engine;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.json.JSONException;
import org.json.JSONObject;

import de.cau.cs.kieler.core.util.Pair;
import de.cau.cs.kieler.sim.kart.Constants;
import de.cau.cs.kieler.sim.kart.Utilities;
import de.cau.cs.kieler.sim.kart.ValidationException;
import de.cau.cs.kieler.sim.kart.Tree;
import de.cau.cs.kieler.sim.kiem.KiemExecutionException;

/**
 * The default validation engine to validate simulation runs with.
 * This engine has the capability to perform validity checks of state
 * information, i. e. it can visualize state information. Furthermore,
 * it also checks other variables for valid values. It also checks signals
 * including their values for validity and can (but not must) raise a
 * validation error if additional signals are being generated by the simulation.
 * 
 * @author Sebastian Sch√§fer - ssc AT informatik.uni-kiel.de
 * @kieler.rating 2012-01-24 red
 */
public class DefaultValidationEngine implements IValidationEngine {
    /**
     * The diagram editor this engine can visualize state validation errors in
     */
    private DiagramEditor editor;
    
    /**
     * Flag to indicate whether to ignore additionally generated signals or not
     */
    private boolean ignoreAdditionalSignals;
    
    /**
     * Create a new DefaultValidationEngine
     * 
     * @param editor the diagram editor to visualize state validation errors in
     * @param ignoreAdditionalSignals flag to indicate to ignore additionally generated signals
     * @param stateVariable the name of the variable containing state validation information
     */
    public DefaultValidationEngine(DiagramEditor editor, boolean ig) {
        this.editor = editor;
        this.ignoreAdditionalSignals = ig;
    }
    
    /**
     * 
     * {@inheritDoc}
     */
    public void validateVariable(Pair<String,String> variable, String recValue, String simValue, boolean isHistoryStep, JSONObject retval)
            throws KiemExecutionException {
        if (simValue == null) {
            throw new KiemExecutionException(Constants.VAL_TITLE, false, new ValidationException(
                    "The simulation step did not generate a variable \"" + variable.getFirst() + "\". "
                            + "No validation for this variable will take place in this step!"));
        } else if (!(recValue.equals(simValue))) {
            try {
                if(!isHistoryStep) {
                    List<EObject> isStates = Utilities.getStates(editor, simValue);
                    List<EObject> shallStates = Utilities.getStates(editor, recValue);
                    
                    // Get meaningful names for the states
                    String stateNamesTree = Utilities.buildTree(new Tree(null), shallStates).toString();
                    String simStateNamesTree = Utilities.buildTree(new Tree(null), isStates).toString();

                    // Display an error message
                    String errorMessage = "Validation error: The simulation should have generated the "
                            + "variable \"" + variable.getFirst() + "\", representing the following "
                            + "diagram objects:\n"
                            + stateNamesTree
                            + "\nbut the variable actually represents:\n"
                            + simStateNamesTree;
                    
                    try {
                        retval.accumulate(variable.getSecond(), recValue);
                    } catch (JSONException e) {
                        // do nothing
                    }
                    
                    throw new KiemExecutionException(Constants.VAL_TITLE, false,
                            new ValidationException(errorMessage));
                }
            } catch (KiemExecutionException e) {
                throw e;
            } catch (Exception e) {
                // something went terribly wrong when trying to get real names, just print that string
                try {
                    retval.accumulate(variable.getSecond(), recValue);
                } catch (JSONException j) {
                    // do nothing
                }
                throw new KiemExecutionException(Constants.VAL_TITLE, false,
                        new ValidationException(
                                "Validation error: The simulation should provide a variable \""
                                        + variable.getFirst() + "\" with a value of \"" + recValue
                                        + "\", but it actually generated the value \""
                                        + simValue + "\"."));
            }
        }
    }
    
    /**
     * 
     * {@inheritDoc}
     */
    public void validateSignals(Map<String,Object> recSignals, Map<String,Object> simSignals,
            boolean isHistoryStep, String errSignalVar, JSONObject retval)
            throws KiemExecutionException {
        
        Iterator<String> signals = recSignals.keySet().iterator();
        String errSignals = "";
        
        while (signals.hasNext()) {
            String signal = signals.next();
            
            if(!(simSignals.containsKey(signal) && recSignals.get(signal).equals(simSignals.get(signal)))) {
                if(!errSignals.isEmpty()) {
                    errSignals += ", ";
                }
                errSignals += signal;
                simSignals.remove(signal);
            }
        }
        
        if(!errSignals.isEmpty()) {
            try {
                retval.accumulate(errSignalVar, errSignals);
            } catch(JSONException e) {
                // do nothing
            }
            
            if(!isHistoryStep) {
                throw new KiemExecutionException(Constants.VAL_TITLE, false,
                        new ValidationException("Validation error: The signals " + errSignals +
                                "were produced erroneously, they were either not present when they should " +
                                "have been or in the case of valued signals were present with a wrong value"));
            }
        }
        
        if(!(ignoreAdditionalSignals || simSignals.isEmpty())) {
            String excessSignals = "";
            Iterator<String> it2 = simSignals.keySet().iterator();
            while (it2.hasNext()) {
                String signal = it2.next();
                excessSignals += "\"" + signal + "\"";

                if (it2.hasNext()) {
                    excessSignals += ", ";
                }
            }

            try {
                retval.accumulate(errSignalVar, excessSignals);
            } catch (JSONException e) {
                // do nothing
            }
            if(!isHistoryStep) {
                throw new KiemExecutionException(Constants.VAL_TITLE, false, new ValidationException(
                        "Validation error: The signal(s) " + excessSignals
                                + " were not recorded, but generated in the simulation"));
            }
        }
    }
}
