/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2011 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.sim.kart;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.CommonPlugin;
import org.eclipse.emf.common.util.URI;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.json.JSONObject;

import de.cau.cs.kieler.core.util.Pair;
import de.cau.cs.kieler.sim.esi.EsiFile;
import de.cau.cs.kieler.sim.esi.ISignal;
import de.cau.cs.kieler.sim.esi.ITick;
import de.cau.cs.kieler.sim.esi.ITrace;
import de.cau.cs.kieler.sim.esi.ITraceProvider;
import de.cau.cs.kieler.sim.kart.engine.DefaultValidationEngine;
import de.cau.cs.kieler.sim.kart.engine.IValidationEngine;
import de.cau.cs.kieler.sim.kiem.IJSONObjectDataComponent;
import de.cau.cs.kieler.sim.kiem.KiemEvent;
import de.cau.cs.kieler.sim.kiem.KiemExecutionException;
import de.cau.cs.kieler.sim.kiem.KiemInitializationException;
import de.cau.cs.kieler.sim.kiem.properties.KiemProperty;
import de.cau.cs.kieler.sim.kiem.properties.KiemPropertyException;
import de.cau.cs.kieler.sim.kiem.properties.KiemPropertyTypeFile;
import de.cau.cs.kieler.sim.kiem.properties.KiemPropertyTypeInt;
import de.cau.cs.kieler.sim.kiem.ui.datacomponent.JSONObjectSimulationDataComponent;

/**
 * This component implements a KIEM data component to validate signal and state information generated in a
 * simulation against pre-recorded values. If the validation fails, the simulation is stopped and
 * the error is visualized in the SyncChart. Additionally, an explanatory error message is
 * displayed. This component does not provide any means to record or replay signal and state
 * information, refer to {@link DataRecordingComponent} and {@link DataReplayComponent}
 * 
 * @author Sebastian Sch√§fer - ssc AT informatik.uni-kiel.de
 * @kieler.rating 2011-11-29 red
 * 
 */
public class DataValidationComponent extends JSONObjectSimulationDataComponent implements
        IJSONObjectDataComponent {
    /** The number of the current step */
    private long step;

    /** The name of the ESI/ESO file the trace shall be read/written from/to */
    private String filename;

    /** Shall we ignore signals generated by the simulation but not present in the ESO file? */
    private boolean ignoreAdditionalSignals;

    /** The currently active diagram editor */
    private DiagramEditor editor;

    /** Are we operating in training mode, i. e. generate an ESO file */
    private boolean trainingMode;

    /** A map of all values of all recorded output signals in each step */
    private List<HashMap<String, Object>> recOutputs;

    /** A map of all values of all recorded special signals in each step */
    private List<HashMap<String, Object>> recSpecialSignals;

    /**
     * A map f all values of all simulated or recorded input signals in each step. Pushed here by the DataReplayComponent
     */
    private List<HashMap<String, Object>> recInputs;

    /**
     * A list of special signals from the properties like a state signal that will be compared
     * differently than regular signals and are found in special comments in the ESO file
     */
    private Set<Pair<String,String>> variables;

    /**
     * The validation engine that will be used to validate signal and variable information
     */
    private IValidationEngine valEngine;

    /** Name of the variable the replay component will give us our configuration through */
    private String configVarName;

    /** Name of the variable the replay component will give us the values of the output signals
     * and variables through
     */
    private String outputVarName;

    /**
     * Initialize the data component. Open an existing ESO file, read the expected signal and state
     * information and store it internally
     * 
     * @throws KiemInitializationException
     *             thrown when reading the file fails
     */
    @Override
    public void initialize() throws KiemInitializationException {
        step = 0;
        filename = "";
        ignoreAdditionalSignals = false;
        
        KiemProperty[] properties = this.getProperties();

        recOutputs = new LinkedList<HashMap<String, Object>>();
        recSpecialSignals = new LinkedList<HashMap<String, Object>>();
        recInputs = new LinkedList<HashMap<String, Object>>();

        editor = (DiagramEditor) getActivePage().getActiveEditor();

        // load properties
        variables = new HashSet<Pair<String,String>>();
        for (KiemProperty prop : properties) {
            if (prop.getKey().equals(Constants.IGNOREEXTRA)) {
                ignoreAdditionalSignals = prop.getValueAsBoolean();
            } else if (prop.getKey().equals(Constants.VALVAR)) {
                variables = Utilities.makeSetOfPairs(prop.getValue());
            } else if (prop.getKey().equals(Constants.CONFIGVAR)) {
                configVarName = prop.getKey();
            } else if (prop.getKey().equals(Constants.OUTPUTVAR)) {
                outputVarName = prop.getKey();
            }
        }

        // Read the file

        if (!trainingMode) {
            valEngine = new DefaultValidationEngine(editor, ignoreAdditionalSignals,
                        null);
        }
    }

    /**
     * Wrapup this component. This writes an ESO file in training mode and always resets the state
     * visualization.
     * 
     * @throws KiemInitializationException
     *             when TraceWriter.doWrite() throws it
     */
    public void wrapup() throws KiemInitializationException {
        Utilities.visualizeStates(null, null, editor);
        
        if (trainingMode) {
            TraceWriter writer = new TraceWriter(recInputs, recOutputs, recSpecialSignals, filename);
            writer.doWrite();
        }
    }

    /**
     * Sets the step number according to the button the user pressed. This is needed to correctly
     * handle history steps or jumps.
     */
    @SuppressWarnings("unchecked")
    @Override
    public void notifyEvent(KiemEvent event) {
        if (event.isEvent(KiemEvent.STEP_INFO) && event.getInfo() instanceof Pair) {
            step = ((Pair<Long, Long>) event.getInfo()).getFirst().longValue();
        }
    }

    /**
     * Return the types of events this component listens to
     * 
     * @return the event types, currently only {@code KiemEvent.STEP_INFO}
     */
    @Override
    public KiemEvent provideEventOfInterest() {
        int[] events = { KiemEvent.STEP_INFO };
        KiemEvent event = new KiemEvent(events);
        return event;
    }

    /**
     * This component may not be skipped so we tell KIEM that we also produce data, though we
     * actually do not.
     * 
     * @return always true
     */
    @Override
    public boolean isProducer() {
        return true;
    }

    /**
     * Tell KIEM that this component does observe data.
     * 
     * @return always true
     */
    @Override
    public boolean isObserver() {
        return true;
    }

    /**
     * Tell KIEM that we are also interested in history data
     * 
     * @return always true
     */
    @Override
    public boolean isHistoryObserver() {
        return true;
    }

    /**
     * Tell KIEM that we are *not* a delta observer
     * 
     * @return always false
     */
    @Override
    public boolean isDeltaObserver() {
        return false;
    }

    /**
     * Provide a list of properties to KIEM so the user can configure this component.
     * 
     * @return the list of properties this component offers
     */
    @Override
    public KiemProperty[] doProvideProperties() {
        KiemPropertyTypeFile fileProperty = new KiemPropertyTypeFile(true);
        fileProperty.setFilterExts(Constants.FILEEXTS);
        fileProperty.setFilterNames(Constants.FILEEXTNAMES);

        String filename = null;
        try {
            /*
             * Try creating a default file name
             * The try block is necessary to suppress NPEs and other exception when we are either
             * running in headless mode or there are no editor opened. Below, you will see that a
             * filename is only proposed if this try block succeeds. We have to use absolute file
             * paths here, because the KiemPropertyTypeFile dialog only returns absolute paths. I do
             * not want to change that for fear that something else breaks.
             */
            URI resource = ((DiagramEditor) getActivePage().getActiveEditor()).getDiagram()
                    .eResource().getURI().trimFileExtension().appendFileExtension("eso");
            URI absFile = CommonPlugin.resolve(resource);
            filename = absFile.toFileString();
        } catch (Exception e) {
            // do nothing
        }

        KiemProperty[] properties = new KiemProperty[6];
        properties[0] = new KiemProperty(Constants.ESOFILE, fileProperty);
        if (filename != null) {
            fileProperty.setValue(properties[0], filename);
        }
        properties[1] = new KiemProperty(Constants.CONFIGVAR, Constants.DEF_CONFIGVAR);
        properties[2] = new KiemProperty(Constants.OUTPUTVAR, Constants.DEF_OUTPUTVAR);
        properties[3] = new KiemProperty(Constants.VALVAR, Constants.DEF_VALVAR);
        properties[4] = new KiemProperty(Constants.IGNOREEXTRA, false);
        properties[5] = new KiemProperty(Constants.TRAINMODE, false);

        return properties;
    }

    /**
     * Take a step in the simulation. The component reads its internal state and compares the signal
     * and possibly state information from the ESO file to the signals and state information
     * generated by the simulation.
     * 
     * @return always {@code null}
     * @throws KiemExecutionException
     *             when the JSON object with signals from ESI/ESO file could not be built.
     */
    @Override
    public JSONObject doStep(JSONObject obj) throws KiemExecutionException {
        /*
        Map<String, Object> outputSignals = Utilities.convertAndRecordSignals(obj, recInputs,
                recOutputs, recSpecialSignals, variables);
        
        if (!trainingMode && trace.getSize() >= (step - 1)) {
            ITick tick = trace.get(step - 1);
            List<ISignal> signals = tick.getOutputs();

            Map<String, String> special = tick.getExtraInfos();

            if (useState) {
                Iterator<String> it = special.keySet().iterator();

                while (it.hasNext()) {
                    String key = it.next();
                    String value = special.get(key);

                    valEngine.validateVariable(key, value, obj.optString(key), isHistoryStep());
                }
            }

            valEngine.validateSignals(signals, outputSignals, isHistoryStep(), step);
        }
*/
        return null;
    }

    /**
     * Check whether the user actually selected an ESI or ESO file or messed up. This does not
     * actually try to read the file, it just checks for the correct extension.
     * 
     * @throws KiemPropertyException
     *             when the user messed up and did not select an ESI or ESO file
     */
    @Override
    public void checkProperties(KiemProperty[] properties) throws KiemPropertyException {
        for (KiemProperty prop : properties) {
            if (prop.getKey().equals(Constants.ESOFILE)) {
                if (!(prop.getValue().toLowerCase().endsWith(".esi") || prop.getValue()
                        .toLowerCase().endsWith(".eso"))) {
                    throw new KiemPropertyException(
                            Constants.ERR_NOTESO);
                }
            }
        }
    }
}
