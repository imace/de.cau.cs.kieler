options {
  IGNORE_CASE = true;
  STATIC=false;
}


PARSER_BEGIN(Parser)

package krep.evalbench.program.krep.parser;

import krep.evalbench.program.KrepAssembler;
import krep.evalbench.program.krep.Process;

import krep.evalbench.program.krep.Statement;
import krep.evalbench.program.krep.*;

public class Parser {
  private static KrepAssembler program;
  private static byte n_proc = 0;
  private static Process p = new Process((byte)0);
}

PARSER_END(Parser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
|  <"%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>

}

TOKEN : /* KEYWORDS */
{
   <GLOBALIO: "_global_io">
|  <PROC:     "_proc">
|  <INPUT:    "input">
|  <OUTPUT:   "output">
|  <RECV:     "recv">
|  <SEND:     "send">
|  <SYNC:     "sync">
|  <IADD:     "iadd">
|  <ADD:      "add">
|  <AND:      "and">
|  <OR:       "or">
|  <XOR:      "xor">
|  <NOT:      "not"> 
|  <JMP:      "jmp">
|  <JZ:       "jz">

|  <RRMOV: "rrmov">
|  <IRMOV: "irmov">
}

TOKEN : {
  <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <NUMBER: (<DIGIT>)+>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]> 
}


void Start(KrepAssembler prog) :
{program=prog;  }
{
  GlobalIO() (Proc())+ <EOF>
  { }
}

void GlobalIO() :
{ }
{
  (Input() | Output())+
  {  }
}

void Input() :
{String l;}
{
  <INPUT> l=id()
  {program.addInput(l);}
}

void Output() :
{String l;}
{
  <OUTPUT> l=id()
  {program.addOutput(l);}
}

void Proc():
{Statement s; String l;}
{
  <PROC> ((l=Label(){p.addLabel(l);})? s=Statement(){p.addStatement(s);})+  
  {program.addProcess(p); n_proc++; p= new Process(n_proc);}
}

String Label():
{String l;}
{
  l=id() ":" {return l;}
}

Statement Statement():
{String l; String R1, R2, R3; int V1, V2, V3;}
{
  <RECV> l=id()                 {return new Recv(l);}
| <SEND> l=id()                 {return new Send(l);}
| <SYNC>                        {return new Sync();}
| <IADD> R1=id() ("<-")? R2=id() ("+")? V3=number() 
{return new LongIOp(Operator.ADD, R1, R2, V3 );}
| <ADD> R1=id() R2=id() R3=id() { return new LongOp(Operator.ADD, R1, R2, R3);}
| <AND> R1=id() R2=id() R3=id() { return new LongOp(Operator.AND, R1, R2, R3);}
| <OR>  R1=id() R2=id() R3=id() { return new LongOp(Operator.OR, R1, R2, R3);}
| <XOR> R1=id() R2=id() R3=id() { return new LongOp(Operator.XOR, R1, R2, R3);}
| <NOT> R1=id() R2=id()         { return new LongOp(Operator.NOT, R1, R2, "");}
| <JMP> l=id()                  {return new Jmp(l);}
| <JZ>  R1=id() l=id()          { return new Jz(R1, l);}

| <RRMOV> R1=id() R2=id()       { return new Rrmov(R1, R2);}
| <IRMOV> R1=id() V2=number()       { return new Irmov(R1, V2);}
}

String id():
{Token t;}
{
	t=<IDENTIFIER>{return t.image;}
}

int number():
{Token t;}
{
	t=<NUMBER> {return Integer.parseInt(t.image);}
}