/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2009 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.kiml.gmf;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Map.Entry;

import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionLocator;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.Label;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Insets;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CommandStack;
import org.eclipse.gmf.runtime.diagram.ui.editparts.AbstractBorderItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.CompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.LabelEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.figures.BorderedNodeFigure;
import org.eclipse.gmf.runtime.diagram.ui.figures.ResizableCompartmentFigure;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel;
import org.eclipse.swt.SWTException;
import org.eclipse.swt.graphics.Font;
import org.eclipse.ui.IWorkbenchPart;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;

import de.cau.cs.kieler.core.kgraph.KEdge;
import de.cau.cs.kieler.core.kgraph.KGraphElement;
import de.cau.cs.kieler.core.kgraph.KLabel;
import de.cau.cs.kieler.core.kgraph.KNode;
import de.cau.cs.kieler.core.kgraph.KPort;
import de.cau.cs.kieler.core.model.IGraphicalFrameworkBridge;
import de.cau.cs.kieler.core.model.gmf.GmfFrameworkBridge;
import de.cau.cs.kieler.core.util.Maybe;
import de.cau.cs.kieler.core.util.Pair;
import de.cau.cs.kieler.kiml.ILayoutConfig;
import de.cau.cs.kieler.kiml.klayoutdata.KEdgeLayout;
import de.cau.cs.kieler.kiml.klayoutdata.KInsets;
import de.cau.cs.kieler.kiml.klayoutdata.KLayoutDataFactory;
import de.cau.cs.kieler.kiml.klayoutdata.KPoint;
import de.cau.cs.kieler.kiml.klayoutdata.KShapeLayout;
import de.cau.cs.kieler.kiml.options.EdgeLabelPlacement;
import de.cau.cs.kieler.kiml.options.LayoutOptions;
import de.cau.cs.kieler.kiml.options.PortConstraints;
import de.cau.cs.kieler.kiml.options.PortSide;
import de.cau.cs.kieler.kiml.ui.layout.ApplyLayoutRequest;
import de.cau.cs.kieler.kiml.ui.layout.DiagramLayoutManager;
import de.cau.cs.kieler.kiml.ui.layout.EclipseLayoutConfig;
import de.cau.cs.kieler.kiml.ui.layout.ICachedLayout;
import de.cau.cs.kieler.kiml.ui.util.KimlUiUtil;
import de.cau.cs.kieler.kiml.util.KimlUtil;

/**
 * Diagram layout manager that is able to generically layout diagrams generated by GMF. The internal
 * KGraph graph structure is built from the structure of edit parts in the diagram. The new layout
 * is applied to the diagram using {@link GmfLayoutEditPolicy}, which creates a
 * {@link GmfLayoutCommand} to directly manipulate data in the GMF notation model, where layout
 * information is stored persistently.
 * 
 * @kieler.rating 2009-12-11 proposed yellow msp
 * @author ars
 * @author msp
 */
public class GmfDiagramLayoutManager extends DiagramLayoutManager {

    /** map of layout graph elements to edit parts. */
    private BiMap<KGraphElement, IGraphicalEditPart> graphElem2EditPartMap = HashBiMap.create();
    /** list of connection edit parts that were found in the diagram. */
    private LinkedList<ConnectionEditPart> connections = new LinkedList<ConnectionEditPart>();
    /** list of empty labels, which should be kept near to their edge. */
    private LinkedList<LabelEditPart> emptyLabels = new LinkedList<LabelEditPart>();
    /** editor part of the currently layouted diagram. */
    private DiagramEditor diagramEditorPart;
    /** diagram edit part of the currently layouted diagram. */
    private DiagramEditPart diagramEditPart;
    /** root of the currently layouted selection. */
    private IGraphicalEditPart layoutRootPart;
    /** target edit part that is layouted recursively. */
    private IGraphicalEditPart ancestryTargetPart;
    /** the last created layout graph. */
    private KNode layoutGraph;
    /** target layout node that is layouted recursively. */
    private KNode ancestryTargetNode;
    /** the cached layout result. */
    private GmfCachedLayout cachedLayout;
    /** the command that applies the transferred layout to the diagram. */
    private Command applyLayoutCommand;

    /**
     * Returns the map of layout graph elements to corresponding edit parts.
     * 
     * @return the graphElem2EditPartMap
     */
    protected Map<KGraphElement, IGraphicalEditPart> getGraphElem2EditPartMap() {
        return graphElem2EditPartMap;
    }

    /**
     * Returns the map of graphical edit parts to corresponding layout graph elements.
     * 
     * @return the editPart2GraphElemMap
     */
    protected Map<IGraphicalEditPart, KGraphElement> getEditPart2GraphElemMap() {
        return graphElem2EditPartMap.inverse();
    }

    /**
     * Returns the diagram edit part.
     * 
     * @return the diagram edit part
     */
    protected DiagramEditPart getDiagramEditPart() {
        return diagramEditPart;
    }

    /**
     * Returns the command that is calculated by {@link #transferLayout(boolean)} to apply the
     * layout.
     * 
     * @return the apply layout command
     */
    protected Command getLayoutCommand() {
        return applyLayoutCommand;
    }

    /**
     * Sets the given command as new layout command.
     * 
     * @param thelayoutCommand the apply layout command
     */
    protected void setLayoutCommand(final Command thelayoutCommand) {
        this.applyLayoutCommand = thelayoutCommand;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected boolean supports(final IWorkbenchPart workbenchPart) {
        return workbenchPart instanceof DiagramEditor;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected boolean supports(final EditPart editPart) {
        return editPart instanceof IGraphicalEditPart;
    }

    /** the editing provider for this layout manager. */
    private GmfFrameworkBridge gmfBridge = new GmfFrameworkBridge();
    
    /**
     * {@inheritDoc}
     */
    @Override
    public IGraphicalFrameworkBridge getBridge() {
        return gmfBridge;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ILayoutConfig getLayoutConfig(final EditPart editPart) {
        GmfLayoutConfig config = new GmfLayoutConfig();
        if (editPart instanceof IGraphicalEditPart) {
            config.initialize((IGraphicalEditPart) editPart);
        } else if (editPart instanceof DiagramRootEditPart) {
            config.initialize((IGraphicalEditPart) ((DiagramRootEditPart) editPart).getContents());
        }
        return config;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public KNode buildLayoutGraph(final IWorkbenchPart workbenchPart, final EditPart editPart,
        final boolean layoutAncestors) {
        graphElem2EditPartMap.clear();
        connections.clear();
        emptyLabels.clear();

        // get the diagram editor part
        if (workbenchPart instanceof DiagramEditor) {
            diagramEditorPart = (DiagramEditor) workbenchPart;
        } else {
            diagramEditorPart = null;
        }

        // choose the layout root edit part
        layoutRootPart = null;
        ancestryTargetNode = null;
        cachedLayout = null;
        if (layoutAncestors && editPart instanceof IGraphicalEditPart) {
            ancestryTargetPart = (IGraphicalEditPart) editPart;
        } else {
            ancestryTargetPart = null;
            if (editPart instanceof ShapeNodeEditPart || editPart instanceof DiagramEditPart) {
                layoutRootPart = (IGraphicalEditPart) editPart;
            } else if (editPart instanceof IGraphicalEditPart) {
                EditPart tgEditPart = ((IGraphicalEditPart) editPart).getTopGraphicEditPart();
                if (tgEditPart instanceof ShapeNodeEditPart) {
                    layoutRootPart = (IGraphicalEditPart) tgEditPart;
                }
            }
        }
        if (layoutRootPart == null && diagramEditorPart != null) {
            layoutRootPart = diagramEditorPart.getDiagramEditPart();
        }
        if (layoutRootPart == null) {
            throw new UnsupportedOperationException("Not supported by this layout manager: Editor "
                + workbenchPart + ", Edit part " + editPart);
        }

        // find the diagram edit part
        diagramEditPart = GmfFrameworkBridge.getDiagramEditPart(layoutRootPart);

        layoutGraph = doBuildLayoutGraph(layoutRootPart);

        return layoutGraph;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void transferLayout(final boolean cacheLayout) {
        // create a new request to change the layout
        ApplyLayoutRequest applyLayoutRequest = new ApplyLayoutRequest();
        for (Entry<KGraphElement, IGraphicalEditPart> entry : graphElem2EditPartMap.entrySet()) {
            if (!(entry.getValue() instanceof DiagramEditPart)) {
                applyLayoutRequest.addElement(entry.getKey(), entry.getValue());
            }
        }
        for (LabelEditPart labelEditPart : emptyLabels) {
            KLabel label = KimlUtil.createInitializedLabel(null);
            applyLayoutRequest.addElement(label, labelEditPart);
        }
        KShapeLayout graphLayout = layoutGraph.getData(KShapeLayout.class);
        applyLayoutRequest.setUpperBound(graphLayout.getWidth(), graphLayout.getHeight());

        // retrieve a command for the request; the command is created by GmfLayoutEditPolicy
        applyLayoutCommand = diagramEditPart.getCommand(applyLayoutRequest);

        // store the layout data into a cache
        if (cacheLayout) {
            cachedLayout = new GmfCachedLayout(graphElem2EditPartMap.size());
            for (Entry<KGraphElement, IGraphicalEditPart> entry : graphElem2EditPartMap.entrySet()) {
                cachedLayout.addLayout(entry.getValue(), entry.getKey());
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void applyLayout() {
        // get a command stack to execute the command
        CommandStack commandStack = null;
        if (diagramEditorPart != null) {
            Object adapter = diagramEditorPart.getAdapter(CommandStack.class);
            if (adapter instanceof CommandStack) {
                commandStack = (CommandStack) adapter;
            }
        }
        if (commandStack == null) {
            commandStack = layoutRootPart.getDiagramEditDomain().getDiagramCommandStack();
        }

        // execute the command
        commandStack.execute(applyLayoutCommand);

        // refresh the border items in the diagram
        refreshDiagram(diagramEditorPart, layoutRootPart);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public KNode getLayoutGraph() {
        if (ancestryTargetNode != null) {
            return ancestryTargetNode;
        } else {
            return layoutGraph;
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected ICachedLayout getCachedLayout() {
        return cachedLayout;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public EditPart getEditPart(final KNode knode) {
        return graphElem2EditPartMap.get(knode);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public KNode getLayoutNode(final EditPart editPart) {
        KGraphElement graphElement = graphElem2EditPartMap.inverse().get(editPart);
        if (graphElement instanceof KNode) {
            return (KNode) graphElement;
        } else {
            return null;
        }
    }

    /**
     * Builds the layout graph for the given root edit part.
     * 
     * @param rootPart the root edit part for layout
     * @return layout graph layout graph that represents the structure contained in the root edit
     *         part
     */
    protected KNode doBuildLayoutGraph(final IGraphicalEditPart rootPart) {
        KNode topNode = KimlUtil.createInitializedNode();
        KShapeLayout shapeLayout = topNode.getData(KShapeLayout.class);
        Rectangle rootBounds = rootPart.getFigure().getBounds();
        // start with the whole diagram as root for layout
        if (rootPart instanceof DiagramEditPart) {
            topNode.getLabel().setText(((DiagramEditPart) rootPart).getDiagramView().getName());
            // start with a specific node as root for layout
        } else {
            shapeLayout.setPos(rootBounds.x, rootBounds.y);
        }
        shapeLayout.setSize(rootBounds.width, rootBounds.height);
        graphElem2EditPartMap.put(topNode, rootPart);

        // create a layout configuration
        GmfLayoutConfig layoutConfig;
        if (getExternalConfig() == null) {
            layoutConfig = new GmfLayoutConfig();
        } else {
            layoutConfig = new GmfLayoutConfig(getExternalConfig());
        }
        try {
            org.eclipse.swt.graphics.Point size = rootPart.getViewer().getControl().getSize();
            if (size.x > 0 && size.y > 0) {
                layoutConfig.setAspectRatio((float) size.x / size.y);
            }
        } catch (SWTException exception) {
            // ignore exception
        }
        
        // traverse the children of the layout root part
        buildLayoutGraphRecursively(rootPart, topNode, rootPart, layoutConfig, false);
        // set user defined layout options for the diagram
        layoutConfig.setFocus(rootPart);
        shapeLayout.copyProperties(layoutConfig);
        // transform all connections in the selected area
        processConnections(layoutConfig);

        // clean up the path of ancestors of the selected elements
        cleanupAncestryPath(topNode);
        return topNode;
    }

    /**
     * Recursively builds a layout graph by analyzing the children of the given edit part.
     * 
     * @param parentEditPart the parent edit part of the current elements
     * @param parentLayoutNode the corresponding KNode
     * @param currentEditPart the currently analyzed edit part
     * @param layoutConfig layout configuration handler
     * @return whether the element has any children (first component), and whether the
     *         element has any ports (second component)
     */
    private Pair<Boolean, Boolean> buildLayoutGraphRecursively(final IGraphicalEditPart parentEditPart,
            final KNode parentLayoutNode, final IGraphicalEditPart currentEditPart,
            final EclipseLayoutConfig layoutConfig, final boolean isCollapsed) {
        boolean hasChildNodes = false, hasPorts = false;
        Maybe<KInsets> kinsets = new Maybe<KInsets>();

        // set the target of layout ancestry if it was found
        if (ancestryTargetNode == null && ancestryTargetPart == currentEditPart) {
            ancestryTargetNode = parentLayoutNode;
        }

        // iterate through the children of the element
        for (Object obj : currentEditPart.getChildren()) {

            // check visibility of the child
            if (obj instanceof IGraphicalEditPart) {
                IFigure figure = ((IGraphicalEditPart) obj).getFigure();
                if (!figure.isVisible()) {
                    continue;
                }
            }

            // process a port (border item)
            if (obj instanceof AbstractBorderItemEditPart) {
                if (!isCollapsed) {
                    createPort((AbstractBorderItemEditPart) obj, parentEditPart, parentLayoutNode,
                            layoutConfig);
                }
                hasPorts = true;

            // process a compartment, which may contain other elements
            } else if (obj instanceof ShapeCompartmentEditPart
                && ((CompartmentEditPart) obj).getChildren().size() > 0) {
                CompartmentEditPart compartment = (CompartmentEditPart) obj;
                if (!GmfLayoutConfig.isNoLayout(compartment)) {
                    IFigure compartmentFigure = compartment.getFigure();
                    boolean compColl = isCollapsed;
                    if (compartmentFigure instanceof ResizableCompartmentFigure) {
                        ResizableCompartmentFigure resizCompFigure
                                = (ResizableCompartmentFigure) compartmentFigure;
                        // check whether the compartment is collapsed
                        if (!resizCompFigure.isExpanded()) {
                            compColl = true;
                        }
                    }

                    Pair<Boolean, Boolean> result = buildLayoutGraphRecursively(parentEditPart,
                            parentLayoutNode, compartment, layoutConfig, compColl);
                    hasChildNodes |= result.getFirst();
                }

            // process a node, which may be a parent of ports, compartments, or other nodes
            } else if (obj instanceof ShapeNodeEditPart) {
                ShapeNodeEditPart childNodeEditPart = (ShapeNodeEditPart) obj;
                if (!GmfLayoutConfig.isNoLayout(childNodeEditPart)) {
                    if (!isCollapsed) {
                        createNode(childNodeEditPart, parentEditPart, parentLayoutNode, layoutConfig,
                                kinsets);
                    }
                    hasChildNodes = true;
                }

            // process a label of the current node
            } else if (obj instanceof IGraphicalEditPart) {
                createNodeLabel((IGraphicalEditPart) obj, parentEditPart, parentLayoutNode,
                        layoutConfig);
            }
        }

        return new Pair<Boolean, Boolean>(hasChildNodes, hasPorts);
    }
    
    /**
     * Create a node while building the layout graph.
     * 
     * @param nodeEditPart the node edit part
     * @param parentEditPart the parent node edit part that contains the current node
     * @param parentKNode the corresponding parent layout node
     * @param layoutConfig a layout configuration
     * @param kinsets reference parameter for insets; the insets are calculated if this has
     *     not been done before
     */
    private void createNode(final ShapeNodeEditPart nodeEditPart,
            final IGraphicalEditPart parentEditPart, final KNode parentKNode,
            final EclipseLayoutConfig layoutConfig, final Maybe<KInsets> kinsets) {
        IFigure nodeFigure = nodeEditPart.getFigure();
        KNode childLayoutNode = KimlUtil.createInitializedNode();

        // set location and size
        Rectangle childBounds = KimlUiUtil.getAbsoluteBounds(nodeFigure);
        Rectangle containerBounds = KimlUiUtil
            .getAbsoluteBounds(nodeFigure.getParent());
        KShapeLayout nodeLayout = childLayoutNode.getData(KShapeLayout.class);
        nodeLayout.setXpos(childBounds.x - containerBounds.x);
        nodeLayout.setYpos(childBounds.y - containerBounds.y);
        nodeLayout.setSize(childBounds.width, childBounds.height);
        try {
            Dimension minSize = nodeFigure.getMinimumSize();
            nodeLayout.setProperty(LayoutOptions.MIN_WIDTH, (float) minSize.width);
            nodeLayout.setProperty(LayoutOptions.MIN_HEIGHT, (float) minSize.height);
        } catch (SWTException exception) {
            // ignore exception and leave the default minimal size
        }

        // set insets if not yet defined
        if (kinsets.get() == null) {
            KInsets ki = parentKNode.getData(KShapeLayout.class).getInsets();
            Insets insets = KimlUiUtil.calcInsets(parentEditPart.getFigure(), nodeFigure);
            ki.setLeft(insets.left);
            ki.setTop(insets.top);
            ki.setRight(insets.right);
            ki.setBottom(insets.bottom);
            kinsets.set(ki);
        }

        parentKNode.getChildren().add(childLayoutNode);
        graphElem2EditPartMap.put(childLayoutNode, nodeEditPart);
        // process the child as new current edit part
        Pair<Boolean, Boolean> result = buildLayoutGraphRecursively(nodeEditPart,
                childLayoutNode, nodeEditPart, layoutConfig, false);

        // set user defined layout options for the node
        layoutConfig.setFocus(nodeEditPart);
        layoutConfig.setChildren(result.getFirst());
        layoutConfig.setPorts(result.getSecond());
        nodeLayout.copyProperties(layoutConfig);

        // store all the connections to process them later
        addConnections(nodeEditPart);
    }
    
    /**
     * Create a port while building the layout graph.
     * 
     * @param portEditPart the port edit part
     * @param nodeEditPart the parent node edit part
     * @param knode the corresponding layout node
     * @param layoutConfig a layout configuration
     */
    private void createPort(final AbstractBorderItemEditPart portEditPart,
            final IGraphicalEditPart nodeEditPart, final KNode knode,
            final EclipseLayoutConfig layoutConfig) {
        KPort port = KimlUtil.createInitializedPort();
        graphElem2EditPartMap.put(port, portEditPart);
        port.setNode(knode);

        // set the port's layout, relative to the node position
        KShapeLayout portLayout = port.getData(KShapeLayout.class);
        Rectangle portBounds = KimlUiUtil.getAbsoluteBounds(portEditPart.getFigure());
        Rectangle nodeBounds = KimlUiUtil.getAbsoluteBounds(nodeEditPart.getFigure());
        float xpos = portBounds.x - nodeBounds.x;
        float ypos = portBounds.y - nodeBounds.y;
        portLayout.setPos(xpos, ypos);
        portLayout.setSize(portBounds.width, portBounds.height);
        
        // calculate port offset from the node border
        // FIXME this should not be done here!!!
        float offset = 0;
        KShapeLayout nodeLayout = knode.getData(KShapeLayout.class);
        float widthPercent = (xpos + portBounds.width / 2) / nodeLayout.getWidth();
        float heightPercent = (ypos + portBounds.height / 2) / nodeLayout.getHeight();
        if (widthPercent + heightPercent <= 1
                && widthPercent - heightPercent <= 0) {
            // port is on the left
            offset = -(xpos + portBounds.width);
            portLayout.setProperty(LayoutOptions.PORT_SIDE, PortSide.WEST);
        } else if (widthPercent + heightPercent >= 1
                && widthPercent - heightPercent >= 0) {
            // port is on the right
            offset = xpos - nodeLayout.getWidth();
            portLayout.setProperty(LayoutOptions.PORT_SIDE, PortSide.EAST);
        } else if (heightPercent < 1.0f / 2) {
            // port is on the top
            offset = -(ypos + portBounds.height);
            portLayout.setProperty(LayoutOptions.PORT_SIDE, PortSide.NORTH);
        } else {
            // port is on the bottom
            offset = ypos - nodeLayout.getHeight();
            portLayout.setProperty(LayoutOptions.PORT_SIDE, PortSide.SOUTH);
        }
        if (offset != 0) {
            portLayout.setProperty(LayoutOptions.OFFSET, offset);
        }
        
        // set user defined layout options for the port
        layoutConfig.setFocus(portEditPart);
        portLayout.copyProperties(layoutConfig);

        // store all the connections to process them later
        addConnections(portEditPart);

        // set the port label
        for (Object portChildObj : portEditPart.getChildren()) {
            if (portChildObj instanceof IGraphicalEditPart) {
                IFigure labelFigure = ((IGraphicalEditPart) portChildObj).getFigure();
                String text = null;
                if (labelFigure instanceof WrappingLabel) {
                    text = ((WrappingLabel) labelFigure).getText();
                } else if (labelFigure instanceof Label) {
                    text = ((Label) labelFigure).getText();
                }
                if (text != null) {
                    KLabel portLabel = port.getLabel();
                    portLabel.setText(text);
                    graphElem2EditPartMap.put(portLabel, (IGraphicalEditPart) portChildObj);
                    // set the port label's layout
                    KShapeLayout labelLayout = portLabel.getData(KShapeLayout.class);
                    Rectangle labelBounds = KimlUiUtil.getAbsoluteBounds(labelFigure);
                    labelLayout.setXpos(labelBounds.x - portBounds.x);
                    labelLayout.setYpos(labelBounds.y - portBounds.y);
                    try {
                        Dimension size = labelFigure.getPreferredSize();
                        labelLayout.setWidth(size.width);
                        labelLayout.setHeight(size.height);
                    } catch (SWTException exception) {
                        // ignore exception and leave the label size to (0, 0)
                    }
                    layoutConfig.setFocus(portChildObj);
                    labelLayout.copyProperties(layoutConfig);
                    // port labels are excluded from layout by default
                    labelLayout.setProperty(LayoutOptions.NO_LAYOUT, true);
                }
            }
        }
    }
    
    /**
     * Create a node label while building the layout graph.
     * 
     * @param labelEditPart the label edit part
     * @param nodeEditPart the parent node edit part
     * @param knode the layout node for which the label is set
     * @param layoutConfig a layout configuration
     */
    private void createNodeLabel(final IGraphicalEditPart labelEditPart,
            final IGraphicalEditPart nodeEditPart, final KNode knode, final ILayoutConfig layoutConfig) {
        IFigure labelFigure = labelEditPart.getFigure();
        String text = null;
        Font font = null;
        if (labelFigure instanceof WrappingLabel) {
            WrappingLabel wrappingLabel = (WrappingLabel) labelFigure;
            text = wrappingLabel.getText();
            font = wrappingLabel.getFont();
        } else if (labelFigure instanceof Label) {
            Label label = (Label) labelFigure;
            text = label.getText();
            font = label.getFont();
        }
        KLabel label = knode.getLabel();
        if (text != null && (label.getText() == null || label.getText().length() == 0)) {
            label.setText(text);
            graphElem2EditPartMap.put(label, labelEditPart);
            KShapeLayout labelLayout = label.getData(KShapeLayout.class);
            Rectangle labelBounds = KimlUiUtil.getAbsoluteBounds(labelFigure);
            Rectangle nodeBounds = KimlUiUtil.getAbsoluteBounds(nodeEditPart.getFigure());
            labelLayout.setXpos(labelBounds.x - nodeBounds.x);
            labelLayout.setYpos(labelBounds.y - nodeBounds.y);
            try {
                Dimension size = labelFigure.getPreferredSize();
                labelLayout.setSize(size.width, size.height);
                labelLayout.setProperty(LayoutOptions.FONT_NAME,
                        font.getFontData()[0].getName());
                labelLayout.setProperty(LayoutOptions.FONT_SIZE,
                    font.getFontData()[0].getHeight());
            } catch (SWTException exception) {
                // ignore exception and leave the label size to (0, 0)
            }
            layoutConfig.setFocus(labelEditPart);
            labelLayout.copyProperties(layoutConfig);
            // exclude the label from layout by default
            labelLayout.setProperty(LayoutOptions.NO_LAYOUT, true);
        }
    }

    /**
     * Adds all target connections and connected connections to the list of connections that must be
     * processed later.
     * 
     * @param editPart an edit part
     */
    private void addConnections(final IGraphicalEditPart editPart) {
        for (Object targetConn : editPart.getTargetConnections()) {
            if (targetConn instanceof ConnectionEditPart) {
                ConnectionEditPart connectionEditPart = (ConnectionEditPart) targetConn;
                connections.add(connectionEditPart);
                addConnections(connectionEditPart);
            }
        }
    }

    /**
     * Creates new edges and takes care of the labels for each connection identified in the
     * {@code buildLayoutGraphRecursively} method.
     * 
     * @param layoutConfig layout configuration handler
     */
    private void processConnections(final ILayoutConfig layoutConfig) {
        Map<EReference, KEdge> reference2EdgeMap = new HashMap<EReference, KEdge>();
        for (ConnectionEditPart connection : connections) {
            boolean isOppositeEdge = false;
            EdgeLabelPlacement edgeLabelPlacement = EdgeLabelPlacement.UNDEFINED;
            KEdge edge;

            // check whether the edge belongs to an Ecore reference, which may have opposites
            EObject modelObject = connection.getNotationView().getElement();
            if (modelObject instanceof EReference) {
                EReference reference = (EReference) modelObject;
                edge = reference2EdgeMap.get(reference.getEOpposite());
                if (edge != null) {
                    edgeLabelPlacement = EdgeLabelPlacement.TAIL;
                    isOppositeEdge = true;
                } else {
                    edge = KimlUtil.createInitializedEdge();
                    reference2EdgeMap.put(reference, edge);
                }
            } else {
                edge = KimlUtil.createInitializedEdge();
            }

            // find a proper source node and source port
            KGraphElement sourceElem;
            EditPart sourceObj = connection.getSource();
            if (sourceObj instanceof ConnectionEditPart) {
                sourceElem = graphElem2EditPartMap.inverse()
                        .get(((ConnectionEditPart) sourceObj).getSource());
                if (sourceElem == null) {
                    sourceElem = graphElem2EditPartMap.inverse()
                            .get(((ConnectionEditPart) sourceObj).getTarget());
                }
            } else {
                sourceElem = graphElem2EditPartMap.inverse().get(sourceObj);
            }
            KNode sourceNode = null;
            KPort sourcePort = null;
            if (sourceElem instanceof KNode) {
                sourceNode = (KNode) sourceElem;
            } else if (sourceElem instanceof KPort) {
                sourcePort = (KPort) sourceElem;
                sourceNode = sourcePort.getNode();
            } else {
                continue;
            }
            
            // calculate offset for edge and label coordinates
            float offsetx = 0, offsety = 0;
            KNode sourceParentNode = sourceNode.getParent();
            IGraphicalEditPart sourceParent = graphElem2EditPartMap.get(sourceParentNode);
            if (sourceParent != null) {
                Rectangle sourceParentBounds = KimlUiUtil.getAbsoluteBounds(sourceParent.getFigure());
                KInsets insets = sourceParentNode.getData(KShapeLayout.class).getInsets();
                offsetx = sourceParentBounds.x + insets.getLeft();
                offsety = sourceParentBounds.y + insets.getTop();
            }

            if (!isOppositeEdge) {
                // set source node and source port
                edge.setSource(sourceNode);
                if (sourcePort != null) {
                    edge.setSourcePort(sourcePort);
                    sourcePort.getEdges().add(edge);
                }
                
                // find a proper target node and target port
                KGraphElement targetElem;
                EditPart targetObj = connection.getTarget();
                if (targetObj instanceof ConnectionEditPart) {
                    targetElem = graphElem2EditPartMap.inverse()
                        .get(((ConnectionEditPart) targetObj).getTarget());
                    if (targetElem == null) {
                        targetElem = graphElem2EditPartMap.inverse()
                                .get(((ConnectionEditPart) targetObj).getSource());
                    }
                } else {
                    targetElem = graphElem2EditPartMap.inverse().get(targetObj);
                }
                if (targetElem instanceof KNode) {
                    edge.setTarget((KNode) targetElem);
                } else if (targetElem instanceof KPort) {
                    KPort targetPort = (KPort) targetElem;
                    edge.setTargetPort(targetPort);
                    targetPort.getEdges().add(edge);
                    edge.setTarget(targetPort.getNode());
                } else {
                    edge.setSource(null);
                    if (edge.getSourcePort() != null) {
                        edge.getSourcePort().getEdges().remove(edge);
                    }
                    continue;
                }

                graphElem2EditPartMap.put(edge, connection);

                // store the current coordinates of the edge
                KEdgeLayout edgeLayout = edge.getData(KEdgeLayout.class);
                setEdgeLayout(edgeLayout, connection, offsetx, offsety);

                // set user defined layout options for the edge
                layoutConfig.setFocus(connection);
                edgeLayout.copyProperties(layoutConfig);
            }

            // process edge labels
            processEdgeLabels(connection, edge, edgeLabelPlacement, offsetx, offsety, layoutConfig);
        }
    }

    /**
     * Stores the layout information of the given connection edit part into an edge layout.
     * 
     * @param edgeLayout an edge layout
     * @param connection a connection edit part
     * @param offsetx horizontal offset to be subtracted from coordinates
     * @param offsety vertical offset to be subtracted from coordinates
     */
    protected void setEdgeLayout(final KEdgeLayout edgeLayout, final ConnectionEditPart connection,
        final float offsetx, final float offsety) {
        Connection figure = connection.getConnectionFigure();
        PointList pointList = figure.getPoints();
        KPoint sourcePoint = edgeLayout.getSourcePoint();
        Point firstPoint = KimlUiUtil.getAbsolutePoint(figure, 0);
        sourcePoint.setX(firstPoint.x - offsetx);
        sourcePoint.setY(firstPoint.y - offsety);
        for (int i = 1; i < pointList.size() - 1; i++) {
            Point point = KimlUiUtil.getAbsolutePoint(figure, i);
            KPoint kpoint = KLayoutDataFactory.eINSTANCE.createKPoint();
            kpoint.setX(point.x - offsetx);
            kpoint.setY(point.y - offsety);
            edgeLayout.getBendPoints().add(kpoint);
        }
        KPoint targetPoint = edgeLayout.getTargetPoint();
        Point lastPoint = KimlUiUtil.getAbsolutePoint(figure, pointList.size() - 1);
        targetPoint.setX(lastPoint.x - offsetx);
        targetPoint.setY(lastPoint.y - offsety);
    }

    /**
     * Process the labels of an edge.
     * 
     * @param connection the connection edit part
     * @param edge the layout edge
     * @param placement predefined placement for all labels, or {@code UNDEFINED} if the placement
     *            shall be derived from the edit part
     * @param offsetx the offset for horizontal coordinates
     * @param offsety the offset for vertical coordinates
     * @param layoutConfig layout configuration handler
     */
    protected void processEdgeLabels(final ConnectionEditPart connection, final KEdge edge,
        final EdgeLabelPlacement placement, final float offsetx, final float offsety,
        final ILayoutConfig layoutConfig) {
        /*
         * ars: source and target is exchanged when defining it in the gmfgen file. So if Emma sets
         * a label to be placed as target on a connection, then the label will show up next to the
         * source node in the diagram editor. So correct it here, very ugly.
         */
        for (Object obj : connection.getChildren()) {
            if (obj instanceof LabelEditPart) {
                LabelEditPart labelEditPart = (LabelEditPart) obj;
                IFigure labelFigure = labelEditPart.getFigure();
                Rectangle labelBounds = KimlUiUtil.getAbsoluteBounds(labelFigure);
                String labelText = null;
                Dimension iconBounds = null;
                if (labelFigure instanceof WrappingLabel) {
                    WrappingLabel wrappingLabel = (WrappingLabel) labelFigure;
                    labelText = wrappingLabel.getText();
                    if (wrappingLabel.getIcon() != null) {
                        iconBounds = new Dimension();
                        iconBounds.width = wrappingLabel.getIcon().getBounds().width
                            + wrappingLabel.getIconTextGap();
                        iconBounds.height = wrappingLabel.getIcon().getBounds().height;
                        labelText = "O " + labelText;
                    }
                } else if (labelFigure instanceof Label) {
                    Label label = (Label) labelFigure;
                    labelText = label.getText();
                    if (label.getIcon() != null) {
                        iconBounds = label.getIconBounds().getSize();
                        iconBounds.width += label.getIconTextGap();
                        labelText = "O " + labelText;
                    }
                }
                if (labelText != null && labelText.length() > 0) {
                    KLabel label = KimlUtil.createInitializedLabel(edge);
                    KShapeLayout labelLayout = label.getData(KShapeLayout.class);
                    if (placement == EdgeLabelPlacement.UNDEFINED) {
                        switch (labelEditPart.getKeyPoint()) {
                        case ConnectionLocator.SOURCE:
                            labelLayout.setProperty(LayoutOptions.EDGE_LABEL_PLACEMENT,
                                EdgeLabelPlacement.HEAD);
                            break;
                        case ConnectionLocator.MIDDLE:
                            labelLayout.setProperty(LayoutOptions.EDGE_LABEL_PLACEMENT,
                                EdgeLabelPlacement.CENTER);
                            break;
                        case ConnectionLocator.TARGET:
                            labelLayout.setProperty(LayoutOptions.EDGE_LABEL_PLACEMENT,
                                EdgeLabelPlacement.TAIL);
                            break;
                        }
                    } else {
                        labelLayout.setProperty(LayoutOptions.EDGE_LABEL_PLACEMENT, placement);
                    }
                    Font font = labelFigure.getFont();
                    if (font != null && !font.isDisposed()) {
                        labelLayout.setProperty(LayoutOptions.FONT_NAME,
                            font.getFontData()[0].getName());
                        labelLayout.setProperty(LayoutOptions.FONT_SIZE,
                            font.getFontData()[0].getHeight());
                    }
                    labelLayout.setXpos(labelBounds.x - offsetx);
                    labelLayout.setYpos(labelBounds.y - offsety);
                    if (iconBounds != null) {
                        labelLayout.setWidth(labelBounds.width + iconBounds.width);
                    } else {
                        labelLayout.setWidth(labelBounds.width);
                    }
                    labelLayout.setHeight(labelBounds.height);
                    label.setText(labelText);
                    edge.getLabels().add(label);
                    graphElem2EditPartMap.put(label, labelEditPart);
                    
                    layoutConfig.setFocus(labelEditPart);
                    labelLayout.copyProperties(layoutConfig);
                    // exclude the label from layout by default
                    labelLayout.setProperty(LayoutOptions.NO_LAYOUT, true);
                } else {
                    emptyLabels.add(labelEditPart);
                }
            }
        }
    }

    /**
     * Cleans the path from the ancestry target node to the top level node, including all parallel
     * paths.
     * 
     * @param topNode the top level node
     */
    protected void cleanupAncestryPath(final KNode topNode) {
        if (ancestryTargetNode != null) {
            KNode previousNode = ancestryTargetNode;
            KNode parent = ancestryTargetNode.getParent();
            while (parent != null) {
                for (KNode child : parent.getChildren()) {
                    if (child != previousNode) {
                        KShapeLayout childLayout = child.getData(KShapeLayout.class);
                        childLayout.setProperty(LayoutOptions.FIXED_SIZE, true);
                        childLayout.setProperty(LayoutOptions.PORT_CONSTRAINTS,
                                PortConstraints.FIXED_POS);
                        removeFromLayout(child);
                    }
                }
                previousNode = parent;
                parent = parent.getParent();
            }
        }
    }

    /**
     * Removes the given node and all its children from layout.
     * 
     * @param node a layout node
     */
    private void removeFromLayout(final KNode node) {
        for (KNode child : node.getChildren()) {
            graphElem2EditPartMap.remove(child);
            child.getData(KShapeLayout.class).setProperty(LayoutOptions.NO_LAYOUT, true);
            graphElem2EditPartMap.remove(child.getLabel());
            for (KPort port : child.getPorts()) {
                graphElem2EditPartMap.remove(port);
                port.getData(KShapeLayout.class).setProperty(LayoutOptions.NO_LAYOUT, true);
                graphElem2EditPartMap.remove(port.getLabel());
            }
            for (KEdge edge : child.getOutgoingEdges()) {
                graphElem2EditPartMap.remove(edge);
                edge.getData(KEdgeLayout.class).setProperty(LayoutOptions.NO_LAYOUT, true);
                for (KLabel edgeLabel : edge.getLabels()) {
                    graphElem2EditPartMap.remove(edgeLabel);
                }
            }
            removeFromLayout(child);
        }
    }

    /**
     * Refreshes all ports in the diagram. This is necessary in order correctly move ports,
     * which does not work due to GMF bugs. See Eclipse bug #291484.
     * 
     * @param editor the diagram editor
     * @param rootPart the root edit part
     */
    private static void refreshDiagram(final DiagramEditor editor,
            final IGraphicalEditPart rootPart) {
        EditPart editPart = rootPart;
        if (editPart == null) {
            editPart = editor.getDiagramEditPart();
        }
        for (Object obj : editPart.getViewer().getEditPartRegistry().values()) {
            if (obj instanceof ShapeNodeEditPart) {
                IFigure figure = ((ShapeNodeEditPart) obj).getFigure();
                if (figure instanceof BorderedNodeFigure) {
                    IFigure portContainer = ((BorderedNodeFigure) figure)
                            .getBorderItemContainer();
                    portContainer.invalidate();
                    portContainer.validate();
                }
            }
        }
    }

}
