grammar de.cau.cs.kieler.core.expressions.Expressions with  org.eclipse.xtext.common.Terminals

import "platform:/resource/de.cau.cs.kieler.core.expressions/model/expressions.ecore" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// --------------------------
//
//   EXPRESSIONS
//
// --------------------------

Expression returns Expression:
	BooleanExpression
	| ValuedExpression
	;

// Example: not D and C or ?E = 42 or not (A and (B or C))
BooleanExpression returns Expression:
	OrExpression;

// Example: A or B, A and B and C, C and B or D and not E, A and B and C
OrExpression returns Expression:
	AndExpression ({OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=AndExpression)*;

// Example: A and B, not C and 42 <= ?D
AndExpression returns Expression:
	CompareOperation ({OperatorExpression.subExpressions+=current} operator=AndOperator subExpressions+=CompareOperation)*;

// Example: 42 <= ?A
CompareOperation returns Expression:
	NotOrValuedExpression ({OperatorExpression.subExpressions+=current} operator=CompareOperator subExpressions+=NotOrValuedExpression)
	| NotExpression
	;

// order IS IMPORTANT
NotOrValuedExpression returns Expression:
	ValuedExpression
	| NotExpression
    ;

// everything that evaluates to a primitive number value
ValuedExpression returns Expression:
	AddExpression;

// Example: 1 + 2
AddExpression returns Expression:
	SubExpression ({OperatorExpression.subExpressions+=current} operator=AddOperator subExpressions+=SubExpression)*;

// Example: varA - ?B
SubExpression returns Expression:
	MultExpression ({OperatorExpression.subExpressions+=current} operator=SubOperator subExpressions+=MultExpression)*;

// Example: 2 * 4
MultExpression returns Expression:
	ModExpression ({OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=ModExpression)*;

// Example: varA mod ?B
ModExpression returns Expression:
	AtomicValuedExpression ({OperatorExpression.subExpressions+=current} operator=ModOperator subExpressions+=AtomicValuedExpression)?;

// Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding
NotExpression returns Expression:
	{OperatorExpression} operator=NotOperator subExpressions+=(NotExpression)
    | AtomicExpression
    ;
    
AtomicExpression returns Expression:
    BooleanValue
    | ValuedObjectTestExpression
    | '(' BooleanExpression ')'
    | TextExpression
    ;

AtomicValuedExpression returns Expression:
    IntValue
    | FloatValue
    | '(' DivExpression ')'
    | '(' ValuedExpression ')'
    | AtomicExpression 
    ;

// Example: (2 / 4)
// note: division always has to have parantheses because the '/' sign is also used for trigger/effect delimiter
DivExpression returns Expression:
	AtomicValuedExpression {OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=AtomicValuedExpression;

// Example: pre(pre(?A)), pre(pre(A)), ?A, A varX
ValuedObjectTestExpression returns Expression:
	{OperatorExpression} operator=PreOperator '('subExpressions+=ValuedObjectTestExpression')'
	| {OperatorExpression} operator=ValueTestOperator subExpressions+=ValuedObjectReference
	| ValuedObjectReference
	;

// Example: A, varB
ValuedObjectReference returns ValuedObjectReference:
	valuedObject=[ValuedObject|ID];

// Taken from oba's kits grammar
//TextExpression returns TextExpression: 
//	code=STRING ("(" type=ID ")")?; 

// Taken from haf's kits grammar
TextExpression returns TextExpression:
	code=STRING ("(" type=ID ")")?;

IntValue returns IntValue:
	value=INT;

FloatValue returns FloatValue:
	value=Float;

BooleanValue returns BooleanValue:
	value=Boolean;

EString returns ecore::EString:
	STRING | ID;

enum CompareOperator returns OperatorType:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";

enum PreOperator returns OperatorType:
    PRE="pre";

enum OrOperator returns OperatorType:
	OR="or";

enum AndOperator returns OperatorType:
	AND="and";

enum NotOperator returns OperatorType:
	NOT="not";

enum AddOperator returns OperatorType:
	ADD="+";
	
enum SubOperator returns OperatorType:
	SUB="-";
	
enum MultOperator returns OperatorType:	
	MULT="*";

enum ModOperator returns OperatorType:	
	MOD="mod";

enum DivOperator returns OperatorType:	
	DIV="/";

enum ValueTestOperator returns OperatorType:
	VAL="?";


/*
   the following declarations are re-used in Interface.xtext, Kits.xtext 
*/
enum ValueType returns ValueType:
	PURE="PURE" | BOOL="BOOL" | UNSIGNED="UNSIGNED"	| 
	INT="INT" | FLOAT="FLOAT" | HOST="HOST"	
;

enum CombineOperator returns CombineOperator:
	NONE="NONE" | ADD="+" | MULT="*" | MAX="max" |
	MIN="min" | OR="or" | AND="and" | HOST="host"
;

// redefine INT terminal to allow negative numbers
terminal INT returns ecore::EInt:
 '-'?('0'..'9')+;

// make sure the Float rule does not shadow the INT rule
terminal Float returns ecore::EFloatObject : ((INT"."INT | INT("."INT)?("e"|"E")("+")?INT))"f"? | INT"f";
terminal Boolean returns ecore::EBooleanObject : "true" | "false";



