import synccharts;
import expressions;

transform(Scope scope) :
	selectReferenceMacroStates(scope).expandMacroState() -> scope
;

selectReferenceMacroStates(Scope scope) :
	scope.eAllContents.typeSelect(State).select(state|state.type==StateType::REFERENCE)
	;

/* As for now we only want Synccharts::States to be expanded, other types 
 * are transformed to a "legacy mode"*/
expandMacroState(State target) :
    let referencedState = target.bodyReference :
    State.isInstance(referencedState) ?        
        target.expandSyncChartsState()
        : null
        ;
        
/* Expand a given referenceMacroState which has a bodyReference to a SyncChart State*/
State expandSyncChartsState (State referencingState):
    let referencedState = referencingState.bodyReference.copyState() :
    let localSignals = referencedState.signals.select(e|e.isInput==false).select(e|e.isOutput==false) :
    /* Recursive transform all referenceMacroStates.*/
    let referencedExpandedState = transform(referencedState) :
    let regions = referencedState.regions :
    let newName = getExpandedStateName(referencingState, referencedState) :
    /* First we add all regions of the referenced state. */
    referencingState.regions.addAll(regions) ->
    /* We preserve the local signals of the referenced state. */
    referencingState.signals.addAll(localSignals) ->
    /* We change the name of the referencing state. */
    referencingState.setLabel(newName) ->
    /* After the expansion we change the type from REFERENCE to NORMAL. */
    referencingState.changeTypeToNormal() ->
    /* We substitute the signals depending on the given renamings. */
    referencingState.renamings.executeSubstitution() ->
    /* After substitution we delete the renamings as we dont need them anymore. */
    referencingState.removeAllRenamings() ->
    /* Return the expanded state. */
    referencingState
;

getExpandedStateName(State referencingState, State referencedState) :
    referencingState.label + "@" + referencedState.label;

changeTypeToNormal(State s) :
	s.setType(StateType::NORMAL) ->
	s.setBodyReference(null);
	
State castToState(Object object) :
    (State) object;

Void executeSubstitution(Substitution renaming) :
    let referencingState = (State) renaming.parentScope :
    let oldID = renaming.formal :
    let newID = renaming.actual :
    let newSignal = getSignalForName(referencingState, newID) :
    let signalReferences = referencingState.eAllContents.typeSelect(ValuedObjectReference).select(e|Signal.isInstance(e) && e.valuedObject.name==oldID) :
    let emissions = referencingState.eAllContents.typeSelect(Emission).select(e|e.signal.name==oldID) :
    (signalReferences.size > 0 ? renameValuedObjectReference(signalReferences, newSignal) : null) ->
    (emissions.size > 0 ? renameEmission(emissions, newSignal) : null)
    ;
    
    
/*Recursively removes all renamings of a given state.
  ATM does not work the obvious way via:
    state.renamings.deleteRenaming()
  therefore use eAllcontent.typeSelect instead.
  Might be changed to more efficient method.*/
Void removeAllRenamings(State state) :
    state.eAllContents.typeSelect(Substitution).deleteSubstitution()
    ;
 
Void deleteSubstitution(Substitution renaming) :
    renaming.delete()
;

    
Void renameValuedObjectReference(List[ValuedObjectReference] valuedObjectReferences, ValuedObject newVO) :
    valuedObjectReferences.setValuedObject(newVO);

Void renameEmission(List[Emission] emission, Signal newSignal) :
    emission.setSignal(newSignal);

Signal getSignalForName(State state, String name) :
    let signals = state.signals :
    signals.exists(e|e.name==name) ?
        signals.selectFirst(e|e.name == name) :
            ((state.parentRegion != null || state.parentRegion.parentState != null) ?
                getSignalForName(state.parentRegion.parentState, name) :
                null);


State copyState(Object object) :
    let state = (State) copy(object) :
    state;
    
Object copy(Object object) :
	JAVA de.cau.cs.kieler.synccharts.diagram.custom.commands.Utils.copy(java.lang.Object)
;

Void delete (emf::EObject eobject):
    JAVA org.eclipse.emf.ecore.util.EcoreUtil.delete(org.eclipse.emf.ecore.EObject);