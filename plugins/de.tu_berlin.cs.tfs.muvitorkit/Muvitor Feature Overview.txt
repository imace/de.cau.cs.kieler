================= General framework =============================
- MuvitorKit stands for Multi Viewer Editors.
- Multiple View(er)s in two senses:
  1. multiple views the main editor can open besides
     (e.g. one view for displaying each possible kind of instance contained in the model: graphs, petri nets, rules etc.)
  2. AND support for an arbitrary number of graphical viewers hosted inside a view
     (e.g. a view for transformation rules containing two graphical viewers, each displaying a graph/petri net as the rule's LHS and RHS, maybe even with a third one displaying a NAC)
Most generalizations of editor features are only possible because we assume to have a generated EMF model and make use of EMF's special features.
The whole Muvitor framework and its integral parts are tailored to be used together with an EMF model.

Main class MuvitorTreeEditor:
- needs to be registered in plugin.xml via extensions
- abstract basic but comprehensive implementation to attach the editor to the Eclipse workbench
- just a few abstract methods have to be filled to get a rich-featured editor:
  + subclasses have to create EditPartFactory, register custom editor actions, ContextMenuProvider, a default model instance (for empty or new files)
- uses information from plugin.xml:
  + file extension and perspective (set on editor activation), but also customary retrieval of other information possible
- installs most of the actions provided by GEF in each custom editor:
  + SaveAction,UndoAction,RedoAction,PrintAction,DirectEditAction,DeleteAction,AlignmentAction
  + automatic updating of actions on most events that would need the actions to change their enablement status
- static method showView(EObject) for the first multiplicity aspect (of Eclipse views)
  + need to register EClasses with IDs corresponding to views in plugin.xml before, once
  + associates unique IDs of EMF model elements (IDs automatically generated by EMF) with MuvitorPageBookView (according to viewID) to display this element (hint: the view's secondary ID is used for this)
  + opens MuvitorPageBookView, see below for details
  + mechanism to automatically close a view on deletion of the model element it displays
  + similiar counterpart closeViewsShowing(EObject)
- stores all currently shown views when the editor is being closed (via saveState(IMemento)), reopens these views when the editor is activate again
- implements IGotoMarker: if custom editors create problem markers, user may "open" these in the Problem View, which invokes showView() so that the problematic part is displayed
- basic revert mechanism (invoked by RevertAction, see below)
- several special adjustments and details for better support of the multi view concept, e.g. keep the editor's action bar enabled if the user selects something in an associated view

MuvitorPageBookView:
- the view class whose instances are managed by the MuvitorTreeEditor to display its tree elements graphically (or even subparts of other elements in graphical views, which allows nested hierachies, e.g. nested graphs)
- needs to be registered in plugin.xml via extensions
- basic abstract implementation, just abstract methods getPageForModel(EObject) and calculatePartName() need to be implemented
- remark: the only information you can pass when opening a view is the main and secondary id. The main id determines what kind of model the view should display (see MuvitorPage below), the secondary ID determines the exact EMF model instance (by equality to unique EMF ID)
- retrieves the model for the ID and creates a page for it; each MuvitorPageBookView contains exactly one page (in Eclipse there is no other possiblity to display a single page directly)
- reevaluates calculatePartName() on model notifications and updates the view's tab name

MuvitorPage:
- based on GEF's sample editor implementation GraphicalEditorImpl but with many extensions
- responsible for the second multiplicity aspect (of graphical viewERs in a view)
- prepared to support animation package
- abstract basic but comprehensive implementation
  + to embed the page properly into the MuvitorPageBookView and to provide access to the model element to be displayed
  + to connect it to the main editor, for accessing the shared CommandStack, shared Action instances, the SelectionSynchronizer, the PropertySheetPage etc.)
- similiar to the main editor, just a few abstract methods have to be filled:
  + subclasses have to create EditPartFactory, register custom editor actions (the page keeps has its own action registry), ContextMenuProvider, create a MuvitorPaletteRoot
  + most important: define the contents of the viewers as array of EMF model elements (e.g. LHS and RHS graphs of the rule that is the model to be displayed); this also determines the number of viewers
- installs by default
  + a single flyout palette on the right side of the page
  + some useful generic actions for graphical viewers (see below)
  + a thumbnail figure of the graphical viewer below the palette
- changes the current graphical viewer depending on the selected edit parts
  + manages everything related to this:
  + update the ZoomManagerDelegate and the thumbnail figure with the new current graphical viewer
  + update the actions and the page's selection provider
- provides well-documented methods to normalize all cases of action registration
- allows to dynamically set new contents for the viewers and switch each viewer's visibility
- prepares graphical viewers for showing rulers and grid

================= GEF specific ==================================
Extended abstract EditParts: Adapter{Tree/Connection/Graphical}EditPart
- encapsulates and documents EMF adapter registration in registerAdapter(adapter) and deregisters them on deactivation
- provides default EObjectPropertySource for Properties View, showing all of the EMF model's attributes and their values
- forward EMF notifications to GlobalNotifierService
- by default, calls MuvitorTreeEditor.showView(model) on "OPEN" request
- by default, runs Muvitor[Tree]DirectEditManager on "DIRECT_EDIT" request if concrete edit part implements IDirectEditPart
- prepared for easy enabling of direct edit, see below

MuvitorPaletteRoot:
- default Palette for Viewers on MuvitorPages
- encapsulates and documents installation of new ToolEntries in a flexible method addToolEntry(), which allows to specify the tool class (for custom tools with special behavior)
- MappingCreationTool is a special ConnectionCreationTool, allowing connections between edit parts in different viewers (this tool remains in valid state when mouse leaves the viewer's border)

ContextMenuProviderWithActionRegistry:
- default context menu provider for all default actions in MuvitorTreeEditors, with two methods to simply add more registered actions to a subclass menu

Support for generic Direct Edit on all extended Edit Parts:
- to enable direct edit on an Adapter{Tree/Connection/Graphical}EditPart it just have to implement IDirectEditPart, everything else is encapsuled
- IDirectEditPart: interface for Adapter{Tree/Connection/Graphical}EditParts. Allows to specify
1) the ID of one of the model's features (as in the EPackage, e.g. EcorePackage.ENAMED_ELEMENT__NAME) to be edited
2) an ICellEditorValidator for checking the direct edit input (the edit part's Muvitor[Tree]DirectEditManager will popup possible error messages)
- Muvitor[Tree]DirectEditManager and Muvitor[Tree]DirectEditPolicy (invoked and installed by default, see above) use SetEObjectFeatureValueCommand to set the value of the feature with the specified ID

================= Other functionalities, templates ==========================
MuvitorFileCreationWizard:
- Wizard that creates a new empty file (MuvitorTreeEditor fills this with an empty default model)
- just needs to be defined in plugin.xml
- automatically retrieves from plugin.xml the file extension to which the editor is bound

IconUtilTemplate:
- proposes a universal way to access image files in the project path via definable keys
- uses caching mechanism of the plugin's ImageRegistry

PropertySources for Properties View:
- AbstractPropertySource encapsulates and documents consistent implementation of property sources.
- generic EObjectPropertySource showing attributes of an EMF model and their values with appropriate PropertyDescriptors

Generic Actions:
- ExportViewerImageAction: Export a GraphicalViewer as PNG,JPEG,BMP
- GenericGraphLayoutAction: Applies the Draw2d graph layouter to the EditPartViewer containing some selected GraphicalEditPart. Uses ChangeBoundsRequest on NodeEditParts.
- GenericGraphLayoutZESTAction: Applies the ZEST graph layouts to the EditPartViewer containing some selected GraphicalEditPart. Features a menu, from which the user may select one of the ZEST layout algorithms.
- MoveNodeAction: Action for moving selected nodes that can be moved by key strokes.
- TrimViewerAction: Trims the viewer containing the currently selected GraphicalEditPart. All editparts that return an executable command for a move request will be moved so that the viewers size is minimized but still showing all figures.
- SelectAllInMultiViewerAction: Selects all edit parts in the current viewer of an AbstractMultiViewerPage
- GenericCopyAction: Copies any EMF model in form of a serialized String into the system's clipboard
- GenericPasteAction: Pastes the clipboard into the current edit part's EMF model if allowed. Supports Undo and flexible PasteRules.
- MuvitorToggleGridAction: Action to toggle the grid visibility of an EditPartViewer
- MuvitorToggleRulerVisibilityAction: Action to toggle the ruler visibility of an EditPartViewer
- RevertAction: Action to invoke the revert mechanism of a MuvitorTreeEditor.

EMFModelManager:
- manages load and save operations on the EMF model
- handled completely by the MuvitorTreeEditor, no additional implementation needed

================= Animation package ==============================
- Animation package (+ ToggleAnimationAction) works nicely but is not final. Several features to be added, which need restructuring.

================= Future work ====================================
- only one editor (i.e. only one file) can be opened at the same time, but extension is not too complicated and already planned
- at most one (custom) editor plugin project can use a copy of MuvitorKit in its dependencies (This is due to the fact that the classes accessing the plugins registries are located in MuvitorKit. Generalization is possible but would need more preparation when implementing custom editor. )
- possibility to export an editor based on Muvitor as independent RCP application