grammar de.cau.cs.kieler.synccharts.TransitionLabel with org.eclipse.xtext.common.Terminals

generate transitionlabel "http://kieler.cs.cau.de/synccharts/actionlabel"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// dummy rule to test the language in an editor
Model : 
	((signals+=Signal | variables+=Variable))* (actions+=Action ";")*;

Action :
	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
	(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 		

Effect : 
	Emission | Assignment | HostCode;
		
//Expression :
//	TerminalExpression | ComplexExpression;

// TODO: Signal and Variable references both are evaluated by simple IDs
//TerminalExpression:
//    SignalOrVariableReference | HostCode | Value;

// TODO: add more complex expressions and not only simple operations without recursion
//UnbracedComplexExpression : 
//	((subExpressions+=TerminalExpression))? operator=Operator subExpressions+=Expression ;

//BracedComplexExpression : 
//	"(" UnbracedComplexExpression ")";

//ComplexExpression :
//	UnbracedComplexExpression | BracedComplexExpression;

Emission :
	signal=[Signal] ("(" newValue=PrimaryExpression ")")?;

Assignment :
	variable=[Variable] ":=" expression=PrimaryExpression;

SignalReference:
	reference = [Signal];
	
VariableReference:
	reference = [Variable];

Signal:
	"input" name = ID ";";

Variable:
	"var" name = ID ";";

IntValue: 
	value=INT;
FloatValue:
    value=Float;
BooleanValue:
    value=Boolean;
Value:
	IntValue | FloatValue | BooleanValue;

// make sure the Float rule does not shadow the built-in INT rule
terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
terminal Boolean returns ecore::EBoolean : "true" | "false";

HostCode:
	//"'"code=STRING"'";
	//("(" type=ID ")")? 
	code=STRING; 	
	
Operator :
	operatorKind=OperatorKind;

ValOperation returns Expression:
	operator=ValOperator subExpressions+=SignalReference;

ValueExpression returns Expression:
	IntValue | FloatValue | ValOperation | VariableReference;

CompareOperation returns Expression:
	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	

NotOperation returns Operations:
	operators=NotOperator subExpressions+=BooleanExpression;

NotOrNormalExpression returns Expression:
	NotOperation | BooleanExpression;

AndOperation returns Expression:
	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;

OrOperation returns Expression:
	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;

// TODO: get rid of parentheses
BooleanExpression returns Expression:
	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;

PrimaryExpression returns Expression:
	//ValueExpression | BooleanExpression;
	BooleanExpression;
	
enum OperatorKind :
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";

enum ValOperator returns OperatorKind:
	VAL="?";

enum CompareOperator returns OperatorKind:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
	
enum NotOperator returns OperatorKind:
	NOT="not";

enum OperatorOr returns OperatorKind:
	OR="or";

enum OperatorAnd returns OperatorKind:
	AND="and";