/*
* generated by Xtext
*/
package de.cau.cs.kieler.synccharts.labelparser.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.synccharts.labelparser.services.ActionLabelGrammarAccess;

import com.google.inject.Inject;

public class ActionLabelParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private ActionLabelGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Action_Group(this, this, 0, inst);
			case 1: return new Effect_Alternatives(this, this, 1, inst);
			case 2: return new Emission_Group(this, this, 2, inst);
			case 3: return new Assignment_Group(this, this, 3, inst);
			case 4: return new SignalReference_Group(this, this, 4, inst);
			case 5: return new VariableReference_Group(this, this, 5, inst);
			case 6: return new Signal_NameAssignment(this, this, 6, inst);
			case 7: return new Variable_NameAssignment(this, this, 7, inst);
			case 8: return new IntValue_ValueAssignment(this, this, 8, inst);
			case 9: return new FloatValue_ValueAssignment(this, this, 9, inst);
			case 10: return new BooleanValue_ValueAssignment(this, this, 10, inst);
			case 11: return new Value_Alternatives(this, this, 11, inst);
			case 12: return new ValOperation_Group(this, this, 12, inst);
			case 13: return new ValueExpression_PlusOperationParserRuleCall(this, this, 13, inst);
			case 14: return new ParanthesedValueExpression_Alternatives(this, this, 14, inst);
			case 15: return new PlusOperation_Group(this, this, 15, inst);
			case 16: return new MultOrDivOperation_Alternatives(this, this, 16, inst);
			case 17: return new MultOperation_Group(this, this, 17, inst);
			case 18: return new DivOperation_Group(this, this, 18, inst);
			case 19: return new PreArithmOperation_Group(this, this, 19, inst);
			case 20: return new PreOrNormalValueExpression_Alternatives(this, this, 20, inst);
			case 21: return new CompareOperation_Group(this, this, 21, inst);
			case 22: return new UnaryOperation_Group(this, this, 22, inst);
			case 23: return new UnaryParanthesedOperation_Group(this, this, 23, inst);
			case 24: return new UnaryOrNormalExpression_Alternatives(this, this, 24, inst);
			case 25: return new AndOperation_Group(this, this, 25, inst);
			case 26: return new OrOperation_Group(this, this, 26, inst);
			case 27: return new ParanthesedBooleanExpression_Alternatives(this, this, 27, inst);
			case 28: return new BooleanExpression_OrOperationParserRuleCall(this, this, 28, inst);
			case 29: return new HostCode_Group(this, this, 29, inst);
			case 30: return new Expression_Alternatives(this, this, 30, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Action ****************
 *
 * //import "synccharts" as synchcharts
 * 
 * //==============================================================================
 * // Basic Actions
 * //==============================================================================
 * 
 * 
 * Action returns synccharts::Action:
 *   isImmediate?="#"? delay=INT? trigger=BooleanExpression? ("/" (effects+=Effect
 *   ","?)*)?;
 *
 **/

// isImmediate?="#"? delay=INT? trigger=BooleanExpression? ("/" (effects+=Effect
// ","?)*)?
protected class Action_Group extends GroupToken {
	
	public Action_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Action_Group_3(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Action_TriggerAssignment_2(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Action_DelayAssignment_1(lastRuleCallOrigin, this, 2, inst);
			case 3: return new Action_IsImmediateAssignment_0(lastRuleCallOrigin, this, 3, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 4, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getActionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// isImmediate?="#"?
protected class Action_IsImmediateAssignment_0 extends AssignmentToken  {
	
	public Action_IsImmediateAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getIsImmediateAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("isImmediate",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("isImmediate");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getActionAccess().getIsImmediateNumberSignKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// delay=INT?
protected class Action_DelayAssignment_1 extends AssignmentToken  {
	
	public Action_DelayAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getDelayAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Action_IsImmediateAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 1, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("delay",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("delay");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getActionAccess().getDelayINTTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getActionAccess().getDelayINTTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// trigger=BooleanExpression?
protected class Action_TriggerAssignment_2 extends AssignmentToken  {
	
	public Action_TriggerAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTriggerAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("trigger",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getActionAccess().getTriggerBooleanExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_DelayAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Action_IsImmediateAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 2, consumed);
		}	
	}	
}

// ("/" (effects+=Effect ","?)*)?
protected class Action_Group_3 extends GroupToken {
	
	public Action_Group_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Action_Group_3_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Action_SolidusKeyword_3_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// "/"
protected class Action_SolidusKeyword_3_0 extends KeywordToken  {
	
	public Action_SolidusKeyword_3_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getSolidusKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Action_TriggerAssignment_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Action_DelayAssignment_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Action_IsImmediateAssignment_0(lastRuleCallOrigin, this, 2, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 3, inst);
		}	
	}

}

// (effects+=Effect ","?)*
protected class Action_Group_3_1 extends GroupToken {
	
	public Action_Group_3_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Action_EffectsAssignment_3_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// effects+=Effect
protected class Action_EffectsAssignment_3_1_0 extends AssignmentToken  {
	
	public Action_EffectsAssignment_3_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getEffectsAssignment_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("effects",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getActionAccess().getEffectsEffectParserRuleCall_3_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_Group_3_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Action_SolidusKeyword_3_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule Action ****************/


/************ begin Rule Effect ****************
 *
 * Effect returns synccharts::Effect:
 *   Emission|Assignment|HostCode;
 *
 **/

// Emission|Assignment|HostCode
protected class Effect_Alternatives extends AlternativesToken {

	public Effect_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEffectAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Effect_EmissionParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Effect_AssignmentParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Effect_HostCodeParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssignmentRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEmissionRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Emission
protected class Effect_EmissionParserRuleCall_0 extends RuleCallToken {
	
	public Effect_EmissionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getEmissionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEmissionRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Emission_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// Assignment
protected class Effect_AssignmentParserRuleCall_1 extends RuleCallToken {
	
	public Effect_AssignmentParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getAssignmentParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssignmentRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Assignment_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// HostCode
protected class Effect_HostCodeParserRuleCall_2 extends RuleCallToken {
	
	public Effect_HostCodeParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getHostCodeParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(HostCode_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Effect ****************/


/************ begin Rule Emission ****************
 *
 * Emission returns synccharts::Emission:
 *   signal=[synccharts::Signal] ("(" newValue=ValueExpression ")"|"("
 *   newValue=BooleanExpression ")")?;
 *
 **/

// signal=[synccharts::Signal] ("(" newValue=ValueExpression ")"|"("
// newValue=BooleanExpression ")")?
protected class Emission_Group extends GroupToken {
	
	public Emission_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_Alternatives_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Emission_SignalAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEmissionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// signal=[synccharts::Signal]
protected class Emission_SignalAssignment_0 extends AssignmentToken  {
	
	public Emission_SignalAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getSignalAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("signal",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" newValue=ValueExpression ")"|"(" newValue=BooleanExpression ")")?
protected class Emission_Alternatives_1 extends AlternativesToken {

	public Emission_Alternatives_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEmissionAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_Group_1_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Emission_Group_1_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// "(" newValue=ValueExpression ")"
protected class Emission_Group_1_0 extends GroupToken {
	
	public Emission_Group_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_RightParenthesisKeyword_1_0_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class Emission_LeftParenthesisKeyword_1_0_0 extends KeywordToken  {
	
	public Emission_LeftParenthesisKeyword_1_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getLeftParenthesisKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_SignalAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// newValue=ValueExpression
protected class Emission_NewValueAssignment_1_0_1 extends AssignmentToken  {
	
	public Emission_NewValueAssignment_1_0_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getNewValueAssignment_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValueExpression_PlusOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("newValue",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("newValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEmissionAccess().getNewValueValueExpressionParserRuleCall_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Emission_LeftParenthesisKeyword_1_0_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Emission_RightParenthesisKeyword_1_0_2 extends KeywordToken  {
	
	public Emission_RightParenthesisKeyword_1_0_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getRightParenthesisKeyword_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_NewValueAssignment_1_0_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// "(" newValue=BooleanExpression ")"
protected class Emission_Group_1_1 extends GroupToken {
	
	public Emission_Group_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_RightParenthesisKeyword_1_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class Emission_LeftParenthesisKeyword_1_1_0 extends KeywordToken  {
	
	public Emission_LeftParenthesisKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getLeftParenthesisKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_SignalAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// newValue=BooleanExpression
protected class Emission_NewValueAssignment_1_1_1 extends AssignmentToken  {
	
	public Emission_NewValueAssignment_1_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getNewValueAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("newValue",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("newValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getEmissionAccess().getNewValueBooleanExpressionParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Emission_LeftParenthesisKeyword_1_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Emission_RightParenthesisKeyword_1_1_2 extends KeywordToken  {
	
	public Emission_RightParenthesisKeyword_1_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getRightParenthesisKeyword_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Emission_NewValueAssignment_1_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}




/************ end Rule Emission ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment returns synccharts::Assignment:
 *   variable=[synccharts::Variable] ":=" (expression=ValueExpression|
 *   expression=BooleanExpression);
 *
 **/

// variable=[synccharts::Variable] ":=" (expression=ValueExpression|
// expression=BooleanExpression)
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assignment_Alternatives_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAssignmentRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// variable=[synccharts::Variable]
protected class Assignment_VariableAssignment_0 extends AssignmentToken  {
	
	public Assignment_VariableAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getVariableAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("variable",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ":="
protected class Assignment_ColonEqualsSignKeyword_1 extends KeywordToken  {
	
	public Assignment_ColonEqualsSignKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getColonEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assignment_VariableAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// expression=ValueExpression|expression=BooleanExpression
protected class Assignment_Alternatives_2 extends AlternativesToken {

	public Assignment_Alternatives_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Assignment_ExpressionAssignment_2_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Assignment_ExpressionAssignment_2_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// expression=ValueExpression
protected class Assignment_ExpressionAssignment_2_0 extends AssignmentToken  {
	
	public Assignment_ExpressionAssignment_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getExpressionAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValueExpression_PlusOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAssignmentAccess().getExpressionValueExpressionParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_ColonEqualsSignKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// expression=BooleanExpression
protected class Assignment_ExpressionAssignment_2_1 extends AssignmentToken  {
	
	public Assignment_ExpressionAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getExpressionAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expression",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAssignmentAccess().getExpressionBooleanExpressionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_ColonEqualsSignKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Assignment ****************/


/************ begin Rule SignalReference ****************
 *
 * SignalReference returns synccharts::SignalReference:
 *   signal=[synccharts::Signal] ("(" (subExpressions+=Expression ","?)* ")")?;
 *
 **/

// signal=[synccharts::Signal] ("(" (subExpressions+=Expression ","?)* ")")?
protected class SignalReference_Group extends GroupToken {
	
	public SignalReference_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new SignalReference_SignalAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// signal=[synccharts::Signal]
protected class SignalReference_SignalAssignment_0 extends AssignmentToken  {
	
	public SignalReference_SignalAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getSignalAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("signal",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceAccess().getSignalSignalCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getSignalReferenceAccess().getSignalSignalCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" (subExpressions+=Expression ","?)* ")")?
protected class SignalReference_Group_1 extends GroupToken {
	
	public SignalReference_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_RightParenthesisKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class SignalReference_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public SignalReference_LeftParenthesisKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_SignalAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// (subExpressions+=Expression ","?)*
protected class SignalReference_Group_1_1 extends GroupToken {
	
	public SignalReference_Group_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_SubExpressionsAssignment_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// subExpressions+=Expression
protected class SignalReference_SubExpressionsAssignment_1_1_0 extends AssignmentToken  {
	
	public SignalReference_SubExpressionsAssignment_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getSubExpressionsAssignment_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSignalReferenceAccess().getSubExpressionsExpressionParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SignalReference_Group_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new SignalReference_LeftParenthesisKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class SignalReference_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public SignalReference_RightParenthesisKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_Group_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule SignalReference ****************/


/************ begin Rule VariableReference ****************
 *
 * VariableReference returns synccharts::VariableReference:
 *   variable=[synccharts::Variable] ("(" (subExpressions+=Expression ","?)* ")")?
 * ;
 *
 **/

// variable=[synccharts::Variable] ("(" (subExpressions+=Expression ","?)* ")")?
protected class VariableReference_Group extends GroupToken {
	
	public VariableReference_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableReference_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new VariableReference_VariableAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// variable=[synccharts::Variable]
protected class VariableReference_VariableAssignment_0 extends AssignmentToken  {
	
	public VariableReference_VariableAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getVariableAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("variable",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableReferenceAccess().getVariableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getVariableReferenceAccess().getVariableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" (subExpressions+=Expression ","?)* ")")?
protected class VariableReference_Group_1 extends GroupToken {
	
	public VariableReference_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableReference_RightParenthesisKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class VariableReference_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public VariableReference_LeftParenthesisKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableReference_VariableAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// (subExpressions+=Expression ","?)*
protected class VariableReference_Group_1_1 extends GroupToken {
	
	public VariableReference_Group_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableReference_SubExpressionsAssignment_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// subExpressions+=Expression
protected class VariableReference_SubExpressionsAssignment_1_1_0 extends AssignmentToken  {
	
	public VariableReference_SubExpressionsAssignment_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getSubExpressionsAssignment_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVariableReferenceAccess().getSubExpressionsExpressionParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VariableReference_Group_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new VariableReference_LeftParenthesisKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class VariableReference_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public VariableReference_RightParenthesisKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableReference_Group_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule VariableReference ****************/


/************ begin Rule Signal ****************
 *
 * Signal returns synccharts::Signal:
 *   name=ID;
 *
 **/

// name=ID
protected class Signal_NameAssignment extends AssignmentToken  {
	
	public Signal_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSignalRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Signal ****************/


/************ begin Rule Variable ****************
 *
 * Variable returns synccharts::Variable:
 *   name=ID;
 *
 **/

// name=ID
protected class Variable_NameAssignment extends AssignmentToken  {
	
	public Variable_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Variable ****************/


/************ begin Rule IntValue ****************
 *
 * IntValue returns synccharts::IntValue:
 *   value=INT;
 *
 **/

// value=INT
protected class IntValue_ValueAssignment extends AssignmentToken  {
	
	public IntValue_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntValueAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntValue ****************/


/************ begin Rule FloatValue ****************
 *
 * FloatValue returns synccharts::FloatValue:
 *   value=Float;
 *
 **/

// value=Float
protected class FloatValue_ValueAssignment extends AssignmentToken  {
	
	public FloatValue_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatValueAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getFloatValueAccess().getValueFloatTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getFloatValueAccess().getValueFloatTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule FloatValue ****************/


/************ begin Rule BooleanValue ****************
 *
 * BooleanValue returns synccharts::BooleanValue:
 *   value=Boolean;
 *
 **/

// value=Boolean
protected class BooleanValue_ValueAssignment extends AssignmentToken  {
	
	public BooleanValue_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanValueAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getBooleanValueAccess().getValueBooleanTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getBooleanValueAccess().getValueBooleanTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanValue ****************/


/************ begin Rule Value ****************
 *
 * Value returns synccharts::Value:
 *   IntValue|FloatValue|BooleanValue;
 *
 **/

// IntValue|FloatValue|BooleanValue
protected class Value_Alternatives extends AlternativesToken {

	public Value_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Value_IntValueParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Value_FloatValueParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Value_BooleanValueParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// IntValue
protected class Value_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public Value_IntValueParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getIntValueParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier())
			return null;
		if(checkForRecursion(IntValue_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class Value_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public Value_FloatValueParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getFloatValueParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier())
			return null;
		if(checkForRecursion(FloatValue_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// BooleanValue
protected class Value_BooleanValueParserRuleCall_2 extends RuleCallToken {
	
	public Value_BooleanValueParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getBooleanValueParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BooleanValue_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Value ****************/


/************ begin Rule ValOperation ****************
 *
 * //==============================================================================
 * // Arithmetic Expressions
 * //==============================================================================
 * 
 * // Example: ?A	
 * 
 * 
 * ValOperation returns synccharts::OperatorExpression:
 *   operator=ValOperator subExpressions+=SignalReference;
 *
 **/

// operator=ValOperator subExpressions+=SignalReference
protected class ValOperation_Group extends GroupToken {
	
	public ValOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getValOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValOperation_SubExpressionsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getValOperationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// operator=ValOperator
protected class ValOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public ValOperation_OperatorAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getOperatorAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getValOperationAccess().getOperatorValOperatorEnumRuleCall_0_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getValOperationAccess().getOperatorValOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=SignalReference
protected class ValOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public ValOperation_SubExpressionsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getSubExpressionsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getValOperationAccess().getSubExpressionsSignalReferenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValOperation_OperatorAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ValOperation ****************/


/************ begin Rule ValueExpression ****************
 *
 * // everything that evaluates to a primitive number value
 * 
 * 
 * ValueExpression returns synccharts::Expression:
 *   PlusOperation;
 *
 **/

// PlusOperation
protected class ValueExpression_PlusOperationParserRuleCall extends RuleCallToken {
	
	public ValueExpression_PlusOperationParserRuleCall(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getPlusOperationParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PlusOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(PlusOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule ValueExpression ****************/


/************ begin Rule ParanthesedValueExpression ****************
 *
 * // Example: 42, 42.2, ?A, var1, (1+2*3)
 * 
 * 
 * ParanthesedValueExpression returns synccharts::Expression:
 *   IntValue|FloatValue|ValOperation|VariableReference|HostCode|"(" PlusOperation
 *   ")"|"(" DivOperation ")";
 *
 **/

// IntValue|FloatValue|ValOperation|VariableReference|HostCode|"(" PlusOperation
// ")"|"(" DivOperation ")"
protected class ParanthesedValueExpression_Alternatives extends AlternativesToken {

	public ParanthesedValueExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_IntValueParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ParanthesedValueExpression_FloatValueParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new ParanthesedValueExpression_ValOperationParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new ParanthesedValueExpression_VariableReferenceParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			case 4: return new ParanthesedValueExpression_HostCodeParserRuleCall_4(lastRuleCallOrigin, this, 4, inst);
			case 5: return new ParanthesedValueExpression_Group_5(lastRuleCallOrigin, this, 5, inst);
			case 6: return new ParanthesedValueExpression_Group_6(lastRuleCallOrigin, this, 6, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// IntValue
protected class ParanthesedValueExpression_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public ParanthesedValueExpression_IntValueParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getIntValueParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier())
			return null;
		if(checkForRecursion(IntValue_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class ParanthesedValueExpression_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public ParanthesedValueExpression_FloatValueParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getFloatValueParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier())
			return null;
		if(checkForRecursion(FloatValue_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ValOperation
protected class ParanthesedValueExpression_ValOperationParserRuleCall_2 extends RuleCallToken {
	
	public ParanthesedValueExpression_ValOperationParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getValOperationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getValOperationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ValOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// VariableReference
protected class ParanthesedValueExpression_VariableReferenceParserRuleCall_3 extends RuleCallToken {
	
	public ParanthesedValueExpression_VariableReferenceParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getVariableReferenceParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new VariableReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(VariableReference_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// HostCode
protected class ParanthesedValueExpression_HostCodeParserRuleCall_4 extends RuleCallToken {
	
	public ParanthesedValueExpression_HostCodeParserRuleCall_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getHostCodeParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(HostCode_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// "(" PlusOperation ")"
protected class ParanthesedValueExpression_Group_5 extends GroupToken {
	
	public ParanthesedValueExpression_Group_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_RightParenthesisKeyword_5_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class ParanthesedValueExpression_LeftParenthesisKeyword_5_0 extends KeywordToken  {
	
	public ParanthesedValueExpression_LeftParenthesisKeyword_5_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getLeftParenthesisKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// PlusOperation
protected class ParanthesedValueExpression_PlusOperationParserRuleCall_5_1 extends RuleCallToken {
	
	public ParanthesedValueExpression_PlusOperationParserRuleCall_5_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getPlusOperationParserRuleCall_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PlusOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(PlusOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_LeftParenthesisKeyword_5_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParanthesedValueExpression_RightParenthesisKeyword_5_2 extends KeywordToken  {
	
	public ParanthesedValueExpression_RightParenthesisKeyword_5_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getRightParenthesisKeyword_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_PlusOperationParserRuleCall_5_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// "(" DivOperation ")"
protected class ParanthesedValueExpression_Group_6 extends GroupToken {
	
	public ParanthesedValueExpression_Group_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getGroup_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_RightParenthesisKeyword_6_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class ParanthesedValueExpression_LeftParenthesisKeyword_6_0 extends KeywordToken  {
	
	public ParanthesedValueExpression_LeftParenthesisKeyword_6_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getLeftParenthesisKeyword_6_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// DivOperation
protected class ParanthesedValueExpression_DivOperationParserRuleCall_6_1 extends RuleCallToken {
	
	public ParanthesedValueExpression_DivOperationParserRuleCall_6_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getDivOperationParserRuleCall_6_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DivOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(DivOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_LeftParenthesisKeyword_6_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParanthesedValueExpression_RightParenthesisKeyword_6_2 extends KeywordToken  {
	
	public ParanthesedValueExpression_RightParenthesisKeyword_6_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedValueExpressionAccess().getRightParenthesisKeyword_6_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_DivOperationParserRuleCall_6_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule ParanthesedValueExpression ****************/


/************ begin Rule PlusOperation ****************
 *
 * // Example: 1 + 2, varA - ?B
 * 
 * 
 * PlusOperation returns synccharts::Expression:
 *   MultOrDivOperation ({synccharts::OperatorExpression.subExpressions+=current}
 *   operator=PlusOperator subExpressions+=MultOrDivOperation)*;
 *
 **/

// MultOrDivOperation ({synccharts::OperatorExpression.subExpressions+=current}
// operator=PlusOperator subExpressions+=MultOrDivOperation)*
protected class PlusOperation_Group extends GroupToken {
	
	public PlusOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPlusOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PlusOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new PlusOperation_MultOrDivOperationParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// MultOrDivOperation
protected class PlusOperation_MultOrDivOperationParserRuleCall_0 extends RuleCallToken {
	
	public PlusOperation_MultOrDivOperationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPlusOperationAccess().getMultOrDivOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOrDivOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(MultOrDivOperation_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({synccharts::OperatorExpression.subExpressions+=current} operator=PlusOperator
// subExpressions+=MultOrDivOperation)*
protected class PlusOperation_Group_1 extends GroupToken {
	
	public PlusOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPlusOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PlusOperation_SubExpressionsAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {synccharts::OperatorExpression.subExpressions+=current}
protected class PlusOperation_OperatorExpressionSubExpressionsAction_1_0 extends ActionToken  {

	public PlusOperation_OperatorExpressionSubExpressionsAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PlusOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new PlusOperation_MultOrDivOperationParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("subExpressions")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=PlusOperator
protected class PlusOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public PlusOperation_OperatorAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPlusOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PlusOperation_OperatorExpressionSubExpressionsAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getPlusOperationAccess().getOperatorPlusOperatorEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getPlusOperationAccess().getOperatorPlusOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=MultOrDivOperation
protected class PlusOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public PlusOperation_SubExpressionsAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPlusOperationAccess().getSubExpressionsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOrDivOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultOrDivOperationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getPlusOperationAccess().getSubExpressionsMultOrDivOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PlusOperation_OperatorAssignment_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule PlusOperation ****************/


/************ begin Rule MultOrDivOperation ****************
 *
 * MultOrDivOperation returns synccharts::Expression:
 *   MultOperation|"(" DivOperation ")";
 *
 **/

// MultOperation|"(" DivOperation ")"
protected class MultOrDivOperation_Alternatives extends AlternativesToken {

	public MultOrDivOperation_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMultOrDivOperationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOrDivOperation_MultOperationParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new MultOrDivOperation_Group_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// MultOperation
protected class MultOrDivOperation_MultOperationParserRuleCall_0 extends RuleCallToken {
	
	public MultOrDivOperation_MultOperationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultOrDivOperationAccess().getMultOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(MultOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// "(" DivOperation ")"
protected class MultOrDivOperation_Group_1 extends GroupToken {
	
	public MultOrDivOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultOrDivOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOrDivOperation_RightParenthesisKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class MultOrDivOperation_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public MultOrDivOperation_LeftParenthesisKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMultOrDivOperationAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// DivOperation
protected class MultOrDivOperation_DivOperationParserRuleCall_1_1 extends RuleCallToken {
	
	public MultOrDivOperation_DivOperationParserRuleCall_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultOrDivOperationAccess().getDivOperationParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DivOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(DivOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOrDivOperation_LeftParenthesisKeyword_1_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class MultOrDivOperation_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public MultOrDivOperation_RightParenthesisKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMultOrDivOperationAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOrDivOperation_DivOperationParserRuleCall_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule MultOrDivOperation ****************/


/************ begin Rule MultOperation ****************
 *
 * // Example: 2 * 4, varA mod ?B
 * 
 * 
 * MultOperation returns synccharts::Expression:
 *   PreOrNormalValueExpression ({synccharts::OperatorExpression.subExpressions+=
 *   current} operator=MultOperator subExpressions+=PreOrNormalValueExpression)*;
 *
 **/

// PreOrNormalValueExpression ({synccharts::OperatorExpression.subExpressions+=
// current} operator=MultOperator subExpressions+=PreOrNormalValueExpression)*
protected class MultOperation_Group extends GroupToken {
	
	public MultOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new MultOperation_PreOrNormalValueExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// PreOrNormalValueExpression
protected class MultOperation_PreOrNormalValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public MultOperation_PreOrNormalValueExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultOperationAccess().getPreOrNormalValueExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreOrNormalValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(PreOrNormalValueExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({synccharts::OperatorExpression.subExpressions+=current} operator=MultOperator
// subExpressions+=PreOrNormalValueExpression)*
protected class MultOperation_Group_1 extends GroupToken {
	
	public MultOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOperation_SubExpressionsAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMultOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {synccharts::OperatorExpression.subExpressions+=current}
protected class MultOperation_OperatorExpressionSubExpressionsAction_1_0 extends ActionToken  {

	public MultOperation_OperatorExpressionSubExpressionsAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMultOperationAccess().getOperatorExpressionSubExpressionsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new MultOperation_PreOrNormalValueExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("subExpressions")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=MultOperator
protected class MultOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public MultOperation_OperatorAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultOperation_OperatorExpressionSubExpressionsAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getMultOperationAccess().getOperatorMultOperatorEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getMultOperationAccess().getOperatorMultOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=PreOrNormalValueExpression
protected class MultOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public MultOperation_SubExpressionsAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultOperationAccess().getSubExpressionsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreOrNormalValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPreOrNormalValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMultOperationAccess().getSubExpressionsPreOrNormalValueExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultOperation_OperatorAssignment_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule MultOperation ****************/


/************ begin Rule DivOperation ****************
 *
 * // Example: (2 / 4)
 * // note: division has to have always parantheses because the '/' sign is also used for trigger/effect delimiter
 * 
 * 
 * DivOperation returns synccharts::Expression:
 *   PreOrNormalValueExpression ({synccharts::OperatorExpression.subExpressions+=
 *   current} operator=DivOperator subExpressions+=PreOrNormalValueExpression)*;
 *
 **/

// PreOrNormalValueExpression ({synccharts::OperatorExpression.subExpressions+=
// current} operator=DivOperator subExpressions+=PreOrNormalValueExpression)*
protected class DivOperation_Group extends GroupToken {
	
	public DivOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDivOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DivOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DivOperation_PreOrNormalValueExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// PreOrNormalValueExpression
protected class DivOperation_PreOrNormalValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public DivOperation_PreOrNormalValueExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDivOperationAccess().getPreOrNormalValueExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreOrNormalValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(PreOrNormalValueExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({synccharts::OperatorExpression.subExpressions+=current} operator=DivOperator
// subExpressions+=PreOrNormalValueExpression)*
protected class DivOperation_Group_1 extends GroupToken {
	
	public DivOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDivOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DivOperation_SubExpressionsAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDivOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {synccharts::OperatorExpression.subExpressions+=current}
protected class DivOperation_OperatorExpressionSubExpressionsAction_1_0 extends ActionToken  {

	public DivOperation_OperatorExpressionSubExpressionsAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getDivOperationAccess().getOperatorExpressionSubExpressionsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DivOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DivOperation_PreOrNormalValueExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("subExpressions")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=DivOperator
protected class DivOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public DivOperation_OperatorAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDivOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DivOperation_OperatorExpressionSubExpressionsAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getDivOperationAccess().getOperatorDivOperatorEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getDivOperationAccess().getOperatorDivOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=PreOrNormalValueExpression
protected class DivOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public DivOperation_SubExpressionsAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDivOperationAccess().getSubExpressionsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreOrNormalValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPreOrNormalValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDivOperationAccess().getSubExpressionsPreOrNormalValueExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DivOperation_OperatorAssignment_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule DivOperation ****************/


/************ begin Rule PreArithmOperation ****************
 *
 * // Example: pre (? A)
 * 
 * 
 * PreArithmOperation returns synccharts::OperatorExpression:
 *   operator=UnaryParanthesedOperator "(" subExpressions+=ValOperation ")";
 *
 **/

// operator=UnaryParanthesedOperator "(" subExpressions+=ValOperation ")"
protected class PreArithmOperation_Group extends GroupToken {
	
	public PreArithmOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPreArithmOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreArithmOperation_RightParenthesisKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPreArithmOperationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// operator=UnaryParanthesedOperator
protected class PreArithmOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public PreArithmOperation_OperatorAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPreArithmOperationAccess().getOperatorAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getPreArithmOperationAccess().getOperatorUnaryParanthesedOperatorEnumRuleCall_0_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getPreArithmOperationAccess().getOperatorUnaryParanthesedOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class PreArithmOperation_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public PreArithmOperation_LeftParenthesisKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPreArithmOperationAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreArithmOperation_OperatorAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// subExpressions+=ValOperation
protected class PreArithmOperation_SubExpressionsAssignment_2 extends AssignmentToken  {
	
	public PreArithmOperation_SubExpressionsAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPreArithmOperationAccess().getSubExpressionsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getPreArithmOperationAccess().getSubExpressionsValOperationParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PreArithmOperation_LeftParenthesisKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class PreArithmOperation_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public PreArithmOperation_RightParenthesisKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPreArithmOperationAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreArithmOperation_SubExpressionsAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule PreArithmOperation ****************/


/************ begin Rule PreOrNormalValueExpression ****************
 *
 * PreOrNormalValueExpression returns synccharts::Expression:
 *   PreArithmOperation|ParanthesedValueExpression;
 *
 **/

// PreArithmOperation|ParanthesedValueExpression
protected class PreOrNormalValueExpression_Alternatives extends AlternativesToken {

	public PreOrNormalValueExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPreOrNormalValueExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreOrNormalValueExpression_PreArithmOperationParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new PreOrNormalValueExpression_ParanthesedValueExpressionParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// PreArithmOperation
protected class PreOrNormalValueExpression_PreArithmOperationParserRuleCall_0 extends RuleCallToken {
	
	public PreOrNormalValueExpression_PreArithmOperationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPreOrNormalValueExpressionAccess().getPreArithmOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PreArithmOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPreArithmOperationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(PreArithmOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ParanthesedValueExpression
protected class PreOrNormalValueExpression_ParanthesedValueExpressionParserRuleCall_1 extends RuleCallToken {
	
	public PreOrNormalValueExpression_ParanthesedValueExpressionParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPreOrNormalValueExpressionAccess().getParanthesedValueExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(ParanthesedValueExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PreOrNormalValueExpression ****************/


/************ begin Rule CompareOperation ****************
 *
 * //==============================================================================
 * // Boolean Expressions
 * //==============================================================================
 * 
 * // Example: 42 <= ?A
 * 
 * 
 * CompareOperation returns synccharts::Expression:
 *   ValueExpression ({synccharts::OperatorExpression.subExpressions+=current}
 *   operator=CompareOperator subExpressions+=ValueExpression);
 *
 **/

// ValueExpression ({synccharts::OperatorExpression.subExpressions+=current}
// operator=CompareOperator subExpressions+=ValueExpression)
protected class CompareOperation_Group extends GroupToken {
	
	public CompareOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CompareOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCompareOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ValueExpression
protected class CompareOperation_ValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public CompareOperation_ValueExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getValueExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValueExpression_PlusOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(ValueExpression_PlusOperationParserRuleCall.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// {synccharts::OperatorExpression.subExpressions+=current}
// operator=CompareOperator subExpressions+=ValueExpression
protected class CompareOperation_Group_1 extends GroupToken {
	
	public CompareOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CompareOperation_SubExpressionsAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// {synccharts::OperatorExpression.subExpressions+=current}
protected class CompareOperation_OperatorExpressionSubExpressionsAction_1_0 extends ActionToken  {

	public CompareOperation_OperatorExpressionSubExpressionsAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperatorExpressionSubExpressionsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CompareOperation_ValueExpressionParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("subExpressions")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=CompareOperator
protected class CompareOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public CompareOperation_OperatorAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CompareOperation_OperatorExpressionSubExpressionsAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getCompareOperationAccess().getOperatorCompareOperatorEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getCompareOperationAccess().getOperatorCompareOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=ValueExpression
protected class CompareOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public CompareOperation_SubExpressionsAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getSubExpressionsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValueExpression_PlusOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCompareOperationAccess().getSubExpressionsValueExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompareOperation_OperatorAssignment_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CompareOperation ****************/


/************ begin Rule UnaryOperation ****************
 *
 * // Example: not A, not false, not (A or B)
 * // at the latter we need the parans to indicate the right binding
 * 
 * 
 * UnaryOperation returns synccharts::OperatorExpression:
 *   operator=UnaryOperator subExpressions+=( ParanthesedBooleanExpression |
 *   UnaryParanthesedOperation );
 *
 **/

// operator=UnaryOperator subExpressions+=( ParanthesedBooleanExpression |
// UnaryParanthesedOperation )
protected class UnaryOperation_Group extends GroupToken {
	
	public UnaryOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryOperation_SubExpressionsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// operator=UnaryOperator
protected class UnaryOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public UnaryOperation_OperatorAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getOperatorAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getUnaryOperationAccess().getOperatorUnaryOperatorEnumRuleCall_0_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getUnaryOperationAccess().getOperatorUnaryOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=( ParanthesedBooleanExpression | UnaryParanthesedOperation )
protected class UnaryOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public UnaryOperation_SubExpressionsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getSubExpressionsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_Alternatives(this, this, 0, inst);
			case 1: return new UnaryParanthesedOperation_Group(this, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParanthesedBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getUnaryOperationAccess().getSubExpressionsParanthesedBooleanExpressionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryParanthesedOperationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getUnaryOperationAccess().getSubExpressionsUnaryParanthesedOperationParserRuleCall_1_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryOperation_OperatorAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule UnaryOperation ****************/


/************ begin Rule UnaryParanthesedOperation ****************
 *
 * UnaryParanthesedOperation returns synccharts::OperatorExpression:
 *   operator=UnaryParanthesedOperator "(" subExpressions+=BooleanExpression ")";
 *
 **/

// operator=UnaryParanthesedOperator "(" subExpressions+=BooleanExpression ")"
protected class UnaryParanthesedOperation_Group extends GroupToken {
	
	public UnaryParanthesedOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryParanthesedOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryParanthesedOperation_RightParenthesisKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getUnaryParanthesedOperationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// operator=UnaryParanthesedOperator
protected class UnaryParanthesedOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public UnaryParanthesedOperation_OperatorAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryParanthesedOperationAccess().getOperatorAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getUnaryParanthesedOperationAccess().getOperatorUnaryParanthesedOperatorEnumRuleCall_0_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getUnaryParanthesedOperationAccess().getOperatorUnaryParanthesedOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class UnaryParanthesedOperation_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public UnaryParanthesedOperation_LeftParenthesisKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnaryParanthesedOperationAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryParanthesedOperation_OperatorAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// subExpressions+=BooleanExpression
protected class UnaryParanthesedOperation_SubExpressionsAssignment_2 extends AssignmentToken  {
	
	public UnaryParanthesedOperation_SubExpressionsAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryParanthesedOperationAccess().getSubExpressionsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getUnaryParanthesedOperationAccess().getSubExpressionsBooleanExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryParanthesedOperation_LeftParenthesisKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class UnaryParanthesedOperation_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public UnaryParanthesedOperation_RightParenthesisKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnaryParanthesedOperationAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryParanthesedOperation_SubExpressionsAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule UnaryParanthesedOperation ****************/


/************ begin Rule UnaryOrNormalExpression ****************
 *
 * // Example: either negated or normal expression (with parantheses) 
 * 
 * 
 * UnaryOrNormalExpression returns synccharts::Expression:
 *   UnaryOperation|UnaryParanthesedOperation|ParanthesedBooleanExpression;
 *
 **/

// UnaryOperation|UnaryParanthesedOperation|ParanthesedBooleanExpression
protected class UnaryOrNormalExpression_Alternatives extends AlternativesToken {

	public UnaryOrNormalExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnaryOrNormalExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryOrNormalExpression_UnaryOperationParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new UnaryOrNormalExpression_UnaryParanthesedOperationParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new UnaryOrNormalExpression_ParanthesedBooleanExpressionParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// UnaryOperation
protected class UnaryOrNormalExpression_UnaryOperationParserRuleCall_0 extends RuleCallToken {
	
	public UnaryOrNormalExpression_UnaryOperationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOrNormalExpressionAccess().getUnaryOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(UnaryOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// UnaryParanthesedOperation
protected class UnaryOrNormalExpression_UnaryParanthesedOperationParserRuleCall_1 extends RuleCallToken {
	
	public UnaryOrNormalExpression_UnaryParanthesedOperationParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOrNormalExpressionAccess().getUnaryParanthesedOperationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryParanthesedOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getUnaryParanthesedOperationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(UnaryParanthesedOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ParanthesedBooleanExpression
protected class UnaryOrNormalExpression_ParanthesedBooleanExpressionParserRuleCall_2 extends RuleCallToken {
	
	public UnaryOrNormalExpression_ParanthesedBooleanExpressionParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOrNormalExpressionAccess().getParanthesedBooleanExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(ParanthesedBooleanExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule UnaryOrNormalExpression ****************/


/************ begin Rule AndOperation ****************
 *
 * // Example: A and B, not C and 42 <= ?D
 * 
 * 
 * AndOperation returns synccharts::Expression:
 *   UnaryOrNormalExpression ({synccharts::OperatorExpression.subExpressions+=
 *   current} operator=OperatorAnd subExpressions+=UnaryOrNormalExpression)*;
 *
 **/

// UnaryOrNormalExpression ({synccharts::OperatorExpression.subExpressions+=current
// } operator=OperatorAnd subExpressions+=UnaryOrNormalExpression)*
protected class AndOperation_Group extends GroupToken {
	
	public AndOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AndOperation_UnaryOrNormalExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// UnaryOrNormalExpression
protected class AndOperation_UnaryOrNormalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndOperation_UnaryOrNormalExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getUnaryOrNormalExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(UnaryOrNormalExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({synccharts::OperatorExpression.subExpressions+=current} operator=OperatorAnd
// subExpressions+=UnaryOrNormalExpression)*
protected class AndOperation_Group_1 extends GroupToken {
	
	public AndOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndOperation_SubExpressionsAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {synccharts::OperatorExpression.subExpressions+=current}
protected class AndOperation_OperatorExpressionSubExpressionsAction_1_0 extends ActionToken  {

	public AndOperation_OperatorExpressionSubExpressionsAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperatorExpressionSubExpressionsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AndOperation_UnaryOrNormalExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("subExpressions")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=OperatorAnd
protected class AndOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndOperation_OperatorAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndOperation_OperatorExpressionSubExpressionsAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getAndOperationAccess().getOperatorOperatorAndEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getAndOperationAccess().getOperatorOperatorAndEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=UnaryOrNormalExpression
protected class AndOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public AndOperation_SubExpressionsAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getSubExpressionsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new UnaryOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryOrNormalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAndOperationAccess().getSubExpressionsUnaryOrNormalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndOperation_OperatorAssignment_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndOperation ****************/


/************ begin Rule OrOperation ****************
 *
 * // Example: A or B, C and B or D and not E 
 * 
 * 
 * OrOperation returns synccharts::Expression:
 *   AndOperation ({synccharts::OperatorExpression.subExpressions+=current}
 *   operator=OperatorOr subExpressions+=AndOperation)*;
 *
 **/

// AndOperation ({synccharts::OperatorExpression.subExpressions+=current}
// operator=OperatorOr subExpressions+=AndOperation)*
protected class OrOperation_Group extends GroupToken {
	
	public OrOperation_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// AndOperation
protected class OrOperation_AndOperationParserRuleCall_0 extends RuleCallToken {
	
	public OrOperation_AndOperationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getAndOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(AndOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({synccharts::OperatorExpression.subExpressions+=current} operator=OperatorOr
// subExpressions+=AndOperation)*
protected class OrOperation_Group_1 extends GroupToken {
	
	public OrOperation_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrOperation_SubExpressionsAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getOrOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {synccharts::OperatorExpression.subExpressions+=current}
protected class OrOperation_OperatorExpressionSubExpressionsAction_1_0 extends ActionToken  {

	public OrOperation_OperatorExpressionSubExpressionsAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperatorExpressionSubExpressionsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("subExpressions")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=OperatorOr
protected class OrOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrOperation_OperatorAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrOperation_OperatorExpressionSubExpressionsAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getOrOperationAccess().getOperatorOperatorOrEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getOrOperationAccess().getOperatorOperatorOrEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=AndOperation
protected class OrOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public OrOperation_SubExpressionsAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getSubExpressionsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("subExpressions",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getOrOperationAccess().getSubExpressionsAndOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrOperation_OperatorAssignment_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrOperation ****************/


/************ begin Rule ParanthesedBooleanExpression ****************
 *
 * // Example: true, A, 42>var1, (A or B), (not D and C or ?E = 42)
 * // note that the order of CompareOperation and SignalReference is important. This might be an Xtext bug...
 * 
 * 
 * ParanthesedBooleanExpression returns synccharts::Expression:
 *   BooleanValue|CompareOperation|SignalReference|ValOperation|HostCode|"("
 *   OrOperation ")";
 *
 **/

// BooleanValue|CompareOperation|SignalReference|ValOperation|HostCode|"("
// OrOperation ")"
protected class ParanthesedBooleanExpression_Alternatives extends AlternativesToken {

	public ParanthesedBooleanExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_BooleanValueParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ParanthesedBooleanExpression_CompareOperationParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new ParanthesedBooleanExpression_SignalReferenceParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new ParanthesedBooleanExpression_ValOperationParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			case 4: return new ParanthesedBooleanExpression_HostCodeParserRuleCall_4(lastRuleCallOrigin, this, 4, inst);
			case 5: return new ParanthesedBooleanExpression_Group_5(lastRuleCallOrigin, this, 5, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// BooleanValue
protected class ParanthesedBooleanExpression_BooleanValueParserRuleCall_0 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_BooleanValueParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getBooleanValueParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BooleanValue_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// CompareOperation
protected class ParanthesedBooleanExpression_CompareOperationParserRuleCall_1 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_CompareOperationParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getCompareOperationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CompareOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCompareOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier())
			return null;
		if(checkForRecursion(CompareOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// SignalReference
protected class ParanthesedBooleanExpression_SignalReferenceParserRuleCall_2 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_SignalReferenceParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getSignalReferenceParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SignalReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(SignalReference_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ValOperation
protected class ParanthesedBooleanExpression_ValOperationParserRuleCall_3 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_ValOperationParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getValOperationParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getValOperationRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ValOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// HostCode
protected class ParanthesedBooleanExpression_HostCodeParserRuleCall_4 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_HostCodeParserRuleCall_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getHostCodeParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(HostCode_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// "(" OrOperation ")"
protected class ParanthesedBooleanExpression_Group_5 extends GroupToken {
	
	public ParanthesedBooleanExpression_Group_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_RightParenthesisKeyword_5_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class ParanthesedBooleanExpression_LeftParenthesisKeyword_5_0 extends KeywordToken  {
	
	public ParanthesedBooleanExpression_LeftParenthesisKeyword_5_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getLeftParenthesisKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// OrOperation
protected class ParanthesedBooleanExpression_OrOperationParserRuleCall_5_1 extends RuleCallToken {
	
	public ParanthesedBooleanExpression_OrOperationParserRuleCall_5_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getOrOperationParserRuleCall_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(OrOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_LeftParenthesisKeyword_5_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParanthesedBooleanExpression_RightParenthesisKeyword_5_2 extends KeywordToken  {
	
	public ParanthesedBooleanExpression_RightParenthesisKeyword_5_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesedBooleanExpressionAccess().getRightParenthesisKeyword_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ParanthesedBooleanExpression_OrOperationParserRuleCall_5_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule ParanthesedBooleanExpression ****************/


/************ begin Rule BooleanExpression ****************
 *
 * // Example: not D and C or ?E = 42 or not (A and (B or C))
 * 
 * 
 * BooleanExpression returns synccharts::Expression:
 *   OrOperation;
 *
 **/

// OrOperation
protected class BooleanExpression_OrOperationParserRuleCall extends RuleCallToken {
	
	public BooleanExpression_OrOperationParserRuleCall(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getOrOperationParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(OrOperation_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule BooleanExpression ****************/


/************ begin Rule HostCode ****************
 *
 * //==============================================================================
 * // Misc
 * //==============================================================================
 * 
 * 
 * HostCode returns synccharts::TextualCode:
 * //"'"code=STRING"'";
 *   code=STRING ("(" type=ID ")")?;
 *
 **/

// //"'"code=STRING"'";
// code=STRING ("(" type=ID ")")?
protected class HostCode_Group extends GroupToken {
	
	public HostCode_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new HostCode_CodeAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// //"'"code=STRING"'";
// code=STRING
protected class HostCode_CodeAssignment_0 extends AssignmentToken  {
	
	public HostCode_CodeAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getCodeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("code",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("code");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getHostCodeAccess().getCodeSTRINGTerminalRuleCall_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getHostCodeAccess().getCodeSTRINGTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("(" type=ID ")")?
protected class HostCode_Group_1 extends GroupToken {
	
	public HostCode_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_RightParenthesisKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class HostCode_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public HostCode_LeftParenthesisKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_CodeAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// type=ID
protected class HostCode_TypeAssignment_1_1 extends AssignmentToken  {
	
	public HostCode_TypeAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_LeftParenthesisKeyword_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("type",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("type");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getHostCodeAccess().getTypeIDTerminalRuleCall_1_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getHostCodeAccess().getTypeIDTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class HostCode_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public HostCode_RightParenthesisKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HostCode_TypeAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule HostCode ****************/


/************ begin Rule Expression ****************
 *
 * Expression returns synccharts::Expression:
 *   ValueExpression|BooleanExpression;
 *
 **/

// ValueExpression|BooleanExpression
protected class Expression_Alternatives extends AlternativesToken {

	public Expression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Expression_ValueExpressionParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Expression_BooleanExpressionParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ValueExpression
protected class Expression_ValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Expression_ValueExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getValueExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ValueExpression_PlusOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPlusOperationAccess().getOperatorExpressionSubExpressionsAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVariableReferenceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ValueExpression_PlusOperationParserRuleCall.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// BooleanExpression
protected class Expression_BooleanExpressionParserRuleCall_1 extends RuleCallToken {
	
	public Expression_BooleanExpressionParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getBooleanExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanValueRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getUnaryOperationRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSignalReferenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHostCodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BooleanExpression_OrOperationParserRuleCall.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Expression ****************/

}
