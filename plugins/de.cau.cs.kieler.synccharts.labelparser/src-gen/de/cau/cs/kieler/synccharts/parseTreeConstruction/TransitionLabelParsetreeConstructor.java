/*
* generated by Xtext
*/
package de.cau.cs.kieler.synccharts.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.synccharts.services.TransitionLabelGrammarAccess;

import com.google.inject.Inject;

public class TransitionLabelParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private TransitionLabelGrammarAccess grammarAccess;
		
	public TransitionLabelGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group(this, this, 0, inst);
			case 1: return new Effect_Alternatives(this, this, 1, inst);
			case 2: return new Emission_Group(this, this, 2, inst);
			case 3: return new Assignment_Group(this, this, 3, inst);
			case 4: return new SignalReference_SignalAssignment(this, this, 4, inst);
			case 5: return new VariableReference_VariableAssignment(this, this, 5, inst);
			case 6: return new IntValue_ValueAssignment(this, this, 6, inst);
			case 7: return new FloatValue_ValueAssignment(this, this, 7, inst);
			case 8: return new BooleanValue_ValueAssignment(this, this, 8, inst);
			case 9: return new Value_Alternatives(this, this, 9, inst);
			case 10: return new HostCode_CodeAssignment(this, this, 10, inst);
			case 11: return new ValOperation_Group(this, this, 11, inst);
			case 12: return new ValueExpression_Alternatives(this, this, 12, inst);
			case 13: return new CompareOperation_Group(this, this, 13, inst);
			case 14: return new NotOperation_Group(this, this, 14, inst);
			case 15: return new NotOrNormalExpression_Alternatives(this, this, 15, inst);
			case 16: return new AndOperation_Group(this, this, 16, inst);
			case 17: return new OrOperation_Group(this, this, 17, inst);
			case 18: return new BooleanExpression_Alternatives(this, this, 18, inst);
			case 19: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 19, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Action ****************
 *
 * Action returns synccharts::Action:
 *   isImmediate?="#" delay=INT? trigger=BooleanExpression? ("/" effects+=Effect*)?; 
 * //import "platform:/resource/de.cau.cs.kieler.synccharts/model/synccharts.ecore" as synccharts
 * //import "synccharts" as synchcharts
 * 
 * //dummy rule to test the language in an editor
 * //Model : 
 * //	((signals+=Signal | variables+=Variable))* (actions+=Action ";")*;
 * 
 *     
 * 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
 * 	         // (";" parentStateEntryAction=[synccharts::State]? ";" parentStateExitAction=[synccharts::State]? ";" parentStateInnerAction=[synccharts::State]?)? ; 		
 * 
 * // dummy rule that will never be parsed. However, the serializer might get
 * // a transition instead of an action and needs to know how to serialize it
 * // here we define, that the textual representation will only hold the elements
 * // of an action. This is only meaningful for the graphical editor. If you need
 * // a proper textual representation of a Transition, you should override this 
 * // rule!
 * //Transition returns synccharts::Transition:
 * //	Action;
 *
 **/

// isImmediate?="#" delay=INT? trigger=BooleanExpression? ("/" effects+=Effect*)? 
// 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
protected class Action_Group extends GroupToken {
	
	public Action_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group_3(parent, this, 0, inst);
			case 1: return new Action_TriggerAssignment_2(parent, this, 1, inst);
			case 2: return new Action_DelayAssignment_1(parent, this, 2, inst);
			case 3: return new Action_IsImmediateAssignment_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// isImmediate?="#" 
// 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
protected class Action_IsImmediateAssignment_0 extends AssignmentToken  {
	
	public Action_IsImmediateAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getIsImmediateAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isImmediate",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isImmediate");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getActionAccess().getIsImmediateNumberSignKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// delay=INT?
protected class Action_DelayAssignment_1 extends AssignmentToken  {
	
	public Action_DelayAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getDelayAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_IsImmediateAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("delay",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("delay");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getActionAccess().getDelayINTTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// trigger=BooleanExpression?
protected class Action_TriggerAssignment_2 extends AssignmentToken  {
	
	public Action_TriggerAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTriggerAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("trigger",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getTriggerBooleanExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_DelayAssignment_1(parent, next, actIndex, consumed);
			case 1: return new Action_IsImmediateAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("/" effects+=Effect*)?
protected class Action_Group_3 extends GroupToken {
	
	public Action_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_EffectsAssignment_3_1(parent, this, 0, inst);
			case 1: return new Action_SolidusKeyword_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class Action_SolidusKeyword_3_0 extends KeywordToken  {
	
	public Action_SolidusKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getSolidusKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_TriggerAssignment_2(parent, this, 0, inst);
			case 1: return new Action_DelayAssignment_1(parent, this, 1, inst);
			case 2: return new Action_IsImmediateAssignment_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// effects+=Effect*
protected class Action_EffectsAssignment_3_1 extends AssignmentToken  {
	
	public Action_EffectsAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getEffectsAssignment_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("effects",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getEffectsEffectParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_EffectsAssignment_3_1(parent, next, actIndex, consumed);
			case 1: return new Action_SolidusKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Action ****************/


/************ begin Rule Effect ****************
 *
 * Effect returns synccharts::Effect:
 *   Emission|Assignment|HostCode; // (";" parentStateEntryAction=[synccharts::State]? ";" parentStateExitAction=[synccharts::State]? ";" parentStateInnerAction=[synccharts::State]?)? ; 		
 * 
 * // dummy rule that will never be parsed. However, the serializer might get
 * // a transition instead of an action and needs to know how to serialize it
 * // here we define, that the textual representation will only hold the elements
 * // of an action. This is only meaningful for the graphical editor. If you need
 * // a proper textual representation of a Transition, you should override this 
 * // rule!
 * //Transition returns synccharts::Transition:
 * //	Action;
 *
 **/

// Emission|Assignment|HostCode // (";" parentStateEntryAction=[synccharts::State]? ";" parentStateExitAction=[synccharts::State]? ";" parentStateInnerAction=[synccharts::State]?)? ; 		
// 
// // dummy rule that will never be parsed. However, the serializer might get
// // a transition instead of an action and needs to know how to serialize it
// // here we define, that the textual representation will only hold the elements
// // of an action. This is only meaningful for the graphical editor. If you need
// // a proper textual representation of a Transition, you should override this 
// // rule!
// //Transition returns synccharts::Transition:
// //	Action;
protected class Effect_Alternatives extends AlternativesToken {

	public Effect_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getEffectAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_EmissionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Effect_AssignmentParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Effect_HostCodeParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Emission
protected class Effect_EmissionParserRuleCall_0 extends RuleCallToken {
	
	public Effect_EmissionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getEmissionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Emission_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEmissionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Assignment
protected class Effect_AssignmentParserRuleCall_1 extends RuleCallToken {
	
	public Effect_AssignmentParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getAssignmentParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// HostCode
protected class Effect_HostCodeParserRuleCall_2 extends RuleCallToken {
	
	public Effect_HostCodeParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getHostCodeParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HostCode_CodeAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(HostCode_CodeAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getHostCodeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Effect ****************/


/************ begin Rule Emission ****************
 *
 * Emission returns synccharts::Emission:
 *   signal=[synccharts::Signal] ("(" newValue=PrimaryExpression ")")?;
 *
 **/

// signal=[synccharts::Signal] ("(" newValue=PrimaryExpression ")")?
protected class Emission_Group extends GroupToken {
	
	public Emission_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_Group_1(parent, this, 0, inst);
			case 1: return new Emission_SignalAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEmissionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signal=[synccharts::Signal]
protected class Emission_SignalAssignment_0 extends AssignmentToken  {
	
	public Emission_SignalAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getSignalAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" newValue=PrimaryExpression ")")?
protected class Emission_Group_1 extends GroupToken {
	
	public Emission_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Emission_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public Emission_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getLeftParenthesisKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_SignalAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// newValue=PrimaryExpression
protected class Emission_NewValueAssignment_1_1 extends AssignmentToken  {
	
	public Emission_NewValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getNewValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("newValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEmissionAccess().getNewValuePrimaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Emission_LeftParenthesisKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Emission_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public Emission_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getRightParenthesisKeyword_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_NewValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Emission ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment returns synccharts::Assignment:
 *   variable=[synccharts::Variable] ":=" expression=PrimaryExpression;
 *
 **/

// variable=[synccharts::Variable] ":=" expression=PrimaryExpression
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_ExpressionAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// variable=[synccharts::Variable]
protected class Assignment_VariableAssignment_0 extends AssignmentToken  {
	
	public Assignment_VariableAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getVariableAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ":="
protected class Assignment_ColonEqualsSignKeyword_1 extends KeywordToken  {
	
	public Assignment_ColonEqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getColonEqualsSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_VariableAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expression=PrimaryExpression
protected class Assignment_ExpressionAssignment_2 extends AssignmentToken  {
	
	public Assignment_ExpressionAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getExpressionAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getExpressionPrimaryExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_ColonEqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Assignment ****************/


/************ begin Rule SignalReference ****************
 *
 * SignalReference returns synccharts::SignalReference:
 *   signal=[synccharts::Signal]; 
 * 
 *     
 * 	    
 * 
 * //SignalReference :
 * //	signal = [Signal];
 *
 **/

// signal=[synccharts::Signal]
protected class SignalReference_SignalAssignment extends AssignmentToken  {
	
	public SignalReference_SignalAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getSignalAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceAccess().getSignalSignalCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSignalReferenceAccess().getSignalSignalCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule SignalReference ****************/


/************ begin Rule VariableReference ****************
 *
 * VariableReference returns synccharts::VariableReference:
 *   variable=[synccharts::Variable]; 
 * 
 * //SignalReference :
 * //	signal = [Signal];
 *
 **/

// variable=[synccharts::Variable]
protected class VariableReference_VariableAssignment extends AssignmentToken  {
	
	public VariableReference_VariableAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getVariableAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableReferenceAccess().getVariableVariableCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getVariableReferenceAccess().getVariableVariableCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule VariableReference ****************/


/************ begin Rule IntValue ****************
 *
 * IntValue:
 *   value=INT;
 *
 **/

// value=INT
protected class IntValue_ValueAssignment extends AssignmentToken  {
	
	public IntValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getIntValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntValue ****************/


/************ begin Rule FloatValue ****************
 *
 * FloatValue:
 *   value=Float;
 *
 **/

// value=Float
protected class FloatValue_ValueAssignment extends AssignmentToken  {
	
	public FloatValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFloatValueAccess().getValueFloatTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule FloatValue ****************/


/************ begin Rule BooleanValue ****************
 *
 * BooleanValue:
 *   value=Boolean;
 *
 **/

// value=Boolean
protected class BooleanValue_ValueAssignment extends AssignmentToken  {
	
	public BooleanValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBooleanValueAccess().getValueBooleanTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanValue ****************/


/************ begin Rule Value ****************
 *
 * Value:
 *   IntValue|FloatValue|BooleanValue; 
 * 
 * 	        
 * 
 * //Signal:
 * //	"signal" name = ID;
 * 	
 * //Variable:
 * //	"variable" name = ID;
 * 
 * // make sure the Float rule does not shadow the built-in INT rule
 *
 **/

// IntValue|FloatValue|BooleanValue 
// 
// 	        
// 
// //Signal:
// //	"signal" name = ID;
// 	
// //Variable:
// //	"variable" name = ID;
// 
// // make sure the Float rule does not shadow the built-in INT rule
protected class Value_Alternatives extends AlternativesToken {

	public Value_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Value_IntValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Value_FloatValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Value_BooleanValueParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntValue
protected class Value_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public Value_IntValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getIntValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class Value_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public Value_FloatValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getFloatValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FloatValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanValue
protected class Value_BooleanValueParserRuleCall_2 extends RuleCallToken {
	
	public Value_BooleanValueParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getBooleanValueParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Value ****************/


/************ begin Rule HostCode ****************
 *
 * HostCode returns synccharts::HostCode:
 *   code=STRING; 
 * 
 *     
 * 	//"'"code=STRING"'";
 * 	 //("(" type=ID ")")?
 *
 **/

// code=STRING 
// 	//"'"code=STRING"'";
// 	 //("(" type=ID ")")?
protected class HostCode_CodeAssignment extends AssignmentToken  {
	
	public HostCode_CodeAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getCodeAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHostCodeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("code",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("code");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getHostCodeAccess().getCodeSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule HostCode ****************/


/************ begin Rule ValOperation ****************
 *
 * ValOperation returns synccharts::ComplexExpression:
 *   operator=ValOperator subExpressions+=SignalReference;
 *
 **/

// operator=ValOperator subExpressions+=SignalReference
protected class ValOperation_Group extends GroupToken {
	
	public ValOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getValOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=ValOperator
protected class ValOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public ValOperation_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getValOperationAccess().getOperatorValOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=SignalReference
protected class ValOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public ValOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_SignalAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getValOperationAccess().getSubExpressionsSignalReferenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValOperation_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ValOperation ****************/


/************ begin Rule ValueExpression ****************
 *
 * ValueExpression returns synccharts::Expression:
 *   IntValue|FloatValue|ValOperation|VariableReference;
 *
 **/

// IntValue|FloatValue|ValOperation|VariableReference
protected class ValueExpression_Alternatives extends AlternativesToken {

	public ValueExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_IntValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ValueExpression_FloatValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new ValueExpression_ValOperationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new ValueExpression_VariableReferenceParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntValue
protected class ValueExpression_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public ValueExpression_IntValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getIntValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class ValueExpression_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public ValueExpression_FloatValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getFloatValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FloatValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ValOperation
protected class ValueExpression_ValOperationParserRuleCall_2 extends RuleCallToken {
	
	public ValueExpression_ValOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getValOperationParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VariableReference
protected class ValueExpression_VariableReferenceParserRuleCall_3 extends RuleCallToken {
	
	public ValueExpression_VariableReferenceParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getVariableReferenceParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_VariableAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableReference_VariableAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ValueExpression ****************/


/************ begin Rule CompareOperation ****************
 *
 * CompareOperation returns synccharts::Expression:
 *   ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator
 *   subExpressions+=ValueExpression);
 *
 **/

// ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator
// subExpressions+=ValueExpression)
protected class CompareOperation_Group extends GroupToken {
	
	public CompareOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompareOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ValueExpression
protected class CompareOperation_ValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public CompareOperation_ValueExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getValueExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValueExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// {Operation.subExpressions+=current} operator=CompareOperator subExpressions+=
// ValueExpression
protected class CompareOperation_Group_1 extends GroupToken {
	
	public CompareOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class CompareOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public CompareOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_ValueExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompareOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator=CompareOperator
protected class CompareOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public CompareOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getCompareOperationAccess().getOperatorCompareOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=ValueExpression
protected class CompareOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public CompareOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompareOperationAccess().getSubExpressionsValueExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompareOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CompareOperation ****************/


/************ begin Rule NotOperation ****************
 *
 * NotOperation returns synccharts::ComplexExpression:
 *   operator=NotOperator subExpressions+=BooleanExpression;
 *
 **/

// operator=NotOperator subExpressions+=BooleanExpression
protected class NotOperation_Group extends GroupToken {
	
	public NotOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=NotOperator
protected class NotOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public NotOperation_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getNotOperationAccess().getOperatorNotOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=BooleanExpression
protected class NotOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public NotOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNotOperationAccess().getSubExpressionsBooleanExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NotOperation_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NotOperation ****************/


/************ begin Rule NotOrNormalExpression ****************
 *
 * NotOrNormalExpression returns synccharts::Expression:
 *   NotOperation|BooleanExpression;
 *
 **/

// NotOperation|BooleanExpression
protected class NotOrNormalExpression_Alternatives extends AlternativesToken {

	public NotOrNormalExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_NotOperationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new NotOrNormalExpression_BooleanExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOperation
protected class NotOrNormalExpression_NotOperationParserRuleCall_0 extends RuleCallToken {
	
	public NotOrNormalExpression_NotOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getNotOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanExpression
protected class NotOrNormalExpression_BooleanExpressionParserRuleCall_1 extends RuleCallToken {
	
	public NotOrNormalExpression_BooleanExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getBooleanExpressionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NotOrNormalExpression ****************/


/************ begin Rule AndOperation ****************
 *
 * AndOperation returns synccharts::Expression:
 *   NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd
 *   subExpression+=NotOrNormalExpression)*;
 *
 **/

// NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd
// subExpression+=NotOrNormalExpression)*
protected class AndOperation_Group extends GroupToken {
	
	public AndOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOrNormalExpression
protected class AndOperation_NotOrNormalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndOperation_NotOrNormalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getNotOrNormalExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOrNormalExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=
// NotOrNormalExpression)*
protected class AndOperation_Group_1 extends GroupToken {
	
	public AndOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_SubExpressionAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpression+=current}
protected class AndOperation_OperationSubExpressionAction_1_0 extends ActionToken  {

	public AndOperation_OperationSubExpressionAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperationSubExpressionAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationAccess().getOperationSubExpressionAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpression", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpression")) return null;
		return getDescr((EObject) val);
	}
}

// operator=OperatorAnd
protected class AndOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_OperationSubExpressionAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getAndOperationAccess().getOperatorOperatorAndEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpression+=NotOrNormalExpression
protected class AndOperation_SubExpressionAssignment_1_2 extends AssignmentToken  {
	
	public AndOperation_SubExpressionAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getSubExpressionAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndOperationAccess().getSubExpressionNotOrNormalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndOperation ****************/


/************ begin Rule OrOperation ****************
 *
 * OrOperation returns synccharts::Expression:
 *   AndOperation ({Operation.subExpressions+=current} operator=OperatorOr
 *   subExpressions+=AndOperation)*; 
 * 
 *     
 * 	      
 * 
 * // TODO: get rid of parentheses
 *
 **/

// AndOperation ({Operation.subExpressions+=current} operator=OperatorOr
// subExpressions+=AndOperation)*
protected class OrOperation_Group extends GroupToken {
	
	public OrOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndOperation
protected class OrOperation_AndOperationParserRuleCall_0 extends RuleCallToken {
	
	public OrOperation_AndOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getAndOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=
// AndOperation)*
protected class OrOperation_Group_1 extends GroupToken {
	
	public OrOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class OrOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public OrOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator=OperatorOr
protected class OrOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getOrOperationAccess().getOperatorOperatorOrEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=AndOperation
protected class OrOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public OrOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrOperationAccess().getSubExpressionsAndOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrOperation ****************/


/************ begin Rule BooleanExpression ****************
 *
 * BooleanExpression returns synccharts::Expression:
 *   BooleanValue|SignalReference|CompareOperation|"(" OrOperation ")"; 
 * 
 * // TODO: get rid of parentheses
 *
 **/

// BooleanValue|SignalReference|CompareOperation|"(" OrOperation ")" 
// 
// // TODO: get rid of parentheses
protected class BooleanExpression_Alternatives extends AlternativesToken {

	public BooleanExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_BooleanValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new BooleanExpression_SignalReferenceParserRuleCall_1(parent, this, 1, inst);
			case 2: return new BooleanExpression_CompareOperationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new BooleanExpression_Group_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BooleanValue
protected class BooleanExpression_BooleanValueParserRuleCall_0 extends RuleCallToken {
	
	public BooleanExpression_BooleanValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getBooleanValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SignalReference
protected class BooleanExpression_SignalReferenceParserRuleCall_1 extends RuleCallToken {
	
	public BooleanExpression_SignalReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getSignalReferenceParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_SignalAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SignalReference_SignalAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CompareOperation
protected class BooleanExpression_CompareOperationParserRuleCall_2 extends RuleCallToken {
	
	public BooleanExpression_CompareOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getCompareOperationParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CompareOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCompareOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "(" OrOperation ")"
protected class BooleanExpression_Group_3 extends GroupToken {
	
	public BooleanExpression_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_RightParenthesisKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class BooleanExpression_LeftParenthesisKeyword_3_0 extends KeywordToken  {
	
	public BooleanExpression_LeftParenthesisKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getLeftParenthesisKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// OrOperation
protected class BooleanExpression_OrOperationParserRuleCall_3_1 extends RuleCallToken {
	
	public BooleanExpression_OrOperationParserRuleCall_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getOrOperationParserRuleCall_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_LeftParenthesisKeyword_3_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class BooleanExpression_RightParenthesisKeyword_3_2 extends KeywordToken  {
	
	public BooleanExpression_RightParenthesisKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getRightParenthesisKeyword_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule BooleanExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns synccharts::Expression:
 *   BooleanExpression; 
 * 
 *     
 * 	//ValueExpression | BooleanExpression;
 *
 **/

// BooleanExpression 
// 	//ValueExpression | BooleanExpression;
protected class PrimaryExpression_BooleanExpressionParserRuleCall extends RuleCallToken {
	
	public PrimaryExpression_BooleanExpressionParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBooleanExpressionParserRuleCall();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule PrimaryExpression ****************/

}
