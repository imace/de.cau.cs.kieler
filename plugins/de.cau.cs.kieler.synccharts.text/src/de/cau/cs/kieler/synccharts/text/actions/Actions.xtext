grammar de.cau.cs.kieler.synccharts.text.actions.Actions with de.cau.cs.kieler.core.kexpressions.KExpressions
 
//// we do not need to generate the transitionlabel ecore model, because we
//// only reuse classes of the official synccharts metamodel
//generate transitionlabel "http://kieler.cs.cau.de/synccharts/actionlabel"
 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/de.cau.cs.kieler.synccharts/model/synccharts.ecore" as synccharts
import "platform:/resource/de.cau.cs.kieler.core.kexpressions/model/kexpressions.ecore" as kexpressions

// haf: We need a Rule for transitions in order to serialize them
// here we only want to have the features isImmediate, delay, trigger and effects
// the features type, targetState, priority, isHistory are ignored and set as transient
// you need to override the rule to support transitions properly

Transition returns synccharts::Transition:
	{synccharts::Transition}
    (annotations += Annotation)*
	(isImmediate?='#')? (delay=INT)? (trigger=BooleanExpression)? ("/" effects+=Effect ((',') effects+=Effect)*)?; 


// chsch: The action rule is used in Kits.xtext for entry-, inner-, exitActions, suspensionTrigger 
Action returns synccharts::Action:
    {synccharts::Action}
//    (annotations += Annotation)*
	(isImmediate?='#')? (delay=INT)? (trigger=BooleanExpression)? ("/" effects+=Effect ((',') effects+=Effect)*)?; 		


Effect returns synccharts::Effect: 
	Emission | Assignment | TextEffect;

		
Emission returns synccharts::Emission:
	signal=[kexpressions::Signal] ( "(" newValue=Expression ")" )?;

    
Assignment returns synccharts::Assignment:
	variable=[kexpressions::Variable] ":=" expression = Expression;


TextEffect returns synccharts::TextEffect:
 	code=HOSTCODE ("(" type=ID ")")?;

enum DivOperator returns kexpressions::OperatorType:	
	DIV=":";
	