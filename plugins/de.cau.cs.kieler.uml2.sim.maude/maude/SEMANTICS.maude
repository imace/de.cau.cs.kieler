mod SEMANTICS is 
  including COMPOUNDTRANSITIONSSYNTAX .
  including COMPOUNDTRANSITIONS .
  including VERTSSYNTAX .
  including VERTS .
  including SEMANTICSSYNTAX .
  including SMGETTER .
  including STATE-DEFAULT .
  including DEEP-DEFAULT .
  including SHALLOW-DEFAULT .
  including HISTORY-CONF .
  including STATE-ACTION .
  including PRIORITY .
  including STATEMACHINE . 
  including eclipseInterface .

	var mastate : MState .	
	var mstate : MState .

    vars src tgt src2 tgt2 : Verts . 
    vars e e2 : Event .
    vars g g2 : Guard .
    vars a af aj a2 af2 aj2 action : Actions .
    vars A AF AJ A2 AF2 AJ2 actions : Actions .
    vars lreg lreg2 : Vert .
	


    vars  ENA : EntryActions .
    vars  EXA : ExitActions .

    vars sm : StateMachine .
    vars HC : HistoryConfs .
    vars hc : HistoryConf .
    vars C2 leaveStates enterStates : Verts . *** Konfiguration
    vars fe : Event . *** event selected for this rtc step
    vars E E2 : EventSet .
    vars ES ES2 : EventSet .
    vars C C' V V2 S : Verts .
    vars NeT : NeCompoundtransitions .    
    vars T T1 T2 F : Compoundtransitions .
    vars t t1 t2 : Compoundtransition .
    vars sT sT1 sT2 sF : BasicTransitions .
    vars st st1 st2 : BasicTransition .
    vars S2 : Verts .
    vars s : ModState .
    vars s2 s3 ds1 ds2 : ModState .
    vars V_vert V_vert2 v : Vert .
    vars R : Verts .
    vars r r2 r3 : Region .
    vars c : CompositeID .
    vars shn : HistShallowID .
    vars dhn : HistDeepID .
    vars D : Defaults .
    vars d : Default .
    vars SH : ShallowDefaults .
    vars sh : ShallowDefault .
    vars DH : DeepDefaults .
    vars dh : DeepDefault .
    vars str : String .
    vars MN : Sets .

	 
			  		
	rl [noevents] : maState (stableC V HC) (ev: "noevent") => 
	maState (doneC V HC) empty .

    *** ToDo: Currently events are NOT consumed 
	crl [selectEventFSetESINT] : maState (stableC V HC) (e2, ES) => 
	maState (eventSelC V HC e2) (ES, e2) if (e2 =/= empty) and (e2 =/= (ev: "noevent")) [print "selected " e2] .
	crl [discardFSetESINT] : maState (eventSelC V HC e2) (ES) => 
		maState (doneC V HC) (ES) if 
		(enabled V e2) == empty [print "discarded " e2]  .

	crl [computeFSetESINT] : maState (eventSelC V HC e2) (ES) => 
		maState (fireC V HC 
			(fireableSets 
				(remLowPrio 
					(enabled 
						V 
						e2
					)
				)) 
		) (ES) if 
		(enabled V e2) =/= empty 
		*** [print "firesets for " e2] 
		.
	rl [fireFSetESINT] : maState (fireC V HC (mm(NeT), MN)) ES => 
		maState (unstableC V HC NeT noac) ES 
		[print "choosen " NeT " not considered " MN] 
		.

	rl [finishedRTCESINT] : maState (doneC V HC) ES => 
		maState (stableC V HC) ES .

    rl [doneExecTrans] : maState (unstableC V HC empty A) ES =>
     maState (doneC V (succHC V HC)) ES [print "done executing all transitions "] .
***     maState (doneC V HC) ES [print "done executing all transitions "] .
 
    rl [fireTrans] : maState (unstableC V HC (t, T) A) ES =>
       maState (leaveC V HC T t (inTrans t) (outTrans t) (leave V t) A) ES 
       *** . 
       [print "fire CTrans " t] .
    rl [fireTrans] : maState (unstableC V HC t A) ES =>
       maState (leaveC V HC empty t (inTrans t) (outTrans t) (leave V t) A) ES 
       *** .
       [print "fire CTrans " t] .

 *** started by maState (unstableC V HC (t, T) (par A)) ES => 
 ***  maState ((leaveC V HC T t (inTrans t) (outTrans t) (leave V t) (par A)) ES 
    crl [leaveState] : maState (leaveC V HC T t sT sT1 (v, leaveStates) A) ES =>
     maState (leaveC (V \ v)  HC T t sT sT1 leaveStates A) ES 
     if (((intersection (leaveStates, (getSubVerts v))) == empty) and not(typeRegion v)) [print "leaving " v] .
    crl [leaveState] : maState (leaveC V HC T t sT sT1 (v, leaveStates) A) ES =>
     maState (leaveC (V \ v)  HC T t sT sT1 leaveStates A)  ES 
     if ((intersection (leaveStates, (getSubVerts v)) == empty) and (typeRegion v)) [print "leaving " v] .

    rl [statesLeft] : maState (leaveC V HC T t sT sT1 empty A) ES => maState (execTransC V  HC T t sT sT1 A) ES [print "stateLeft for " t] .

    *** add the effect of the transition to the actions, valuations
    rl [execBTransincomingPstate] : maState (execTransC V HC T t (st, sT) sT1       A) ES => maState (execTransC V  HC T t sT sT1 A) ES .
    crl [execBTrans2] : maState (execTransC V HC T t empty       sT1 A) ES => maState (execChoiceOut V  HC T t empty sT1 A) ES if (isChoice t) .
    crl [execBTrans2] : maState (execTransC V HC T t empty    (st, sT1) A) ES => maState (execTransC V  HC T t empty sT1 A) ES if not(isChoice t) .
   


    rl [enterStatesForNonChoiceTrans] : maState (execTransC V HC T t empty empty A) ES => 
     maState(enterC V HC T t (enterH HC t) A) ES .
    rl [enterStatesForChoiceTrans] : maState (execChoiceOut V HC T t empty sT1 A) ES => 
     maState(enterC V HC T t (enterH HC (chooseChoice t V)) A) ES .

    crl [enterState] : maState (enterC V HC T t (v, enterStates) A) ES => 
     maState (enterC (V, v) HC T t enterStates A) ES 
     if (((intersection (enterStates, (start v))) == empty) and not(typeRegion v)) [print "entering state " v V] .

    crl [enterState] : maState (enterC V HC T t (v, enterStates) A) ES =>
     maState (enterC (V, v)  HC T t enterStates A)  ES 
     if ((intersection (enterStates, (start v)) == empty) and (typeRegion v))  [print "entering region " v V] .

    rl [doneExecTrans] : maState (enterC V HC T t empty A) ES =>
***     maState (doneC V (succHC V HC)) ES .
     maState (unstableC V HC T A) ES [print "done executing " t] .

    
     



endm
***( 

endm  
)*** 		
  
