fmod COMPOUNDTRANSITIONS is
  including EVENT .
  including VERTS .
  including ACTIONS .
  including PRIORITY .
  including COMPOUNDTRANSITIONSSYNTAX .

  vars T T2 F : Compoundtransitions .
  vars NeT : NeCompoundtransitions .
  vars t t2 : Compoundtransition .
  vars sT sT2 sF : Transitions .
  vars st st2 : Transition .
  vars src tgt src2 tgt2 C : Verts . 
  vars e e2 fe : Event .
  vars E1 : Events .
  vars g g2 : Guard .
  vars A AF AJ A2 AF2 AJ2 actions : Actions .
  vars a af aj a2 af2 aj2 action : Action .
  vars lreg lreg2 : Vert .
  var str strid mode : String .  
  vars M N : Menge .
  vars MN NN : Sets .
  vars NeMN : NeSets .
  var reg : Region .
   
  op mm_ : Compoundtransitions -> Menge .
          
     *** optimize that   
     *** for choice only
     *** add valuations


  op chooseChoice__ : Compoundtransition Verts -> Compoundtransition .
  eq chooseChoice (choiceTrans strid e st sT reg) C = (choiceTrans strid e st ($chooseChoice empty C sT) reg) .
  
  op $chooseChoice___ : Transition Verts Transitions -> Transition .
  ceq $chooseChoice st C (st2, sT) = $chooseChoice st2 C sT if ((guard st2) == choiceelse) .
  ceq $chooseChoice st C (st2, sT) = st2 if (evalGuard (guard st2) C) .
  ceq $chooseChoice empty C (st2, sT) = $chooseChoice st2 C sT if ((guard st2) == choiceelse) .
  ceq $chooseChoice empty C (st2, sT) = st2 if (evalGuard (guard st2) C) .
  eq $chooseChoice empty C st2 = st2 .
  ceq $chooseChoice st C st2 = st2 if (evalGuard (guard st2) C) .
  eq $chooseChoice st C st2 = st [owise] .

  
    
  op conflict__ : Compoundtransition Compoundtransitions -> Bool .
  eq conflict t (t2, T) = 
  ((prefix (region t) (region t2)) or 
        			(prefix (region t2) (region t))) or 
  						(conflict t T) .
  eq conflict t empty = false .

  op remLowPrio_ : Compoundtransitions -> Compoundtransitions .
  eq remLowPrio T = $remLowPrio empty T .

  op $remLowPrio__ : Compoundtransitions Compoundtransitions -> Compoundtransitions .
  ceq $remLowPrio T (T2, t) = $remLowPrio (T, t) T2 
  	if noHigherPrio t (T, T2) .
  ceq $remLowPrio T (T2, t) = $remLowPrio T T2 if not (noHigherPrio t (T, T2)) .
  eq $remLowPrio T empty = T .


  op enabled__ : Verts Event -> Compoundtransitions .    
  eq enabled C e2 = $enabled C e2 (getTrans SMINT) .
     
     
     *** optimize that   
  op $enabled___ : Verts Event Compoundtransitions -> Compoundtransitions .
  eq $enabled C e2 (T ,  t) = ($$enabled C e2 t) ,  ($enabled C e2 T) .
  eq $enabled C e2 empty = empty .
  op $$enabled___ : Verts Event Compoundtransition -> Compoundtransition .
  ceq $$enabled C e2 t = t if ((source t) subset C) and (event t) == e2 
  and (evalGuard (guard t) C) 
  . 
  eq $$enabled C e2 t = empty [owise] .


  op leave __ : Verts Compoundtransitions -> Verts .
  eq leave C empty = empty .
  eq leave C t =
       intersection((upset (region t) C) \ (region t), C) .
  eq leave C (T ,  t) = (leave C T) ,  (leave C t) .
  
  op fire _____ : String Verts Event Compoundtransitions Compoundtransitions -> Compoundtransitions [memo] .
  ***(
  eq fire "UML" C fe T F = fireUML C fe T F .
  eq fire str C fe T F = fireSC C fe T F [owise] .
 
  op fireSC ____ :  Verts Event Compoundtransitions Compoundtransitions -> Compoundtransitions .
  ceq fireSC C fe (t, T) F = fireSC C fe T (F, t)
    if not (conflict t F) and (noHigherPrioSC t T) [label fire1] .
  eq fireSC C fe empty F = F .
  eq fireSC C fe (t, T) F = fireSC C fe T F [owise] .

  op fireUML ____ :  Verts Event Compoundtransitions Compoundtransitions -> Compoundtransitions .
  ceq fireUML C fe (T, t, T2) F = fireUML C fe (T, T2) (F, t)
    if not (conflict t F) and (noHigherPrioUML t (T, T2)) [label fire1] .
  eq fireUML C fe empty F = F .
  eq fireUML C fe (T, t, T2) F = fireUML C fe (T, T2) F [owise] .
)***

  *** here we require a set transitons which is not free of conflicting Compoundtransitions but these 
  *** are not related by the priority relation.
  
  op getConflTrans__ : Compoundtransition Compoundtransitions -> Compoundtransitions .
  ceq getConflTrans t (t2, T) = t2, (getConflTrans t T) if (conflict t t2) .
  eq getConflTrans t (t2, T) = (getConflTrans t T) [owise] .
  eq getConflTrans t empty = empty .
  

  op getConflSets_ : Compoundtransitions -> Sets .
  ceq getConflSets (t, T) = mm((getConflTrans t T), t), getConflSets (T \ ((getConflTrans t T),t)) 
      if (getConflTrans t T) =/= (empty).Compoundtransition .
  eq getConflSets (t, T) = mm (t), getConflSets T [owise] .
  eq getConflSets (empty).Compoundtransition = (empty).Menge . 
  
  op getDeepestScope_ : Compoundtransitions -> Compoundtransitions .
  eq getDeepestScope T = $getDeepestScope T empty .
  
  op $getDeepestScope__ : Compoundtransitions Compoundtransitions -> Compoundtransitions .
  eq $getDeepestScope empty T = T .
  eq $getDeepestScope (t, T) empty = $getDeepestScope (t, T) t .
  ceq $getDeepestScope (t, T) (t2, T2) = $getDeepestScope T (t, t2, T2) 
    if len(region(t)) == len(region(t2)) .
  ceq $getDeepestScope (t, T) (t2, T2) = $getDeepestScope T t 
    if len(region(t)) > len(region(t2)) .
  eq $getDeepestScope (t, T) (t2, T2) = $getDeepestScope T (t2, T2) 
    [owise] .
  
		

  ******************************************************************
  *** das funktioniert jetzt
  ******************************************************************
  *** alle (Konflikt) Compoundtransitionen jeweils mit der Menge kombinieren
  *** Ceq erklaeren
  op $allIntoAll__ : Compoundtransitions Menge -> Sets .
  ceq $allIntoAll (t, T) mm(T2) = mm(t, T2), ($allIntoAll T mm(T2)) if (getConflTrans t T2) == empty .
  eq $allIntoAll (t, T) mm(T2) = mm(t, (T2 \(getConflTrans t T2))), mm(T2), ($allIntoAll T mm(T2)) [owise] .
  eq $allIntoAll empty M = empty .
 
   *** alle (Konflikt) Compoundtransitionen mit allen Sets kombinieren
  op allIntoAll__ : Compoundtransitions Sets -> Sets .
  eq allIntoAll T (M, NeMN) = ($allIntoAll T M), (allIntoAll T NeMN) .
  eq allIntoAll T M = $allIntoAll T M .
  eq allIntoAll (t, T) empty = mm(t), (allIntoAll T empty) .
  eq allIntoAll empty empty = empty .
  *** alle Sets von (Konflikt) Compoundtransitionen miteinander kombinieren
  *** wir kombinieren jeweils eine Compoundtransition aus jeder Menge von Compoundtransitionen
  *** zu Sets von Compoundtransitionen 
  op allSetsIntoAll__ : Sets Sets -> Sets .
  eq allSetsIntoAll ((mm T), MN) NN  = (allSetsIntoAll MN (allIntoAll T NN)) .
  eq allSetsIntoAll empty MN = MN .


  *** Compoundtransitionen mit vergleichbarer und niedrigerer Prioritaet werden mit remLowPrio
  *** zuvor entfernt.  
  *** von den simple states (Blaettern) ausgehend zur root region (getDeepestScope NeT) 
  *** die Menge der Sets feuerbarer Compoundtransitionen MN um die (Konflikt)Transitionen 
  *** auf diesem Level(Abstand zur root Region) in der State Hierarchy erweitern
  *** es ist moeglich, dass in einer hoeher gelegenen region ein Compoundtransition im Konflikt mit bereits 
  *** hinzugefuegten Compoundtransitionen ist.
  *** Im Jarnal Beispiel sind das die Compoundtransitionen 0,1,4 oder 5 mit der Compoundtransition 3
  *** Dann haben wir 2 Sets feuerbarer Compoundtransitionen:
  ***  - die gegebene Menge ohne 0,1,4 und 5 aber mit 3 also mm(t, (T2 \(getConflTrans t T2))) und 
  ***  - die unveraenderte Menge, mit einer passenden Kombination von 0,1,4 und 5 ohne 3 mm(T2)	
  *** siehe dazu vorallem oben bei $allIntoAll 
  ******************************************************************
  *** das funktioniert 
  ******************************************************************   
  op fireableSets_ : Compoundtransitions -> Sets .
  eq fireableSets T = $fireableSets T empty .
  
  op $fireableSets__ : Compoundtransitions Sets -> Sets .
  eq $fireableSets NeT MN = $fireableSets (NeT \(getDeepestScope NeT))
       (allSetsIntoAll(getConflSets(getDeepestScope NeT)) MN) .
  eq $fireableSets empty MN = MN .

 endfm
