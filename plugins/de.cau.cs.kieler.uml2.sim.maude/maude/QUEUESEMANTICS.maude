load EVENTSYNTAX .

fmod QUEUESIGNATURE is 
  including LIST{Event} * (sort List{Event} to EventList, sort NeList{Event} to NeEventList) .
  sort EventQueue .
  op QUEUE_ENDQUEUE : EventList -> EventQueue .
  op emptyQueue : -> EventQueue .
  eq emptyQueue = QUEUE nil ENDQUEUE .        
endfm

mod QUEUESEMANTICS is 
 including QUEUESIGNATURE .
     sort QueueStatus .
 var el : EventList .
 var event : Event .
 var equeue : EventQueue .

 ops e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 : -> Event [ctor] .

 
 *** these rules have to generated by the eclpise tranformation
 rl [add-0] : QUEUE el ENDQUEUE => QUEUE el (e0)ENDQUEUE .
 rl [add-1] : QUEUE el ENDQUEUE => QUEUE el (e1)ENDQUEUE .
 rl [add-2] : QUEUE el ENDQUEUE => QUEUE el (e2)ENDQUEUE .
 rl [add-3] : QUEUE el ENDQUEUE => QUEUE el (e3)ENDQUEUE .
 rl [add-4] : QUEUE el ENDQUEUE => QUEUE el (e4)ENDQUEUE .
 rl [add-5] : QUEUE el ENDQUEUE => QUEUE el (e5)ENDQUEUE .
 rl [add-6] : QUEUE el ENDQUEUE => QUEUE el (e6)ENDQUEUE .
 rl [add-7] : QUEUE el ENDQUEUE => QUEUE el (e7)ENDQUEUE .
 rl [add-8] : QUEUE el ENDQUEUE => QUEUE el (e8)ENDQUEUE .
 rl [add-9] : QUEUE el ENDQUEUE => QUEUE el (e9)ENDQUEUE .


 op <ready_ > : EventQueue -> QueueStatus .
 op <schedule__ > : EventQueue Event -> QueueStatus .
 op <initQueue> : -> QueueStatus .
  
 rl <ready (QUEUE event el ENDQUEUE) > => <schedule (QUEUE el ENDQUEUE) event > .
 rl <schedule equeue event >  => <ready equeue > .
 rl <initQueue> => <ready emptyQueue > . 

endm



***rew [50] initQueue .

