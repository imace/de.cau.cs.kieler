«IMPORT uml»

«REM»
MUST BE:
«EXTENSION model::Extensions»
FOR KIELER RCA !!! Otherwise the Extensions cannot be found!
updatesite fix! extensions not found in models folder because it seems not to be extracted, this is now fixed when building the update site
«ENDREM»
«EXTENSION Extensions»

«DEFINE main FOR Model»
   «EXPAND sm FOREACH packagedElement»
«ENDDEFINE»

«DEFINE main FOR Package»
   «EXPAND sm FOREACH packagedElement»
«ENDDEFINE»


	
«DEFINE sm FOR StateMachine»
	«FILE ((String)(GLOBALVAR modelname)) +".maude"»
	
load «((String)(GLOBALVAR maudebasecode))»VERTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»ACTIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»EVENTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINESYNTAX
load «((String)(GLOBALVAR maudebasecode))»SEMANTICSSYNTAX

fmod eclipseInterface is
  including COMPOUNDTRANSITIONSSYNTAX .
  including TRANSITIONSYNTAX .
  including VERTSSYNTAX .
  including SEMANTICSSYNTAX .
  including STATE-ACTION .
  including STATEMACHINESYNTAX . 
 *** // Events //
  ops «FOREACH this.getTriggerEvents() AS event SEPARATOR " "-»«event-»«ENDFOREACH-» : -> Event .
  op allEvents : -> EventSet .

*** // allActions //
«REM» ToDo: no double entries, no nils? nil == falsche transitionen, fehlende beschriftung«ENDREM»	
«REM» skip needs to be added automatically «ENDREM»	
  ops skip «FOREACH this.getActions() AS action SEPARATOR " "-»«action-»«ENDFOREACH-» : -> Action .

***// States //
  «IF  this.getStates().size > 0-»
  ops «FOREACH this.getStates() AS state SEPARATOR " "-»«((State)state).getId()-»«ENDFOREACH-» : -> ModState .	
	«FOREACH this.getMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .	
  «ENDIF-»
  	
«REM»also generate history and deep history states«ENDREM» 
***// PseudoStates //
*** history
  «IF  this.getHistoryStates().size > 0-»
  ops «FOREACH this.getHistoryStates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> ModState .	
	«FOREACH this.getHistoryMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»
*** choice
  «IF  this.getRelevantPseudotates().size > 0-»
  ops «FOREACH this.getRelevantPseudotates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> ModState .	
	«FOREACH this.getPseudoMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»

  	
***// Regions //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«region.getId()-»«ENDFOREACH-» : -> Region .
	«FOREACH this.getMaudeRegions() AS region SEPARATOR " .\n"-»«region-»«ENDFOREACH-» .
***// allVerts //
  op allVerts : -> Verts .
  eq allVerts = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«region.getId()-»«ENDFOREACH-» , «FOREACH this.getStates() AS state SEPARATOR ", "-»«((State)state).getId()-»«ENDFOREACH-» .
	
	
  	«REM»FIXME: only consider regions containing initial states for ops and allDefs«ENDREM» 
***// defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"def"+region.getId()-»«ENDFOREACH-» : -> Default .
  «FOREACH this.getInitialTransitions() AS transition SEPARATOR ""-»«transition.genDefault()-»«ENDFOREACH-»
  op allDefs : -> Defaults .
  eq allDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"def"+region.getId()-»«ENDFOREACH-» .
  
	«REM»FIXME: only consider regions containing history states with outgoing transitions for ops and allDefs«ENDREM» 
***// deep defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"dDef"+region.getId()-»«ENDFOREACH-» : -> DeepDefault .
  «FOREACH this.getDHDTransitions() AS transition SEPARATOR ""-»«transition.genDHDefault()-»«ENDFOREACH-»
  op allDHDefs : -> DeepDefaults .
  eq allDHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"dDef"+region.getId()-»«ENDFOREACH-» .

	«REM»FIXME: only consider regions containing history states with outgoing transitions for ops and allDefs«ENDREM» 
***// shallow defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"sDef"+region.getId()-»«ENDFOREACH-» : -> ShallowDefault .
  «FOREACH this.getSHDTransitions() AS transition SEPARATOR ""-»«transition.genSHDefault()-»«ENDFOREACH-»
  
  op allSHDefs : -> ShallowDefaults .
  eq allSHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"sDef"+region.getId()-»«ENDFOREACH-» .

*** Transitions
«REM» First calculate psudostates (Fork / Join) for complex transition ids «ENDREM»
«clearDoneVertices()-»
«FOREACH this.getForkJoinChoice() AS pseudostate-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «ignore(pseudostate.getPseudoSourceVertices().toString())-»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
«ENDFOREACH-»
«REM»No getPseudostates() can be queried«ENDREM»

*******************
*** basic transitions op declaration
*******************      
*** ToDo: Add trigger statt noevent!!
  ops «FOREACH this.getTransitions().select(e|e.isBasicTrans())  AS transition SEPARATOR "  "-»tr«transition.getId()-»«ENDFOREACH-»
      : -> BasicTransition .

*******************
*** compound transitions op declaration
*******************      
  ops «FOREACH getPseudostates()  AS pseudostate SEPARATOR "  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  «FOREACH this.getTransitions().select(e|e.isBasicCompound())  AS transition SEPARATOR "  "-»ctr«transition.getId()-»«ENDFOREACH-»
      : -> Compoundtransition .

      
*******************
*** compound transitions
*******************
  «FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR '\n'-»«transition.genMaudeBasicCompound()-»«ENDFOREACH-»


  «FOREACH this.getTransitions().select(e|e.isBasicTrans()) AS transition SEPARATOR '\n'-»«transition.genMaude2()-»«ENDFOREACH-»

  «REM» We now work thru the Fork and Join and Choice nodes. «ENDREM»
  «resetPseudostates()-»
  «REM»Clear marked vertices«ENDREM»
  «clearDoneVertices()-»
  «FOREACH this.getForkJoinChoice() AS pseudostate SEPARATOR '\n'-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «REM» Protocol: getPseudoTargetTransitions has to be called BEFORE getComplexTransitionInformation can be called.
   Therefore the PsuedoSourceTransitions list is memorized as a temporary variable as it is used later than the
   getComplexTransitionInformation. 
   «ENDREM»
   «LET pseudostate.getPseudoSourceTransitions() AS PseudoSourceTransitions -»
   	eq ctr«pseudostate.getId()-» = «pseudostate.getClassIdentifier()-» "ctr«pseudostate.getId()-»" «getComplexTransitionInformation("TRIGGER").get(0)» («FOREACH PseudoSourceTransitions AS source SEPARATOR ','-»tr«source.getId()-»«ENDFOREACH-») («FOREACH pseudostate.getPseudoTargetTransitions() AS target SEPARATOR ','-»tr«target.getId()-»«ENDFOREACH-») «getLastRootRegion().getId()-» . «resetLastRootRegion()-»
   «ENDLET»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
  «ENDFOREACH-»
  
  «REM»
   TODO: 
     allTrans mit allen basic und simple transitions?! Dann sollte man die genMaude2() Funktion eher (als Codegenerierung) 
     nach Xpand verlagern und die (wiederverwendbare) Auswahlfunktion/ID-Funktion nach Xtend.
   
  «ENDREM»
  
  op allTrans : -> Compoundtransitions .
  eq allTrans = «FOREACH getPseudostates()  AS pseudostate SEPARATOR ",  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  				«IF (getPseudostates().size > 0 && this.getTransitions().select(e|e.isBasicCompound()).size > 0)-»,«ENDIF-»
				«FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR ", "-»ctr«transition.getId()-»«ENDFOREACH-»
 				.

 				
***/// A state machine consits of Vertices Defaultsstatesfunction ShallowDefaultstatesfunction DeepDefaultstatesfunction EntryActionsfunction ExitActionsFunction Transitions 
  op SMINT : -> StateMachine .
  ***// ToDo: add entry/exit actions//
  eq SMINT = (allVerts allDefs allSHDefs allDHDefs (empty).EntryActions (empty).ExitActions allTrans) .

endfm

load model-checker
*** next we need getter functions for the SM
load «((String)(GLOBALVAR maudebasecode))»SMGETTER
load «((String)(GLOBALVAR maudebasecode))»VERTS .
load «((String)(GLOBALVAR maudebasecode))»ACTIONS .
load «((String)(GLOBALVAR maudebasecode))»UMLPRIORITY
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONS
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINE
load «((String)(GLOBALVAR maudebasecode))»SEMANTICS
mod INIT is
	including SEMANTICS .
	including SATISFACTION .
	including LTL .
	including MODEL-CHECKER .
	including LTL-SIMPLIFIER .
	
	
	subsort MState < State .

	vars msst mastate : MState .
	vars V V2 : Verts .
	var E : EventSet .
	vars HC : HistoryConfs .
	
	subsort MState < State .
	
	op aCf : Actions -> Prop .
	op inC : Verts -> Prop .
    ceq maState (stableC V HC) E |= inC(V2) = true if (V2 subset V)  .
	eq msst |= inC(V) = false [owise] .

	
	op isDone_ : MState -> Bool .
	eq isDone (maState (doneC V HC) E) = true .
	eq isDone msst = false [owise] .
	
endm

«REM» state machine definition ends here, following the Eclipse interface module referenced by maude core step sem
load «((String)(GLOBALVAR maudebasecode))»QUEUESYNTAX
 mod QUEUESEMANTICS is 
 including eclipseInterface .
 including QUEUESIGNATURE .
     sort QueueStatus .
 var el : EventList .
 var event : Event .
 var equeue : EventQueue .

 «FOREACH this.getTriggerEvents() AS event SEPARATOR '\n'-»rl QUEUE el ENDQUEUE => QUEUE el («event-») ENDQUEUE .«ENDFOREACH-»

 op <ready_ > : EventQueue -> QueueStatus .
 op <schedule__ > : EventQueue Event -> QueueStatus .
 op <initQueue> : -> QueueStatus .
  
 rl <ready (QUEUE event el ENDQUEUE) > => <schedule (QUEUE el ENDQUEUE) event > .
 rl <schedule equeue event >  => <ready equeue > .
 rl <initQueue>s => <ready emptyQueue > . 

endm
*** so far there is no need for event semantics

«ENDREM»

***(
***load «((String)(GLOBALVAR maudebasecode))»ACCS
***load «((String)(GLOBALVAR maudebasecode))»BFAIRPOOL
)***

«REM»

***(
set break on .
break select finishedRTCESINT discardFSetESINT .
)***

***(
#####################################################
##          Interface     for     Eclipse          ##        
#####################################################
search (maState (stableC (State0-885791716,R-2027565592) empty) (d,a)) =>* mastate such that isDone mastate . 

bzw. wenn die ID-String bei dir anders sind 

search (maState (stableC (<Konfiguration>) <HistoryKonfiguration>) (<EventSet>)) =>* mastate such that isDone mastate . 


- <Konfiguration>: eine durch "," getrennte Menge von Regionen und States. Diese muss den Anforderungen im Standard entsprechen.
  z.B: Rroot, Csusp (aus Test.maude)
- <HistoryKonfiguration>: kann erstmal empty sein
- <EventSet>: eine durch "," getrennte Menge von Events die abgearbeitet werden soll




)***
«ENDREM»

	«ENDFILE»
«ENDDEFINE»


«REM» needed else branch - should not be taken but should not have any effect «ENDREM»
«DEFINE sm FOR PackageableElement»
«ENDDEFINE»

«REM» needed else branch - should not be taken but should not have any effect «ENDREM»
«DEFINE init FOR PackageableElement»
«ENDDEFINE»
