«IMPORT uml»

«REM»
MUST BE:
«EXTENSION model::Extensions»
FOR KIELER RCA !!! Otherwise the Extensions cannot be found!
updatesite fix! extensions not found in models folder because it seems not to be extracted, this is now fixed when building the update site
«ENDREM»
«EXTENSION Extensions»

«DEFINE main FOR Model»
   «EXPAND sm FOREACH packagedElement»
«ENDDEFINE»

«DEFINE main FOR Package»
   «EXPAND sm FOREACH packagedElement»
«ENDDEFINE»


	
«DEFINE sm FOR StateMachine»
	«FILE ((String)(GLOBALVAR modelname)) +".maude"»
	
load «((String)(GLOBALVAR maudebasecode))»VERTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»ACTIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»EVENTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINESYNTAX
load «((String)(GLOBALVAR maudebasecode))»SEMANTICSSYNTAX

fmod eclipseInterface is
  including COMPOUNDTRANSITIONSSYNTAX .
  including TRANSITIONSYNTAX .
  including VERTSSYNTAX .
  including SEMANTICSSYNTAX .
  including STATE-ACTION .
  including STATEMACHINESYNTAX . 
 *** // Events //
  ops «FOREACH this.getTriggerEvents() AS event SEPARATOR " "-»«event-»«ENDFOREACH-» : -> Event .
  op allEvents : -> Events .

*** // allActions //
«REM» ToDo: no double entries, no nils? nil == falsche transitionen, fehlende beschriftung«ENDREM»	
«REM» skip needs to be added automatically «ENDREM»	
  ops skip «FOREACH this.getActions() AS action SEPARATOR " "-»«action-»«ENDFOREACH-» : -> Action .

***// States //
  «IF  this.getStates().size > 0-»
  ops «FOREACH this.getStates() AS state SEPARATOR " "-»«((State)state).getId()-»«ENDFOREACH-» : -> State .	
	«FOREACH this.getMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .	
  «ENDIF-»
  	
«REM»also generate history and deep history states«ENDREM» 
***// PseudoStates //
*** history
  «IF  this.getHistoryStates().size > 0-»
  ops «FOREACH this.getHistoryStates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> State .	
	«FOREACH this.getHistoryMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»
*** choice
  «IF  this.getRelevantPseudotates().size > 0-»
  ops «FOREACH this.getRelevantPseudotates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> State .	
	«FOREACH this.getPseudoMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»

  	
***// Regions //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«region.getId()-»«ENDFOREACH-» : -> Region .
	«FOREACH this.getMaudeRegions() AS region SEPARATOR " .\n"-»«region-»«ENDFOREACH-» .
***// allVerts //
  op allVerts : -> Verts .
  eq allVerts = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«region.getId()-»«ENDFOREACH-» , «FOREACH this.getStates() AS state SEPARATOR ", "-»«((State)state).getId()-»«ENDFOREACH-» .
	
***// defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"def"+region.getId()-»«ENDFOREACH-» : -> Default .
  «FOREACH this.getInitialTransitions() AS transition SEPARATOR ""-»«transition.genDefault()-»«ENDFOREACH-»
  op allDefs : -> Defaults .
  eq allDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"def"+region.getId()-»«ENDFOREACH-» .
  
***// deep defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"dDef"+region.getId()-»«ENDFOREACH-» : -> DeepDefault .
  «FOREACH this.getDHDTransitions() AS transition SEPARATOR ""-»«transition.genDHDefault()-»«ENDFOREACH-»
  op allDHDefs : -> DeepDefaults .
  eq allDHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"dDef"+region.getId()-»«ENDFOREACH-» .

***// shallow defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"sDef"+region.getId()-»«ENDFOREACH-» : -> ShallowDefault .
  «FOREACH this.getSHDTransitions() AS transition SEPARATOR ""-»«transition.genSHDefault()-»«ENDFOREACH-»
  
  op allSHDefs : -> ShallowDefaults .
  eq allSHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"sDef"+region.getId()-»«ENDFOREACH-» .

*** Transitions
«REM» First calculate psudostates (Fork / Join) for complex transition ids «ENDREM»
«clearDoneVertices()-»
«FOREACH this.getForkJoinChoice() AS pseudostate-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «ignore(pseudostate.getPseudoSourceVertices().toString())-»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
«ENDFOREACH-»
«REM»No getPseudostates() can be queried«ENDREM»

*******************
*** basic transitions op declaration
*******************      
*** ToDo: Add trigger statt noevent!!
  ops «FOREACH this.getTransitions().select(e|e.isBasicTrans())  AS transition SEPARATOR "  "-»tr«transition.getId()-»«ENDFOREACH-»
      : -> Transition .

*******************
*** compound transitions op declaration
*******************      
  ops «FOREACH this.getTransitions().select(e|e.isBasicCompound())  AS transition SEPARATOR "  "-»ctr«transition.getId()-»«ENDFOREACH-»
      : -> Compoundtransition .

      
*******************
*** compound transitions
*******************
  «FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR '\n'-»«transition.genMaudeBasicCompound()-»«ENDFOREACH-»


  «FOREACH this.getTransitions().select(e|e.isBasicTrans()) AS transition SEPARATOR '\n'-»«transition.genMaude2()-»«ENDFOREACH-»

  «REM» We now work thru the Fork and Join nodes. For all CCs ending with non Fork/Join nodes, we just construct ONE combined transition. «ENDREM»
  «resetPseudostates()-»
  «REM»Clear marked vertices«ENDREM»
  «clearDoneVertices()-»
  «FOREACH this.getForkJoinChoice() AS pseudostate SEPARATOR '\n'-»
   «IF !pseudostate.isDone("OUTGOING")-»
   eq ctr«pseudostate.getId()-» = «pseudostate.getClassIdentifier()-» "ctr«pseudostate.getId()-»" «getComplexTransitionInformation("TRIGGER").get(0)» («FOREACH pseudostate.getPseudoSourceTransitions() AS source SEPARATOR ','-»tr«source.getId()-»«ENDFOREACH-») («FOREACH pseudostate.getPseudoTargetTransitions() AS target SEPARATOR ','-»tr«target.getId()-»«ENDFOREACH-») «getLastRootRegion().getId()-» . «resetLastRootRegion()-»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
  «ENDFOREACH-»
  
  «REM»
   TODO: 
     allTrans mit allen basic und simple transitions?! Dann sollte man die genMaude2() Funktion eher (als Codegenerierung) 
     nach Xpand verlagern und die (wiederverwendbare) Auswahlfunktion/ID-Funktion nach Xtend.
   
  «ENDREM»
  
  op allTrans : -> Transitions .
  eq allTrans = «FOREACH getPseudostates()  AS pseudostate SEPARATOR ",  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  				«IF this.getTransitions().select(e|e.isBasicCompound()).size > 0-»,«ENDIF-»
				«FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR ", "-»ctr«transition.getId()-»«ENDFOREACH-»
 				.

 				
***/// A state machine consits of Vertices Defaultsstatesfunction ShallowDefaultstatesfunction DeepDefaultstatesfunction EntryActionsfunction ExitActionsFunction Transitions 
  op SMINT : -> StateMachine .
  ***// ToDo: add entry/exit actions//
  eq SMINT = (SM allVerts allDefs allSHDefs allDHDefs (empty).EntryActions (empty).ExitActions allTrans) .

endfm

«REM» state machine definition ends here, following the Eclipse interface module referenced by maude core step sem «ENDREM»

«REM»
load «((String)(GLOBALVAR maudebasecode))»STEPSEM

mod INIT is
	including STEPSEM .
	including SATISFACTION .
	including LTL .
	including MODEL-CHECKER .
	including LTL-SIMPLIFIER .
	
	
	vars msst mastate : MState .
	vars V V2 : Verts .
	var ac ac2 : Actions .
	var T : Transitions .
	var ES : EventSS .
	var mode : String .
	vars HC : HistoryConfs .
	
	subsort MState < State .
	
	op aCf : Actions -> Prop .
	op inC : Verts -> Prop .
	eq maState mode ($stableC V HC) ES |= inC(V2) = (prettyVerts V2) subset V  .
	eq maState mode ($unstableC V HC T ac) ES |= aCf(ac2) = actionConflict par (ac ac2) .
	eq maState mode ($unstableC V HC T ac) ES |= aCf(nil) = actionConflict ac .
	
	op isDone_ : MState -> Bool .
	eq isDone (maState mode ($doneC V HC) empty) = true .
	eq isDone msst = false [owise] .
endm

***(
set break on .
break select finishedRTCESINT discardFSetESINT .
)***

***(
#####################################################
##          Interface     for     Eclipse          ##        
#####################################################
search (maState "UML" ($stableC prettyVerts(<Konfiguration>) prettyHc(<HistoryKonfiguration>)) <Events>) =>* mastate such that isDone mastate .

- <Konfiguration>: eine durch "," getrennte Menge von Regionen und States. Diese muss den Anforderungen im Standard entsprechen.
  z.B: Rroot, Csusp (aus Test.maude)
- <HistoryKonfiguration>: kann erstmal empty sein
- <Events>: eine durch "," getrennte Menge von Events die abgearbeitet werden soll

(Rroot = R-990928836 , Csusp = susp441237549)
search (maState "UML" ($stableC (prettyVerts (R-990928836 , susp441237549)) empty) res) =>* mastate such that isDone mastate .
multistep
search (maState "UML" ($stableC (prettyVerts (R-990928836 , susp441237549)) empty) (res, ee1)) =>* mastate such that isDone mastate .

search (maState "UML" ($stableC (prettyVerts (Rroot, Csusp)) empty) res) =>* mastate such that isDone mastate .

red modelCheck ((maState "UML" ($stableC (prettyVerts (R-108097269 , R1010334332, a-1833692673, c--1034807852)) empty) (ee1, ee2)), <> inC(b--181774032)) .
red modelCheck ((maState "UML" ($stableC (prettyVerts (R-108097269 , R1010334332, a-1833692673, c--1034807852)) empty) (ee1,ee2)), <> inC(d--961763712)) .
)***
«ENDREM»

	«ENDFILE»
«ENDDEFINE»


«REM» needed else branch - should not be taken but should not have any effect «ENDREM»
«DEFINE sm FOR PackageableElement»
«ENDDEFINE»

«REM» needed else branch - should not be taken but should not have any effect «ENDREM»
«DEFINE init FOR PackageableElement»
«ENDDEFINE»
