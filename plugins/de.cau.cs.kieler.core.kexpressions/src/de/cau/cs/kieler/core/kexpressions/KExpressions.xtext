grammar de.cau.cs.kieler.core.kexpressions.KExpressions with  de.cau.cs.kieler.core.annotations.text.Annotations

import "platform:/resource/de.cau.cs.kieler.core.kexpressions/model/kexpressions.ecore" 
import "platform:/resource/de.cau.cs.kieler.core.annotations/model/annotations.ecore" as annotations

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Root returns ecore::EObject:
    Expression
    | InterfaceDeclaration;

//Variable returns annotations::Annotatable:
//    (annotations += StringAnnotation)*;

// --------------------------
//
//   EXPRESSIONS
//
// --------------------------

Expression returns Expression:
	=> BooleanExpression
	| ValuedExpression
	;


// Example: not D and C or ?E = 42 or not (A and (B or C))
BooleanExpression returns Expression:
	OrExpression;


// Example: A or B, A and B and C, C and B or D and not E, A and B and C
OrExpression returns Expression:
	AndExpression ({OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=AndExpression)*;


// Example: A and B, not C and 42 <= ?D
AndExpression returns Expression:
	CompareOperation ({OperatorExpression.subExpressions+=current} operator=AndOperator subExpressions+=CompareOperation)*;


// Example: 42 <= ?A
CompareOperation returns Expression:
	=> NotOrValuedExpression ({OperatorExpression.subExpressions+=current} operator=CompareOperator subExpressions+=NotOrValuedExpression)
	| NotExpression
	;


// order IS IMPORTANT
NotOrValuedExpression returns Expression:
	=> ValuedExpression
	| NotExpression
    ;


// Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding
NotExpression returns Expression:
	{OperatorExpression} operator=NotOperator subExpressions+=(NotExpression)
    | AtomicExpression
    ;
  
    
// everything that evaluates to a primitive number value
ValuedExpression returns Expression:
	AddExpression;


// Example: 1 + 2
AddExpression returns Expression:
	SubExpression ({OperatorExpression.subExpressions+=current} operator=AddOperator subExpressions+=SubExpression)*;


// Example: varA - ?B
SubExpression returns Expression:
	MultExpression ({OperatorExpression.subExpressions+=current} operator=SubOperator subExpressions+=MultExpression)*;
//    ({OperatorExpression} subExpressions+=MultExpression (operator=SubOperator subExpressions+=MultExpression)+)
//	| ({OperatorExpression} subExpressions+=MultExpression subExpressions+=NIntValue)
//    | MultExpression;


// Example: 2 * 4
MultExpression returns Expression:
	DivExpression ({OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=DivExpression)*;


// Example: (2 / 4)
// note: division always has to have parantheses because the '/' sign is also used for trigger/effect delimiter
DivExpression returns Expression:
	ModExpression ({OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=ModExpression)?;
	

// Example: varA mod ?B
ModExpression returns Expression:
	NegExpression ({OperatorExpression.subExpressions+=current} operator=ModOperator subExpressions+=AtomicValuedExpression)?;


// Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding
NegExpression returns Expression:
	{OperatorExpression} operator=SubOperator subExpressions+=(NegExpression)
    | AtomicValuedExpression
    ;
  
    
AtomicExpression returns Expression:
    BooleanValue
    | ValuedObjectTestExpression
    | '(' BooleanExpression ')'
    | TextExpression
    ;


AtomicValuedExpression returns Expression:
    IntValue
    | FloatValue
//    | '(' DivExpression ')'
    | => '(' ValuedExpression ')'
    | AtomicExpression 
    ;


// Example: pre(pre(?A)), pre(pre(A)), ?A, A varX
ValuedObjectTestExpression returns Expression:
	{OperatorExpression} operator=PreOperator '('subExpressions+=ValuedObjectTestExpression')'
	| {OperatorExpression} operator=ValueTestOperator subExpressions+=ValuedObjectReference
	| ValuedObjectReference
	;


// Example: A, varB
ValuedObjectReference returns ValuedObjectReference:
	valuedObject=[ValuedObject|ID];


// Example: 'printf(...)'(C)
TextExpression returns TextExpression:
	code=HOSTCODE ("(" type=ID ")")?;


IntValue returns IntValue:
	value=INT;

//NIntValue returns IntValue:
//	value=NINT;


FloatValue returns FloatValue:
	value=FLOAT;


BooleanValue returns BooleanValue:
	value=BOOLEAN;


// data type rule allowing any kind of value to be accepted,
// e.g. as initialValues of valuedObjects
// used in Kits.xtext 
AnyType returns ecore::EString:
    BOOLEAN | INT | FLOAT | ID | STRING;


// --------------------------
//
//  Interface Declarations
//
// --------------------------

InterfaceDeclaration:
	InterfaceSignalDecl 
	| InterfaceVariableDecl
;

ISignal returns ISignal:
	name=ID (channelDescr=ChannelDescription)?;

InterfaceSignalDecl:
	{Input} "input" signals+=ISignal ("," signals+=ISignal)* ";" |
	{Output} "output" signals+=ISignal ("," signals+=ISignal)* ";" |
	{InputOutput} "inputoutput" signals+=ISignal ("," signals+=ISignal)* ";" |
	{Return} "return" signals+=ISignal ("," signals+=ISignal)* ";";

ChannelDescription:
	(":" type=TypeIdentifier)
	| ("(" type=TypeIdentifier ")")
	| (":=" expression=Expression ":" type=TypeIdentifier);

// Variables
InterfaceVariableDecl:
	"var" (varDecls+=VariableDecl) ("," varDecls+=VariableDecl)*;
	
VariableDecl:
	(variables+=IVariable) ("," variables+=IVariable)* ":" type=TypeIdentifier;

IVariable:
	 name=ID (":=" expression=Expression)?;

// transform ID to hostcode
TypeIdentifier:
	type=ValueType 
	| typeID=ID
	| ("combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator);
	
	

// --------------------------
//
//  Terminals...
//
// --------------------------


enum CompareOperator returns OperatorType:
	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";

enum PreOperator returns OperatorType:
    PRE="pre";

enum OrOperator returns OperatorType:
	OR="or";

enum AndOperator returns OperatorType:
	AND="and";

enum NotOperator returns OperatorType:
	NOT="not";

enum AddOperator returns OperatorType:
	ADD="+";
	
enum SubOperator returns OperatorType:
	SUB="-";
	
enum MultOperator returns OperatorType:	
	MULT="*";

enum ModOperator returns OperatorType:	
	MOD="mod";

enum DivOperator returns OperatorType:	
	DIV="/";

enum ValueTestOperator returns OperatorType:
	VAL="?";


/*
   the following declarations are re-used in Actions.xtext, Interface.xtext, Kits.xtext 
*/
enum ValueType returns ValueType:
	PURE="pure" | BOOL="boolean" | UNSIGNED="unsigned"	| 
	INT="integer" | FLOAT="float" | DOUBLE="double" |
	STRING="string" | HOST="host";


enum CombineOperator returns CombineOperator:
	NONE="none" | ADD="+" | MULT="*" | MAX="max" |
	MIN="min" | OR="or" | AND="and" | HOST="host";


// custom terminal rule allowing to save transition label string as they are
terminal HOSTCODE returns ecore::EString: 
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'";