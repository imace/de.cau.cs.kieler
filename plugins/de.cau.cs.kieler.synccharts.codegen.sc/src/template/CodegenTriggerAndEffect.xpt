«REM»
	Template file for triggers and effects of transitions and actions. 
«ENDREM»

«IMPORT synccharts»
«IMPORT expressions»

«EXTENSION template::Helper»

«REM»
	Entry point for triggers. It will be distinguished if
	the ritgger is simple or complex. Then the effects will be generated.
«ENDREM»
«DEFINE trigger FOR Action-»
	«IF !(this.label == null)-»
		«IF !(this.trigger == null)-»
			«IF (this.trigger.metaType == ValuedObjectReference 
			     && ((ValuedObjectReference)this.trigger).valuedObject.metaType == Signal)-»
				«EXPAND simpleTrigger FOR this-»
			«ELSEIF (this.trigger.metaType == ComplexExpression)-»
				«EXPAND complexTrigger FOR this-»
			«ELSE-»
				/* error while generating code */
			«ENDIF-»
		«ELSE-»
			«EXPAND effects FOR this-»
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE simpleTrigger FOR Action-»
	if («EXPAND ifRequest FOR this-») {
		«EXPAND effects FOR this-»
		«EXPAND CodegenPriority::priorityReduction FOR this-»
	}
«ENDDEFINE»

«DEFINE complexTrigger FOR Action-»
	if («EXPAND ifRequest FOR this-») {
		«EXPAND effects FOR this-»
		«EXPAND stateAbortion FOR (Transition)this-»
	}
«ENDDEFINE»

«REM»
	This template distinguishes if the request is a boolean value, an expression or
	a signal reference. 
«ENDREM»
«DEFINE ifRequest FOR Action-»
	«IF (this.trigger.metaType == BooleanValue)-»
		«EXPAND getValue FOR this.trigger-»
	«ELSEIF this.trigger.metaType == OperatorExpression-»
		«EXPAND complexExpression FOR ((OperatorExpression)this.trigger)-»
	«ELSEIF this.trigger.metaType == ValuedObjectReference-»
		PRESENT(sig_«((ValuedObjectReference)this.trigger).valuedObject.name-»)
	«ELSE-»
		/* unknown if request */
	«ENDIF-»
«ENDDEFINE»

«REM»
	Emission of int values, bool values or pure signals. 
«ENDREM»
«DEFINE effects FOR Action-»
	«FOREACH this.effects AS effect-»
		«IF ((Emission)effect).signal.type == ValueType::INT-»
			«EXPAND valuedIntegerSignal FOR ((Emission)effect)-»
		«ELSEIF ((Emission)effect).signal.type == ValueType::BOOL-»
			«EXPAND valuedBooleanSignal FOR ((Emission)effect)-»
		«ELSE-»
			EMIT(sig_«((Emission)effect).signal.name-»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«REM»
	Valued integer signals with its combine functions 
«ENDREM»
«DEFINE valuedIntegerSignal FOR Emission-»
	«IF this.signal.combineOperator == CombineOperator::NONE-»
		EMITINT(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MULT-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMUL(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::ADD-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTADD(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MAX-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMAX(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MIN-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMIN(«EXPAND signalAndValue FOR this-»);
	«ENDIF-»
	«IF this.signal.combineOperator == CombineOperator::MULT || this.signal.combineOperator == CombineOperator::ADD || this.signal.combineOperator == CombineOperator::MAX || this.signal.combineOperator == CombineOperator::MIN-»
		} else {
			EMITINT(«EXPAND signalAndValue FOR this-»);
		}
	«ENDIF»
«ENDDEFINE»

«REM»
	Valued boolean signals with its combine functions 
«ENDREM»
«DEFINE valuedBooleanSignal FOR Emission-»
	«IF this.signal.combineOperator == CombineOperator::NONE-»
		EMITBOOL(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::AND-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITBOOLAND(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::OR-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITBOOLOR(«EXPAND signalAndValue FOR this-»);
	«ENDIF-»
	«IF this.signal.combineOperator == CombineOperator::AND || this.signal.combineOperator == CombineOperator::OR-»
		} else {
			EMITBOOL(«EXPAND signalAndValue FOR this-»);
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE signalAndValue FOR Emission-»
	«IF this.newValue.metaType == expressions::OperatorExpression-»
		sig_«this.signal.name», «EXPAND checkExpression FOR this.newValue-»
	«ELSEIF this.newValue.metaType == expressions::BooleanValue-»
		sig_«this.signal.name», «EXPAND getValue FOR this.newValue-»
	«ELSE-»
		sig_«this.signal.name», «((IntValue)this.newValue).value-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	For complex expressions we have to distinguish what kind of operator the expression has.
	The default case is <VAL> OP <VAL>.
«ENDREM»
«DEFINE complexExpression FOR OperatorExpression-»
	«IF this.operator == OperatorType::PRE-»
		«EXPAND preOperator FOR this.subExpressions.get(0)-»
	«ELSEIF this.operator == OperatorType::NOT-»
		«EXPAND syncChartsOpToCOp FOR this.operator-»
		«EXPAND checkExpression FOR this.subExpressions.get(0)-»
	«ELSEIF this.operator == OperatorType::VAL-»
		«IF (this.eContainer.metaType == expressions::OperatorExpression)-»
			VALPRE(sig_«((ValuedObjectReference)this.subExpressions.get(0)).valuedObject.name-»)
		«ELSE-»
			VAL(sig_«((ValuedObjectReference)this.subExpressions.get(0)).valuedObject.name-»)
		«ENDIF-»
	«ELSE-»
		«EXPAND checkExpression FOR this.subExpressions.get(0)-»
		«EXPAND syncChartsOpToCOp FOR this.operator-»
		«EXPAND checkExpression FOR this.subExpressions.get(1)-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	simple signal reference 
«ENDREM»
«DEFINE valuedObjectReference FOR ValuedObjectReference-»
	PRESENT(sig_«this.valuedObject.name»)
«ENDDEFINE»

«REM»
	Pre operator for signal references or complex types. 
«ENDREM»
«DEFINE preOperator FOR Expression-»
	«IF this.metaType == OperatorExpression-»
		«EXPAND complexExpression FOR (OperatorExpression) this-»
	«ELSEIF this.metaType == ValuedObjectReference-»
		PRESENTPRE(sig_«((ValuedObjectReference)this).valuedObject.name-»)
	«ELSE»
		«EXPAND getValue FOR this-»
	«ENDIF»
«ENDDEFINE»

«REM»
	This checks if an expression is weather a complex expression or a signal reference. 
«ENDREM»
«DEFINE checkExpression FOR Expression-»
	«IF this.metaType == OperatorExpression-»
		(«EXPAND complexExpression FOR (OperatorExpression)this-»)
	«ELSEIF this.metaType == ValuedObjectReference-»
		«EXPAND valuedObjectReference FOR (ValuedObjectReference)this-»
	«ELSE»
		«EXPAND getValue FOR this-»
	«ENDIF»
«ENDDEFINE»

«REM»
	Returns the value of valued signals.
«ENDREM»
«DEFINE getValue FOR Expression-»
	/* metatype:  «((Value)this).metaType» */
	«IF ((Value)this).metaType == expressions::IntValue-»
		«((IntValue)this).value-»
	«ELSEIF ((Value)this).metaType == expressions::FloatValue-»
		«((FloatValue)this).value-»
	«ELSEIF((Value)this).metaType == expressions::FloatValue-»
		«IF ((BooleanValue)this).value-»
			1
		«ELSE-»
			0
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	Returns the C operator depending on the operator in the SyncCharts metamodel
«ENDREM»
«DEFINE syncChartsOpToCOp FOR OperatorType-»
	«IF this == OperatorType::AND-»
		&&
	«ELSEIF this == OperatorType::OR»
		||
	«ELSEIF this == OperatorType::NOT»
		!
	«ELSEIF this == OperatorType::EQ»
		==
	«ELSEIF this == OperatorType::NE»
		!=
	«ELSEIF this == OperatorType::LT»
		<
	«ELSEIF this == OperatorType::GT»
		>
	«ELSEIF this == OperatorType::LEQ»
		<=
	«ELSEIF this == OperatorType::GEQ»
		>=
	«ELSEIF this == OperatorType::ADD»
		+
	«ELSEIF this == OperatorType::SUB»
		-
	«ELSEIF this == OperatorType::MULT»
		*
	«ELSEIF this == OperatorType::DIV»
		/
	«ELSEIF this == OperatorType::MOD»
		%
	«ENDIF-»
«ENDDEFINE»

«REM»
	This template handles the differend cases of aborting a state.
«ENDREM»
«DEFINE stateAbortion FOR Transition-»
	«IF this.type != TransitionType::NORMALTERMINATION-»
		«IF !(this.sourceState.regions.isEmpty)-»
			«IF this.type != TransitionType::STRONGABORT-»
				PRIO(«getRealThreadPriority(this.targetState)»);
			«ENDIF-»
			ABORT;
			«IF this.type == TransitionType::STRONGABORT-»
				PRIO(«getRealThreadPriority(this.targetState)»);
			«ENDIF-»
		«ENDIF-»
		«EXPAND CodegenPriority::priorityReduction FOR this-»
	«ENDIF-»
	«EXPAND transitionWithoutTriggersAndEffects FOR this-»
«ENDDEFINE»

«DEFINE transitionWithoutTriggersAndEffects FOR Transition-»
	GOTO(L_«getStateNameByFlag(this.targetState, 3)»);
«ENDDEFINE»

«REM»
	Templates for delayed triggers 
«ENDREM»
«DEFINE delayedTrigger FOR Transition-»
	«IF this.delay > 1-»
		if (count_«getStateNameByFlag(this.targetState, 3)» < «this.delay») {
			GOTO(L_afterCount_«getStateNameByFlag(this.targetState, 3)»);
		}
	«ENDIF-»
«ENDDEFINE»

«DEFINE delayedTriggerLabel FOR Transition-»
	«IF this.delay > 1-»
		L_afterCount_«getStateNameByFlag(this.targetState, 3)»:
		count_«getStateNameByFlag(this.targetState, 3)»++;
	«ENDIF-»
«ENDDEFINE»