«IMPORT synccharts»

«EXTENSION template::Helper»

«DEFINE trigger FOR Action-»
	«IF !(this.triggersAndEffects == null)-»
		«IF !(this.trigger == null)-»
			«IF (this.trigger.metaType == SignalReference)-»
				«EXPAND simpleTrigger FOR this-»
			«ELSE-»
				«EXPAND complexTrigger FOR this-»
			«ENDIF-»
		«ELSE-»
			«EXPAND effects FOR this-»
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE simpleTrigger FOR Action-»
	«EXPAND CodegenMisc::detectLocalSignal FOR ((SignalReference)this.trigger).signal-»
	if (PRESENT(sig_«((SignalReference)this.trigger).signal.name-»)){
		«EXPAND effects FOR this-»
		«EXPAND CodegenPriority::priorityReduction FOR (Transition)this.eRootContainer-»
	}
«ENDDEFINE»

«DEFINE complexTrigger FOR Action-»
	if («EXPAND complexExpression FOR ((ComplexExpression)this.trigger)») {
		«EXPAND effects FOR this-»
		«EXPAND stateAbortion FOR (Transition)this-»
	}
«ENDDEFINE»

«DEFINE effects FOR Action-»
	«FOREACH this.effects AS effect-»
		«IF ((Emission)effect).signal.type == ValueType::INTEGER-»
			«EXPAND valuedIntegerSignal FOR ((Emission)effect)-»
		«ELSEIF ((Emission)effect).signal.type == ValueType::BOOL-»
			«EXPAND valuedBooleanSignal FOR ((Emission)effect)-»
		«ELSE-»
			EMIT(sig_«((Emission)effect).signal.name-»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE valuedIntegerSignal FOR Emission-»
	«IF this.signal.combineOperator == CombineOperator::NONE-»
		EMITINT(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MULT-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMUL(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::ADD-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTADD(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MAX-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMAX(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MIN-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMIN(«EXPAND signalAndValue FOR this-»);
	«ENDIF-»
	«IF this.signal.combineOperator == CombineOperator::MULT || this.signal.combineOperator == CombineOperator::ADD || this.signal.combineOperator == CombineOperator::MAX || this.signal.combineOperator == CombineOperator::MIN-»
		} else {
			EMITINT(«EXPAND signalAndValue FOR this-»);
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE valuedBooleanSignal FOR Emission-»
	«IF this.signal.combineOperator == CombineOperator::NONE-»
		EMITBOOL(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::AND-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITBOOLAND(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::OR-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITBOOLOR(«EXPAND signalAndValue FOR this-»);
	«ENDIF-»
	«IF this.signal.combineOperator == CombineOperator::AND || this.signal.combineOperator == CombineOperator::OR-»
		} else {
			EMITBOOL(«EXPAND signalAndValue FOR this-»);
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE signalAndValue FOR Emission-»
	sig_«this.signal.name», «((IntValue)this.newValue).value-»
«ENDDEFINE»

«DEFINE operatorEQ FOR ComplexExpression-»
	«EXPAND complexExpression FOR ((ComplexExpression)this.subExpressions.get(0))-» == «((IntValue)this.subExpressions.get(1)).value»
«ENDDEFINE»

«DEFINE complexExpression FOR ComplexExpression-»
	«IF this.operator == OperatorType::EQ-»
		«EXPAND operatorEQ FOR this-»
	«ENDIF-»
	«IF this.operator == OperatorType::AND || this.operator == OperatorType::OR-»
		«EXPAND signalOrComplex FOR this.subExpressions.get(0)-»
		«EXPAND syncChartsOpToCOp FOR this.operator-»
		«EXPAND signalOrComplex FOR this.subExpressions.get(1)-»
	«ENDIF»
	«IF this.operator == OperatorType::NOT-»
		«EXPAND syncChartsOpToCOp FOR this.operator-»
		«EXPAND signalOrComplex FOR this.subExpressions.get(0)-»
	«ENDIF»
	«IF this.operator == OperatorType::VAL-»
		VAL(sig_«((SignalReference)this.subExpressions.get(0)).signal.name-»)
	«ENDIF-»
«ENDDEFINE»

«DEFINE signalReference FOR SignalReference-»
	PRESENT(sig_«this.signal.name»)
«ENDDEFINE»

«DEFINE signalOrComplex FOR Expression-»
	«IF this.metaType == ComplexExpression-»
			(«EXPAND complexExpression FOR (ComplexExpression)this-»)
		«ELSE»
			«EXPAND signalReference FOR (SignalReference)this-»
		«ENDIF»
«ENDDEFINE»

«DEFINE syncChartsOpToCOp FOR OperatorType-»
	«IF this == OperatorType::AND-»
		&&
	«ELSEIF this == OperatorType::OR»
		||
	«ELSEIF this == OperatorType::NOT»
		!
	«ELSEIF this == OperatorType::EQ»
		==
	«ELSEIF this == OperatorType::LT»
		<
	«ELSEIF this == OperatorType::GT»
		>
	«ELSEIF this == OperatorType::LEQ»
		<=
	«ELSEIF this == OperatorType::GEQ»
		>=
	«ENDIF-»
«ENDDEFINE»

«DEFINE stateAbortion FOR Transition-»
	«IF this.type != TransitionType::NORMALTERMINATION-»
		«IF !(this.sourceState.regions.isEmpty)-»
			«IF this.type != TransitionType::STRONGABORT-»
				PRIO(«getRealThreadPriority(this.targetState)»);
			«ENDIF-»
			ABORT;
			«IF this.type == TransitionType::STRONGABORT-»
				PRIO(«getRealThreadPriority(this.targetState)»);
			«ENDIF-»
		«ENDIF-»
		«EXPAND CodegenPriority::priorityReduction FOR this-»
	«ENDIF-»
	«EXPAND transitionWithoutTriggersAndEffects FOR this-»
«ENDDEFINE»

«DEFINE transitionWithoutTriggersAndEffects FOR Transition-»
	GOTO(L_«getStateNameByFlag(this.targetState, 3)»);
«ENDDEFINE»