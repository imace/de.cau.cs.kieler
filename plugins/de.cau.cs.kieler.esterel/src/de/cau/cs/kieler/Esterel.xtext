grammar de.cau.cs.kieler.Esterel with org.eclipse.xtext.common.Terminals

generate esterel "http://www.cau.de/cs/kieler/Esterel"

// TODO : replace ID with proper build strings		

// ==============================================
// ===              B.5 Modules               ===
// ==============================================

//	help function to allow multiple modules in one document
Programm hidden(Esterel_SL_Comment, Esterel_ML_Comment, WS):
	module+=MainModule (module+=Module)*;
	
MainModule:
	"module" name=ID ":" (modInt=ModuleInterface)? modBody=ModuleBody EndModule;	

Module:
	"module" name=ID ":" (modInt=ModuleInterface)? modBody=ModuleBody EndModule;

EndModule:
	"end" "module"
	|	"."; //deprecated

// help function to clearly divide a Module into interface and body	
ModuleBody:
	statement+=Statement;

ModuleInterface:
	(intSignalDecl+=SignalDecl
	|	intTypeDecl+=TypeDecl
	|	intSensorDecl+=SensorDecl
	|	intConstantDecl+=ConstantDecl
	|	intRelationDecl+=RelationDecl
	|	intFunctionDecl+=FunctionDecl)+;

// ----------------------------------------------
//            Interface Declarations
// ----------------------------------------------
	
// ==> Signals and Sensors <==

SignalDecl:
	{Input} "input" signal+=Signal ("," signal+=Signal)* ";"
	|	{Output} "output" signal+=Signal ("," signal+=Signal)* ";"
	|	{InputOutput} "inputoutput" signal+=Signal ("," signal+=Signal)* ";"
	|	{Return} "return" signal+=Signal ("," signal+=Signal)* ";";

	
//ChannelType:
//	//make reference to declared types
	//Problem: Need reference OR BaseType
	
SensorDecl:
	"sensor" sensor+=Sensor ("," sensor+=Sensor)* ";";
	
// ==> Relations
RelationDecl:
	"relation" relation+=Relation ("," relation+=Relation)* ";";
	
Relation:
	RelationImplication|RelationIncompatibility;

RelationImplication returns Relation:
	first=[Signal] type="=>" second=[Signal];
	
RelationIncompatibility returns Relation:
	incomp+=[Signal] type="#" incomp+=[Signal] ("#" incomp+=[Signal])*;

// ==> Types

TypeDecl:
	"type" type+=Type ("," type+=Type)* ";"; 

Type:
	name=ID;

	
// ==> Constants
ConstantDecl:
	"constant" constant+=OneTypeConstantDecl ("," constant+=OneTypeConstantDecl)* ";";

OneTypeConstantDecl:
	constant+=Constant ("," constant+=Constant)* ":" (type=ID | type=BaseType);
	
Constant:
	name=ID ("=" value=ConstantValue)?;

ConstantValue:
	ID
	| Number
	| INT
	| STRING
	| Float
	| Boolean;
	
// ==> Functions

FunctionDecl:
	"function" function+=Function ("," function+=Function)* ";";
	
Function:
	name=ID "(" (idList+=(ID|BaseType) ("," idList+=(ID|BaseType))*)? ")" ":" (type=ID | type=BaseType);

// ==============================================
// ===            B.4 Statements              ===
// ==============================================

Statement:
	Sequence ( {Parallel.left=current} "||" right=Sequence)*;
	
AtomicStatement returns Statement:
	Abort 
	|	Assignment
	|	Await
	|	Block
	|	Do
	|	Emit
	|	EveryDo
	|	Exit
	|	Halt
	|	IfTest
	|	LocalSignalDecl
	|	Loop
	|	Nothing
	|	Pause
	|	Present
	|	Repeat
	|	Run
	|	Suspend
	|	Sustain
	|	Trap
	|	Variable
	|	WeakAbort;
	
// --> B.4.1 Control Flow Operators <--	
	
Sequence returns Statement:
	AtomicStatement ({Sequence.left=current} ";" right=AtomicStatement)* ";"?;
	
Block:
	"["statement=Statement"]";
	
Assignment:
	variable=ID ":=" expr=DataExpr;

// --> B.4.2 abort: Strong Preemption
Abort:
	"abort" statement=Statement "when" body=AbortBody;

AbortBody:
	AbortInstance | AbortCase;
		
AbortEnd:
	"end" "abort"?;

AbortInstance:
	delay=DelayExpr ("do" statement=Statement end=AbortEnd)?; 
	
AbortCase:
	cases+=AbortCaseSingle (cases+=AbortCaseSingle)* end=AbortEnd;
	
AbortCaseSingle:
	"case" delay=DelayExpr ("do" statement=Statement)?;
	
// --> B.4.3 await: Strong Preemption
Await:
	"await" body=AwaitBody;

AwaitBody:
	AwaitInstance | AwaitCase;	
	
AwaitEnd:
	"end" "await"?;

AwaitInstance:
	DelayExpr ("do" statement=Statement end=AwaitEnd)?; 
	
AwaitCase:
	cases+=AbortCaseSingle (cases+=AbortCaseSingle)* end=AwaitEnd;
	
// --> B.4.5 do-upto: Conditional Iteration (deprecated)
// --> B.4.6 do-watching: Strong Preemption (deprecated)
Do:
	"do" statement=Statement (end=DoUpto | end=DoWatching);
	
DoUpto:
	"upto" expr=DelayExpr;

DoWatching:
	"watching" delay=DelayExpr (end=DoWatchingEnd)?;

DoWatchingEnd:
	"timeout" statement=Statement "end" "timeout"?;
	
// --> B.4.7 emit: Signal Emission <--
	
// a help function to force an "emit" object into the model
Emit: 
	"emit" signal=[Signal] ("(" expr=DataExpr")")?; //("(" expr=DataExpr ")")?;
	
// --> B.4.8 every-do: Conditional Iteration
EveryDo:
	"every" delay=DelayExpr "do" statement=Statement "end" "every"?;

// --> B.4.10 exit: Trap Exit
Exit:
	"exit" trap=[Trap] ("(" dataExpr=DataExpr ")")?;
	
// --> B.4.11 halt: Wait Forever
Halt:
	"halt" {Halt};
	
// --> B.4.12: if: Conditional for Data
IfTest:
	"if" expr=DataExpr (then=ThenPart)? 
	(elseIf=ElsIfPart)? (else=ElsePart)? 
	"end" "if"?;
	
ElsIfPart:
	elsif+=ElsIf (elsif+=ElsIf)*;
	
ElsIf:
	"elsif" expr=DataExpr (then=ThenPart)?;
	
ThenPart:
	"then" statement=Statement;

ElsePart:
	"else" statement=Statement;
	
// --> B.4.13 loop: Infinite Loop
// --> B.4.14 loop-each: Condition Iteration
Loop:
	"loop" body=LoopBody (EndLoop | end=LoopEach);

EndLoop:
	"end" "loop"?;
	
LoopEach:
	"each" LoopDelay;
	
LoopDelay:
	delay=DelayExpr;
	 
LoopBody:
	statement=Statement;
	
// --> B.4.15 nothing: No Operation
Nothing:
	"nothing" {Nothing};

// --> B.4.16 pause: Unit Delay
Pause: 
	"pause" {Pause};
	
// --> B.4.17 present: Conditional for Signals

Present:
	"present" body=PresentBody
	(elsePart=ElsePart)? "end" "present"?;

PresentBody:
	PresentEventBody
	| PresentCaseList;
	
PresentEventBody:
	event=PresentEvent (thenPart=ThenPart)?;

PresentCaseList:
	case+=PresentCase (case+=PresentCase)*;

PresentCase:
	"case" event=PresentEvent ("do" statement=Statement)?;

PresentEvent:
	expression=SigExpr
	|	"[" expression=SigExpr "]";

// --> B.4.18 repeat: Iterate a Fixed Number of Times
Repeat:
	(positive?="positive")? "repeat" dataExpr=DataExpr "times" statement=Statement "end" "repeat"?;
// --> B.4.19 run: Module Instantiation

Run:
	"run" module=ModuleRenaming ("[" list=RenamingList"]")?
	|	"copymodule" module=ModuleRenaming ("[" list=RenamingList"]")?; //deprecated

ModuleRenaming:
	module=[Module] (renamed?="/" newName=ID)?;
	
RenamingList:
	list+=Renaming (";" list+=Renaming)*;
	
Renaming:
	"type" renaming+=TypeRenaming ("," renaming+=TypeRenaming)*
	|	"constant" renaming+=ConstantRenaming ("," renaming+=ConstantRenaming)*
	|	"function" renaming+=FunctionRenaming ("," renaming+=FunctionRenaming)* 
	|	"signal" renaming+=SignalRenaming ("," renaming+=SignalRenaming)*;
	
TypeRenaming:
	oldName=[Type] "/" newName=ID;
	
ConstantRenaming:
	value=ConstantValue "/" newName=ID;
	
FunctionRenaming:
	oldName=[Function] "/" newName=ID;

SignalRenaming:
	oldName=[Signal] "/" newName=ID;
	
// --> B.4.20 signal: Local Signal Declaration <--
	
LocalSignalDecl:
	"signal" signalList=LocalSignalList "in" statement=Statement "end" "signal"?;
	
LocalSignalList:
	{LocalSignal} signal+=Signal 
	("," signal+=Signal)*;
	
// --> B.4.21 suspend: Preemption with State Freeze
Suspend:
	"suspend" statement=Statement "when" delay=DelayExpr;

// --> B.4.22 sustain: Emit a Signal Indefinitely
Sustain:
	"sustain" signal=[Signal] ("(" dataExpr=DataExpr ")")?;
	
// --> B.4.23 trap: TrapDeclaration and Handling
Trap:
	"trap" trapDeclList=TrapDeclList "in" statement=Statement (trapHandlerList=TrapHandlerList)? "end" "trap"?;

TrapDeclList:
	trapDecl+=TrapDecl ("," trapDecl+=TrapDecl)*;
	
TrapDecl:
	name=ID (channelDesc=ChannelDescription)?;
	
TrapHandlerList:
	trapHandler+=TrapHandler (trapHandler+=TrapHandler)*;
	
TrapHandler:
	"handle" trapExpr=TrapExpr "do" statement=Statement;
	
// --> B.4.24 var: Local Variable Declaration
Variable:
	"var" varDecl=VariableDecl "in" statement=Statement "end" "var"?;

VariableDecl:
	varList=VariableList ":" (type=ID | type=BaseType)
	({VariableDecl.left=current}"," varList=VariableList ":" (type=ID | type=BaseType))*;
	
VariableList:
	variable=ID (":=" expression=DataExpr)? 
	({VariableList.left=current} "," variable=ID (":=" expression=DataExpr)?)*;

// --> B.4.25 weak abort: Weak Preemption
WeakAbort:
	"weak" "abort" statement=Statement "when" weakAbortBody=WeakAbortBody;
	
WeakAbortBody:
	WeakAbortInstance | WeakAbortCase;
		
WeakAbortEnd:
	"end" ("weak"? "abort")?;

WeakAbortInstance:
	delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?; 
	
WeakAbortCase:
	cases+=AbortCaseSingle (cases+=AbortCaseSingle)* end=WeakAbortEnd;


// ==============================================
// ===            B.3 Expressions             ===
// ==============================================

// --> B.3.1 Data Expressions
DataExpr:
	op=DataOp expr=DataExpr
	| (expr=DataUnaryExpr ({DataExpr.left=current}op=DataOp expr=DataExpr)?);

DataUnaryExpr:
	ID
	| Float
	| Boolean
	| INT
	| STRING
	| "(" DataExpr ")"
	| "?" signal=[Signal]
	| "pre" "(" "?" signal=[Signal] ")"
	| "??" trap=[Trap]
	| function=[Function] "(" expression+=DataExpr ("," expression+=DataExpr)* ")";
		
DataOp:
	"and"
	|	"or"
	|	"not"
	|	"<"
	|	">"
	|	"<="
	|	">="
	|	"<>"
	|	"="
	|	"+"
	|	"-"
	|	"*"
	|	"/"
	|	"mod";	

// --> B.3.3 Signal Expressions <--
// --> B.3.5 Trap Expressions <--
TrapExpr:
	SigExpr;
	
SigExpr:
	andExpr+=SigExprAND ("or" andExpr+=SigExprAND)*;
	
SigExprAND:
	unaExpr+=SigExprUnary ("and" unaExpr+=SigExprUnary)*;

SigExprUnary:
	expr=ID
	|	"(" sigExpr=SigExpr ")"
	|	"not" sigExpr=SigExprUnary;
	
// --> B.3.4 Delay Expressions <--
DelayExpr:
	event=DelayEvent
	|	(expr=DataExpr event=DelayEvent);
	
DelayEvent:
	signal=[Signal]
	|	"pre" "(" SigExpr ")"
	|	"[" SigExpr"]";
	


	
// ==============================================
// === B.2 Namespaces and Predefined Objects  ===
// ==============================================

// ==> Signals <==
ChannelDescription:
	(":" (type=ID | type=BaseType))
	|	("(" (type=ID | type=BaseType) ")")
	|	(":=" dataExpr=DataExpr ":" (type=ID | type=BaseType));
	
Signal:
	name=ID (channel=ChannelDescription)?;

Tick:
	"tick" {Tick};

	
Sensor:
	(name=ID ":" (type=ID | type=BaseType))
	|	(name=ID "(" (type=ID | type=BaseType) ")");


terminal Float: ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
terminal Boolean : "true" | "false";
terminal BaseType: 	"boolean" | "integer" | "float" | "double" | "string";
terminal Esterel_SL_Comment: '%' !('\n'|'\r')* ('\r'? '\n')?;
terminal Esterel_ML_Comment: ('%''{') -> ('}''%');
terminal Number: ('+'|'-') ' '? INT;
