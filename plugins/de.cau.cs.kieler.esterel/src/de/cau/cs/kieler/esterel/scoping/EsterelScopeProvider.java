/*
 * generated by Xtext
 */
package de.cau.cs.kieler.esterel.scoping;

import java.util.ArrayList;
import java.util.Collections;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.cau.cs.kieler.esterel.esterel.DataCurrent;
import de.cau.cs.kieler.esterel.esterel.DataFunction;
import de.cau.cs.kieler.esterel.esterel.DataPre;
import de.cau.cs.kieler.esterel.esterel.DataTrap;
import de.cau.cs.kieler.esterel.esterel.DelayEvent;
import de.cau.cs.kieler.esterel.esterel.Emit;
import de.cau.cs.kieler.esterel.esterel.Exit;
import de.cau.cs.kieler.esterel.esterel.Function;
import de.cau.cs.kieler.esterel.esterel.FunctionDecl;
import de.cau.cs.kieler.esterel.esterel.FunctionRenaming;
import de.cau.cs.kieler.esterel.esterel.LocalSignal;
import de.cau.cs.kieler.esterel.esterel.LocalSignalDecl;
import de.cau.cs.kieler.esterel.esterel.LocalSignalList;
import de.cau.cs.kieler.esterel.esterel.Module;
import de.cau.cs.kieler.esterel.esterel.ModuleBody;
import de.cau.cs.kieler.esterel.esterel.ModuleInterface;
import de.cau.cs.kieler.esterel.esterel.Procedure;
import de.cau.cs.kieler.esterel.esterel.ProcedureDecl;
import de.cau.cs.kieler.esterel.esterel.ProcedureRenaming;
import de.cau.cs.kieler.esterel.esterel.Program;
import de.cau.cs.kieler.esterel.esterel.RelationImplication;
import de.cau.cs.kieler.esterel.esterel.RelationIncompatibility;
import de.cau.cs.kieler.esterel.esterel.Run;
import de.cau.cs.kieler.esterel.esterel.Signal;
import de.cau.cs.kieler.esterel.esterel.SignalDecl;
import de.cau.cs.kieler.esterel.esterel.SignalRenaming;
import de.cau.cs.kieler.esterel.esterel.Sustain;
import de.cau.cs.kieler.esterel.esterel.Trap;
import de.cau.cs.kieler.esterel.esterel.TrapDecl;
import de.cau.cs.kieler.esterel.esterel.Type;
import de.cau.cs.kieler.esterel.esterel.TypeDecl;
import de.cau.cs.kieler.esterel.esterel.TypeRenaming;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class EsterelScopeProvider extends AbstractDeclarativeScopeProvider {

	/* ************************************************************************
	 * Scopes for references in one module
	 * ************************************************************************
	 */

	IScope scope_RelationImplication_first(RelationImplication context,
			EReference ref) {
		return new SimpleScope(getInterfaceSignals(context));

	}

	IScope scope_RelationImplication_second(RelationImplication context,
			EReference ref) {
		return new SimpleScope(getInterfaceSignals(context));

	}

	IScope scope_RelationIncompatibility_incomp(
			RelationIncompatibility context, EReference ref) {
		return new SimpleScope(getInterfaceSignals(context));

	}

	IScope scope_Emit_signal(Emit context, EReference ref) {
		return new SimpleScope(getAllSignals(context));

	}

	IScope scope_Sustain_signal(Sustain context, EReference ref) {
		return new SimpleScope(getAllSignals(context));

	}

	IScope scope_DataCurrent_signal(DataCurrent context, EReference ref) {
		return new SimpleScope(getAllSignals(context));

	}

	IScope scope_DataPre_signal(DataPre context, EReference ref) {
		return new SimpleScope(getAllSignals(context));

	}

	IScope scope_DelayEvent_signal(DelayEvent context, EReference ref) {
		return new SimpleScope(getAllSignals(context));

	}

	private ArrayList<IEObjectDescription> getInterfaceSignals(EObject context) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		while (!(parent instanceof ModuleInterface)) {
			parent = parent.eContainer();
		}
		EList<SignalDecl> intSignalDecl = ((ModuleInterface) parent)
				.getIntSignalDecl();
		if (!(intSignalDecl.isEmpty())) {
			for (SignalDecl sigDecl : intSignalDecl) {
				EList<Signal> sigList = sigDecl.getSignal();
				for (Signal sig : sigList) {
					scopeElems.add(new EObjectDescription(sig.getName(), sig,
							Collections.EMPTY_MAP));
				}
			}
		}
		return scopeElems;
	}

	// Gets all Signals (local and global) belonging to the scope of context
	private ArrayList<IEObjectDescription> getAllSignals(EObject context) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		// Go up in the Structure until Module/MainModule
		while (!(parent instanceof ModuleBody)) {
			// Get the local signals into the scope
			if (parent instanceof LocalSignalDecl) {
				LocalSignalList localSigList = ((LocalSignalDecl) parent)
						.getSignalList();
				EList<Signal> signals = ((LocalSignal) localSigList)
						.getSignal();
				for (Signal sig : signals) {
					scopeElems.add(new EObjectDescription(sig.getName(), sig,
							Collections.EMPTY_MAP));
				}
			}
			parent = parent.eContainer();
		}
		if (parent instanceof ModuleBody) {
			parent = parent.eContainer();
		}
		// Get the Signals declared in this Module
		ModuleInterface modInt = null;
		if (parent instanceof Module) {
			modInt = ((Module) parent).getModInt();
		}
		EList<SignalDecl> intSignalDecl = modInt.getIntSignalDecl();
		if (!(intSignalDecl.isEmpty())) {
			for (SignalDecl sigDecl : intSignalDecl) {
				EList<Signal> sigList = sigDecl.getSignal();
				for (Signal sig : sigList) {
					scopeElems.add(new EObjectDescription(sig.getName(), sig,
							Collections.EMPTY_MAP));
				}
			}
		}
		return scopeElems;
	}

	IScope scope_Exit_trap(Exit context, EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		// find all Traps
		while (!(parent instanceof ModuleBody)) {
			if (parent instanceof Trap) {
				EList<TrapDecl> trapDecl = ((Trap) parent).getTrapDeclList()
						.getTrapDecl();
				// add Trap to the scope
				for (TrapDecl trap : trapDecl) {
					scopeElems.add(new EObjectDescription(trap.getName(), trap,
							Collections.EMPTY_MAP));
				}
			}
			parent = parent.eContainer();
		}
		return new SimpleScope(scopeElems);
	}

	IScope scope_DataTrap_trap(DataTrap context, EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		// find all Traps
		while (!(parent instanceof ModuleBody)) {
			if (parent instanceof Trap) {
				EList<TrapDecl> trapDecl = ((Trap) parent).getTrapDeclList()
						.getTrapDecl();
				// add Trap to the scope
				for (TrapDecl trap : trapDecl) {
					scopeElems.add(new EObjectDescription(trap.getName(), trap,
							Collections.EMPTY_MAP));
				}
			}
			parent = parent.eContainer();
		}
		return new SimpleScope(scopeElems);

	}

	IScope scope_DataFunction_function(DataFunction context, EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		// Go up in the Structure until Module/MainModule
		while (!(parent instanceof ModuleBody)) {
			parent = parent.eContainer();
		}
		if (parent instanceof ModuleBody) {
			parent = parent.eContainer();
		}
		// Get the Functions declared in this Module
		ModuleInterface modInt = null;
		if (parent instanceof Module) {
			modInt = ((Module) parent).getModInt();
		}
		EList<FunctionDecl> intFunctionDecl = modInt.getIntFunctionDecl();
		if (!(intFunctionDecl.isEmpty())) {
			for (FunctionDecl funDecl : intFunctionDecl) {
				EList<Function> funList = funDecl.getFunction();
				for (Function fun : funList) {
					scopeElems.add(new EObjectDescription(fun.getName(), fun,
							Collections.EMPTY_MAP));
				}
			}
		}
		return new SimpleScope(scopeElems);

	}

	/* ************************************************************************
	 * Scopes for renaming
	 * ************************************************************************
	 */

	IScope scope_SignalRenaming_oldName(SignalRenaming context, EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		ModuleInterface modInt = getModuleInterface(context);
		if (!(modInt.equals(null))) {
			EList<SignalDecl> intSignalDecl = modInt.getIntSignalDecl();
			if (!(intSignalDecl.isEmpty())) {
				for (SignalDecl sigDecl : intSignalDecl) {
					EList<Signal> sigList = sigDecl.getSignal();
					for (Signal sig : sigList) {
						scopeElems.add(new EObjectDescription(sig.getName(),
								sig, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);

	}

	IScope scope_SignalRenaming_newName(SignalRenaming context, EReference ref) {
		return new SimpleScope(getAllSignals(context));

	}

	IScope scope_TypeRenaming_oldName(TypeRenaming context, EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		ModuleInterface modInt = getModuleInterface(context);
		if (!(modInt.equals(null))) {
			EList<TypeDecl> intTypeDecl = modInt.getIntTypeDecl();
			if (!(intTypeDecl.isEmpty())) {
				for (TypeDecl typeDecl : intTypeDecl) {
					EList<Type> typeList = typeDecl.getType();
					for (Type type : typeList) {
						scopeElems.add(new EObjectDescription(type.getName(),
								type, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	IScope scope_TypeRenaming_newName(TypeRenaming context, EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		while (!(parent instanceof ModuleBody)) {
			parent = parent.eContainer();
		}
		if (parent instanceof ModuleBody) {
			parent = parent.eContainer();
		}
		ModuleInterface modInt = null;
		if (parent instanceof Module) {
			modInt = ((Module) parent).getModInt();
		}
		if (!(modInt.equals(null))) {
			EList<TypeDecl> intTypeDecl = modInt.getIntTypeDecl();
			if (!(intTypeDecl.isEmpty())) {
				for (TypeDecl typeDecl : intTypeDecl) {
					EList<Type> typeList = typeDecl.getType();
					for (Type type : typeList) {
						scopeElems.add(new EObjectDescription(type.getName(),
								type, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	IScope scope_FunctionRenaming_oldName(FunctionRenaming context,
			EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		ModuleInterface modInt = getModuleInterface(context);
		if (!(modInt.equals(null))) {
			EList<FunctionDecl> intFunDecl = modInt.getIntFunctionDecl();
			if (!(intFunDecl.isEmpty())) {
				for (FunctionDecl funDecl : intFunDecl) {
					EList<Function> funList = funDecl.getFunction();
					for (Function fun : funList) {
						scopeElems.add(new EObjectDescription(fun.getName(),
								fun, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	IScope scope_FunctionRenaming_newName(FunctionRenaming context,
			EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		while (!(parent instanceof ModuleBody)) {
			parent = parent.eContainer();
		}
		if (parent instanceof ModuleBody) {
			parent = parent.eContainer();
		}
		ModuleInterface modInt = null;
		if (parent instanceof Module) {
			modInt = ((Module) parent).getModInt();
		}
		if (!(modInt.equals(null))) {
			EList<FunctionDecl> intFunDecl = modInt.getIntFunctionDecl();
			if (!(intFunDecl.isEmpty())) {
				for (FunctionDecl funDecl : intFunDecl) {
					EList<Function> funList = funDecl.getFunction();
					for (Function fun : funList) {
						scopeElems.add(new EObjectDescription(fun.getName(),
								fun, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	IScope scope_ProcedureRenaming_oldName(ProcedureRenaming context,
			EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		ModuleInterface modInt = getModuleInterface(context);
		if (!(modInt.equals(null))) {
			EList<ProcedureDecl> intProcDecl = modInt.getIntProcedureDecl();
			if (!(intProcDecl.isEmpty())) {
				for (ProcedureDecl procDecl : intProcDecl) {
					EList<Procedure> procList = procDecl.getProcedure();
					for (Procedure proc : procList) {
						scopeElems.add(new EObjectDescription(proc.getName(),
								proc, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	IScope scope_ProcedureRenaming_newName(ProcedureRenaming context,
			EReference ref) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		EObject parent = context.eContainer();
		while (!(parent instanceof ModuleBody)) {
			parent = parent.eContainer();
		}
		if (parent instanceof ModuleBody) {
			parent = parent.eContainer();
		}
		ModuleInterface modInt = null;
		if (parent instanceof Module) {
			modInt = ((Module) parent).getModInt();
		}
		if (!(modInt.equals(null))) {
			EList<ProcedureDecl> intProcDecl = modInt.getIntProcedureDecl();
			if (!(intProcDecl.isEmpty())) {
				for (ProcedureDecl procDecl : intProcDecl) {
					EList<Procedure> procList = procDecl.getProcedure();
					for (Procedure proc : procList) {
						scopeElems.add(new EObjectDescription(proc.getName(),
								proc, Collections.EMPTY_MAP));
					}
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	/*
	 * Gets the ModuleInterface of the Module the reference in the Run-Object
	 * points to
	 */
	private ModuleInterface getModuleInterface(EObject context) {
		EObject parent = context.eContainer();
		// get the name of the module the reference points to
		while (!(parent instanceof Run)) {
			parent = parent.eContainer();
		}
		String moduleName = ((Run) parent).getModule().getModule().getName();
		// find the module the reference points to
		while (!(parent instanceof Program)) {
			parent = parent.eContainer();
		}
		EList<Module> moduleList = ((Program) parent).getModule();
		for (Module module : moduleList) {
			if (module.getName().equals(moduleName)) {
				return module.getModInt();
			}
		}
		return null;

	}

}
