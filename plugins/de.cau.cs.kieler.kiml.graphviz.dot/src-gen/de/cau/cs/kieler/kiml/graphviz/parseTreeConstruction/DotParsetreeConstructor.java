/*
* generated by Xtext
*/
package de.cau.cs.kieler.kiml.graphviz.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.kiml.graphviz.services.DotGrammarAccess;

import com.google.inject.Inject;

public class DotParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private DotGrammarAccess grammarAccess;
	
	@Override	
	public DotGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GraphvizModel_GraphsAssignment(this, this, 0, inst);
			case 1: return new Graph_Group(this, this, 1, inst);
			case 2: return new Statement_Group(this, this, 2, inst);
			case 3: return new EdgeStatement_Group(this, this, 3, inst);
			case 4: return new EdgeTarget_Group(this, this, 4, inst);
			case 5: return new NodeStatement_Group(this, this, 5, inst);
			case 6: return new AttributeStatement_Group(this, this, 6, inst);
			case 7: return new Subgraph_Group(this, this, 7, inst);
			case 8: return new AttributeList_Group(this, this, 8, inst);
			case 9: return new Attribute_Group(this, this, 9, inst);
			case 10: return new Node_Group(this, this, 10, inst);
			case 11: return new Port_Alternatives(this, this, 11, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule GraphvizModel ****************
 *
 * GraphvizModel:
 *   graphs+=Graph*;
 *
 **/

// graphs+=Graph*
protected class GraphvizModel_GraphsAssignment extends AssignmentToken  {
	
	public GraphvizModel_GraphsAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGraphvizModelAccess().getGraphsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Graph_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGraphvizModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("graphs",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("graphs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGraphRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGraphvizModelAccess().getGraphsGraphParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new GraphvizModel_GraphsAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule GraphvizModel ****************/


/************ begin Rule Graph ****************
 *
 * Graph:
 *   strict?="strict"? type=GraphType name=ID? "{" statements+=Statement* "}";
 *
 **/

// strict?="strict"? type=GraphType name=ID? "{" statements+=Statement* "}"
protected class Graph_Group extends GroupToken {
	
	public Graph_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGraphAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Graph_RightCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGraphRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// strict?="strict"?
protected class Graph_StrictAssignment_0 extends AssignmentToken  {
	
	public Graph_StrictAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGraphAccess().getStrictAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("strict",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("strict");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getGraphAccess().getStrictStrictKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// type=GraphType
protected class Graph_TypeAssignment_1 extends AssignmentToken  {
	
	public Graph_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGraphAccess().getTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Graph_StrictAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getGraphAccess().getTypeGraphTypeEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// name=ID?
protected class Graph_NameAssignment_2 extends AssignmentToken  {
	
	public Graph_NameAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGraphAccess().getNameAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Graph_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getGraphAccess().getNameIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class Graph_LeftCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Graph_LeftCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGraphAccess().getLeftCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Graph_NameAssignment_2(parent, this, 0, inst);
			case 1: return new Graph_TypeAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// statements+=Statement*
protected class Graph_StatementsAssignment_4 extends AssignmentToken  {
	
	public Graph_StatementsAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGraphAccess().getStatementsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("statements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("statements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGraphAccess().getStatementsStatementParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Graph_StatementsAssignment_4(parent, next, actIndex, consumed);
			case 1: return new Graph_LeftCurlyBracketKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Graph_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public Graph_RightCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGraphAccess().getRightCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Graph_StatementsAssignment_4(parent, this, 0, inst);
			case 1: return new Graph_LeftCurlyBracketKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Graph ****************/


/************ begin Rule Statement ****************
 *
 * Statement:
 *   (EdgeStatement|NodeStatement|AttributeStatement|Subgraph|name=DotID "=" value=
 *   DotID) ";"?;
 *
 **/

// (EdgeStatement|NodeStatement|AttributeStatement|Subgraph|name=DotID "=" value=
// DotID) ";"?
protected class Statement_Group extends GroupToken {
	
	public Statement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStatementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EdgeStatement|NodeStatement|AttributeStatement|Subgraph|name=DotID "=" value=DotID
protected class Statement_Alternatives_0 extends AlternativesToken {

	public Statement_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStatementAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_EdgeStatementParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new Statement_NodeStatementParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new Statement_AttributeStatementParserRuleCall_0_2(parent, this, 2, inst);
			case 3: return new Statement_SubgraphParserRuleCall_0_3(parent, this, 3, inst);
			case 4: return new Statement_Group_0_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}

// EdgeStatement
protected class Statement_EdgeStatementParserRuleCall_0_0 extends RuleCallToken {
	
	public Statement_EdgeStatementParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getEdgeStatementParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EdgeStatement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EdgeStatement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEdgeStatementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NodeStatement
protected class Statement_NodeStatementParserRuleCall_0_1 extends RuleCallToken {
	
	public Statement_NodeStatementParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getNodeStatementParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NodeStatement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NodeStatement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNodeStatementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// AttributeStatement
protected class Statement_AttributeStatementParserRuleCall_0_2 extends RuleCallToken {
	
	public Statement_AttributeStatementParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getAttributeStatementParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeStatement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AttributeStatement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeStatementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Subgraph
protected class Statement_SubgraphParserRuleCall_0_3 extends RuleCallToken {
	
	public Statement_SubgraphParserRuleCall_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getSubgraphParserRuleCall_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Subgraph_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSubgraphRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// name=DotID "=" value=DotID
protected class Statement_Group_0_4 extends GroupToken {
	
	public Statement_Group_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStatementAccess().getGroup_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_ValueAssignment_0_4_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=DotID
protected class Statement_NameAssignment_0_4_0 extends AssignmentToken  {
	
	public Statement_NameAssignment_0_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStatementAccess().getNameAssignment_0_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getStatementAccess().getNameDotIDParserRuleCall_0_4_0_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class Statement_EqualsSignKeyword_0_4_1 extends KeywordToken  {
	
	public Statement_EqualsSignKeyword_0_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStatementAccess().getEqualsSignKeyword_0_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_NameAssignment_0_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=DotID
protected class Statement_ValueAssignment_0_4_2 extends AssignmentToken  {
	
	public Statement_ValueAssignment_0_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStatementAccess().getValueAssignment_0_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_EqualsSignKeyword_0_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getStatementAccess().getValueDotIDParserRuleCall_0_4_2_0();
			return obj;
		}
		return null;
	}

}




/************ end Rule Statement ****************/


/************ begin Rule EdgeStatement ****************
 *
 * EdgeStatement:
 *   (sourceSubgraph=Subgraph|sourceNode=Node) edgeTargets+=EdgeTarget+ attributes=
 *   AttributeList?;
 *
 **/

// (sourceSubgraph=Subgraph|sourceNode=Node) edgeTargets+=EdgeTarget+ attributes=
// AttributeList?
protected class EdgeStatement_Group extends GroupToken {
	
	public EdgeStatement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEdgeStatementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EdgeStatement_AttributesAssignment_2(parent, this, 0, inst);
			case 1: return new EdgeStatement_EdgeTargetsAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEdgeStatementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// sourceSubgraph=Subgraph|sourceNode=Node
protected class EdgeStatement_Alternatives_0 extends AlternativesToken {

	public EdgeStatement_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEdgeStatementAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EdgeStatement_SourceSubgraphAssignment_0_0(parent, this, 0, inst);
			case 1: return new EdgeStatement_SourceNodeAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// sourceSubgraph=Subgraph
protected class EdgeStatement_SourceSubgraphAssignment_0_0 extends AssignmentToken  {
	
	public EdgeStatement_SourceSubgraphAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeStatementAccess().getSourceSubgraphAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("sourceSubgraph",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("sourceSubgraph");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSubgraphRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEdgeStatementAccess().getSourceSubgraphSubgraphParserRuleCall_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// sourceNode=Node
protected class EdgeStatement_SourceNodeAssignment_0_1 extends AssignmentToken  {
	
	public EdgeStatement_SourceNodeAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeStatementAccess().getSourceNodeAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("sourceNode",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("sourceNode");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEdgeStatementAccess().getSourceNodeNodeParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}


// edgeTargets+=EdgeTarget+
protected class EdgeStatement_EdgeTargetsAssignment_1 extends AssignmentToken  {
	
	public EdgeStatement_EdgeTargetsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeStatementAccess().getEdgeTargetsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EdgeTarget_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("edgeTargets",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("edgeTargets");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEdgeTargetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEdgeStatementAccess().getEdgeTargetsEdgeTargetParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EdgeStatement_EdgeTargetsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new EdgeStatement_Alternatives_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// attributes=AttributeList?
protected class EdgeStatement_AttributesAssignment_2 extends AssignmentToken  {
	
	public EdgeStatement_AttributesAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeStatementAccess().getAttributesAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("attributes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEdgeStatementAccess().getAttributesAttributeListParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EdgeStatement_EdgeTargetsAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule EdgeStatement ****************/


/************ begin Rule EdgeTarget ****************
 *
 * EdgeTarget:
 *   operator=EdgeOperator (targetSubgraph=Subgraph|targetnode=Node);
 *
 **/

// operator=EdgeOperator (targetSubgraph=Subgraph|targetnode=Node)
protected class EdgeTarget_Group extends GroupToken {
	
	public EdgeTarget_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEdgeTargetAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EdgeTarget_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEdgeTargetRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=EdgeOperator
protected class EdgeTarget_OperatorAssignment_0 extends AssignmentToken  {
	
	public EdgeTarget_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeTargetAccess().getOperatorAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getEdgeTargetAccess().getOperatorEdgeOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// targetSubgraph=Subgraph|targetnode=Node
protected class EdgeTarget_Alternatives_1 extends AlternativesToken {

	public EdgeTarget_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEdgeTargetAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EdgeTarget_TargetSubgraphAssignment_1_0(parent, this, 0, inst);
			case 1: return new EdgeTarget_TargetnodeAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// targetSubgraph=Subgraph
protected class EdgeTarget_TargetSubgraphAssignment_1_0 extends AssignmentToken  {
	
	public EdgeTarget_TargetSubgraphAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeTargetAccess().getTargetSubgraphAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("targetSubgraph",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("targetSubgraph");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSubgraphRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEdgeTargetAccess().getTargetSubgraphSubgraphParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EdgeTarget_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// targetnode=Node
protected class EdgeTarget_TargetnodeAssignment_1_1 extends AssignmentToken  {
	
	public EdgeTarget_TargetnodeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEdgeTargetAccess().getTargetnodeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("targetnode",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("targetnode");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEdgeTargetAccess().getTargetnodeNodeParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EdgeTarget_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EdgeTarget ****************/


/************ begin Rule NodeStatement ****************
 *
 * NodeStatement:
 *   node=Node attributes=AttributeList?;
 *
 **/

// node=Node attributes=AttributeList?
protected class NodeStatement_Group extends GroupToken {
	
	public NodeStatement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeStatementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NodeStatement_AttributesAssignment_1(parent, this, 0, inst);
			case 1: return new NodeStatement_NodeAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNodeStatementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// node=Node
protected class NodeStatement_NodeAssignment_0 extends AssignmentToken  {
	
	public NodeStatement_NodeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeStatementAccess().getNodeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("node",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("node");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeStatementAccess().getNodeNodeParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// attributes=AttributeList?
protected class NodeStatement_AttributesAssignment_1 extends AssignmentToken  {
	
	public NodeStatement_AttributesAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeStatementAccess().getAttributesAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("attributes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeStatementAccess().getAttributesAttributeListParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NodeStatement_NodeAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NodeStatement ****************/


/************ begin Rule AttributeStatement ****************
 *
 * AttributeStatement:
 *   type=AttributeType attributes=AttributeList;
 *
 **/

// type=AttributeType attributes=AttributeList
protected class AttributeStatement_Group extends GroupToken {
	
	public AttributeStatement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeStatementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeStatement_AttributesAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeStatementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=AttributeType
protected class AttributeStatement_TypeAssignment_0 extends AssignmentToken  {
	
	public AttributeStatement_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeStatementAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getAttributeStatementAccess().getTypeAttributeTypeEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// attributes=AttributeList
protected class AttributeStatement_AttributesAssignment_1 extends AssignmentToken  {
	
	public AttributeStatement_AttributesAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeStatementAccess().getAttributesAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("attributes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAttributeStatementAccess().getAttributesAttributeListParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AttributeStatement_TypeAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule AttributeStatement ****************/


/************ begin Rule Subgraph ****************
 *
 * Subgraph:
 *   ("subgraph" name=ID?)? "{" statements+=Statement* "}";
 *
 **/

// ("subgraph" name=ID?)? "{" statements+=Statement* "}"
protected class Subgraph_Group extends GroupToken {
	
	public Subgraph_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSubgraphRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ("subgraph" name=ID?)?
protected class Subgraph_Group_0 extends GroupToken {
	
	public Subgraph_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_NameAssignment_0_1(parent, this, 0, inst);
			case 1: return new Subgraph_SubgraphKeyword_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "subgraph"
protected class Subgraph_SubgraphKeyword_0_0 extends KeywordToken  {
	
	public Subgraph_SubgraphKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getSubgraphKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID?
protected class Subgraph_NameAssignment_0_1 extends AssignmentToken  {
	
	public Subgraph_NameAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getNameAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_SubgraphKeyword_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSubgraphAccess().getNameIDTerminalRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// "{"
protected class Subgraph_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public Subgraph_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_Group_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// statements+=Statement*
protected class Subgraph_StatementsAssignment_2 extends AssignmentToken  {
	
	public Subgraph_StatementsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getStatementsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("statements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("statements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSubgraphAccess().getStatementsStatementParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Subgraph_StatementsAssignment_2(parent, next, actIndex, consumed);
			case 1: return new Subgraph_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Subgraph_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Subgraph_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSubgraphAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Subgraph_StatementsAssignment_2(parent, this, 0, inst);
			case 1: return new Subgraph_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Subgraph ****************/


/************ begin Rule AttributeList ****************
 *
 * AttributeList:
 *   "[" entries+=Attribute ("," entries+=Attribute)* "]";
 *
 **/

// "[" entries+=Attribute ("," entries+=Attribute)* "]"
protected class AttributeList_Group extends GroupToken {
	
	public AttributeList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_RightSquareBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "["
protected class AttributeList_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public AttributeList_LeftSquareBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getLeftSquareBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// entries+=Attribute
protected class AttributeList_EntriesAssignment_1 extends AssignmentToken  {
	
	public AttributeList_EntriesAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getEntriesAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAttributeListAccess().getEntriesAttributeParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AttributeList_LeftSquareBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," entries+=Attribute)*
protected class AttributeList_Group_2 extends GroupToken {
	
	public AttributeList_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_EntriesAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class AttributeList_CommaKeyword_2_0 extends KeywordToken  {
	
	public AttributeList_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_Group_2(parent, this, 0, inst);
			case 1: return new AttributeList_EntriesAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// entries+=Attribute
protected class AttributeList_EntriesAssignment_2_1 extends AssignmentToken  {
	
	public AttributeList_EntriesAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getEntriesAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAttributeListAccess().getEntriesAttributeParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AttributeList_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "]"
protected class AttributeList_RightSquareBracketKeyword_3 extends KeywordToken  {
	
	public AttributeList_RightSquareBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeListAccess().getRightSquareBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeList_Group_2(parent, this, 0, inst);
			case 1: return new AttributeList_EntriesAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule AttributeList ****************/


/************ begin Rule Attribute ****************
 *
 * Attribute:
 *   name=DotID ("=" value=DotID)?;
 *
 **/

// name=DotID ("=" value=DotID)?
protected class Attribute_Group extends GroupToken {
	
	public Attribute_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group_1(parent, this, 0, inst);
			case 1: return new Attribute_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=DotID
protected class Attribute_NameAssignment_0 extends AssignmentToken  {
	
	public Attribute_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getAttributeAccess().getNameDotIDParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("=" value=DotID)?
protected class Attribute_Group_1 extends GroupToken {
	
	public Attribute_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_ValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class Attribute_EqualsSignKeyword_1_0 extends KeywordToken  {
	
	public Attribute_EqualsSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getEqualsSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=DotID
protected class Attribute_ValueAssignment_1_1 extends AssignmentToken  {
	
	public Attribute_ValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getValueAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_EqualsSignKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getAttributeAccess().getValueDotIDParserRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Attribute ****************/


/************ begin Rule Node ****************
 *
 * Node:
 *   name=DotID (":" port=Port)?;
 *
 **/

// name=DotID (":" port=Port)?
protected class Node_Group extends GroupToken {
	
	public Node_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_Group_1(parent, this, 0, inst);
			case 1: return new Node_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=DotID
protected class Node_NameAssignment_0 extends AssignmentToken  {
	
	public Node_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getNodeAccess().getNameDotIDParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// (":" port=Port)?
protected class Node_Group_1 extends GroupToken {
	
	public Node_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNodeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_PortAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Node_ColonKeyword_1_0 extends KeywordToken  {
	
	public Node_ColonKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNodeAccess().getColonKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Node_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// port=Port
protected class Node_PortAssignment_1_1 extends AssignmentToken  {
	
	public Node_PortAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNodeAccess().getPortAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Port_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("port",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("port");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPortRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNodeAccess().getPortPortParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Node_ColonKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Node ****************/


/************ begin Rule Port ****************
 *
 * Port:
 *   name=DotID (":" compass_pt=CompassPoint)?|compass_pt=CompassPoint;
 *
 **/

// name=DotID (":" compass_pt=CompassPoint)?|compass_pt=CompassPoint
protected class Port_Alternatives extends AlternativesToken {

	public Port_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPortAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Port_Group_0(parent, this, 0, inst);
			case 1: return new Port_Compass_ptAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPortRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=DotID (":" compass_pt=CompassPoint)?
protected class Port_Group_0 extends GroupToken {
	
	public Port_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPortAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Port_Group_0_1(parent, this, 0, inst);
			case 1: return new Port_NameAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// name=DotID
protected class Port_NameAssignment_0_0 extends AssignmentToken  {
	
	public Port_NameAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPortAccess().getNameAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getPortAccess().getNameDotIDParserRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// (":" compass_pt=CompassPoint)?
protected class Port_Group_0_1 extends GroupToken {
	
	public Port_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPortAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Port_Compass_ptAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Port_ColonKeyword_0_1_0 extends KeywordToken  {
	
	public Port_ColonKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPortAccess().getColonKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Port_NameAssignment_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// compass_pt=CompassPoint
protected class Port_Compass_ptAssignment_0_1_1 extends AssignmentToken  {
	
	public Port_Compass_ptAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPortAccess().getCompass_ptAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Port_ColonKeyword_0_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("compass_pt",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("compass_pt");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getPortAccess().getCompass_ptCompassPointEnumRuleCall_0_1_1_0();
			return obj;
		}
		return null;
	}

}



// compass_pt=CompassPoint
protected class Port_Compass_ptAssignment_1 extends AssignmentToken  {
	
	public Port_Compass_ptAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPortAccess().getCompass_ptAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("compass_pt",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("compass_pt");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getPortAccess().getCompass_ptCompassPointEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Port ****************/


}
