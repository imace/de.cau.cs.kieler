«IMPORT synccharts»

«EXTENSION template::helper»

«DEFINE main FOR Region-»
«FILE innerStates.first().label + ".strl"-»
module «innerStates.first().label» : 
«FOREACH innerStates.first().signals AS sig -»«IF sig.isInput»input «sig.name»;«ENDIF-»«IF sig.isOutput»output «sig.name»;«ENDIF-» 
«ENDFOREACH-»
«IF !innerStates.first().locals().isEmpty»
signal
 «FOREACH innerStates.first().locals() AS sig  SEPARATOR ","-»«sig.name»«ENDFOREACH»
in
«ENDIF»
  «FOREACH innerStates.first().regions AS region»«EXPAND Constelation FOR region»«ENDFOREACH-»
«IF !innerStates.first().locals().isEmpty»
end signal
«ENDIF»
end module
«ENDFILE-»
«ENDDEFINE»

«DEFINE Constelation FOR Region-»
«IF canTerminate()»trap done in «ENDIF»
  signal T_«innerStates.first().id»«FOREACH this.innerStates AS state-», goto_«state.id»«ENDFOREACH» in
    emit goto_«this.initial().id»;
    loop
      weak abort 
        «FOREACH this.innerStates.sortStates() AS state-»
        present goto_«state.id» then
        «IF state.canBeTransient()»signal start_«state.id» in emit start_«state.id»;«ENDIF»     
            «EXPAND Star FOR state-»                
         «IF state.canBeTransient()»
            present start_«state.id» else
              emit T_«innerStates.first().id»;pause;
            end present   
          end signal
          «ELSE»
            emit T_«innerStates.first().id»;pause;
          «ENDIF»
        end present;
        «ENDFOREACH-»
        halt;
      when T_«innerStates.first().id»;
    end loop;
  end signal;
«IF canTerminate()»end trap«ENDIF»
«ENDDEFINE»

«DEFINE Star FOR synccharts::State-»
 % «id»
 «IF this.hasSAborts()»abort«ENDIF»
 «IF this.hasWAborts()»weak abort«ENDIF»
 «IF this.regions.isEmpty-»
   «IF this.isFinal»exit done;«ELSE»halt;«ENDIF»
 «ELSE-»
 [
   «FOREACH this.regions AS region SEPARATOR "||"-»
   «EXPAND Constelation FOR region»
   «ENDFOREACH-»
   ]; 
  «IF this.hasNT()-»
    «FOREACH getNT().effects AS eff-»«EXPAND Effect FOR eff»«ENDFOREACH-»
    emit goto_«getNT().targetState.id»;
  «ENDIF-»
«ENDIF»
  «IF this.hasWAborts()» 
    when
    «FOREACH this.getWAborts() AS trans-»
      case «IF trans.isImmediate»immediate «ENDIF-» «IF trans.trigger==null»tick«ELSE»[«EXPAND Trigger FOR trans.trigger»]«ENDIF» do 
      emit goto_«trans.targetState.id»;
      «FOREACH trans.effects AS eff-»
        «EXPAND Effect FOR eff»
      «ENDFOREACH-»
      «ENDFOREACH»
       end abort;
  «ENDIF»
  «IF this.hasSAborts()» 
    when
    «FOREACH this.getSAborts() AS trans-»
      case «IF trans.isImmediate»immediate «ENDIF-» «IF trans.trigger==null»tick«ELSE»[«EXPAND Trigger FOR trans.trigger»]«ENDIF» do 
      emit goto_«trans.targetState.id»;
      «FOREACH trans.effects AS eff-»
        «EXPAND Effect FOR eff»
      «ENDFOREACH-»
    «ENDFOREACH-»
     end abort;
  «ENDIF» 
«ENDDEFINE»

«DEFINE Effect FOR Emission»emit «signal.name»;«ENDDEFINE»
«DEFINE Effect FOR Assignment»«variable» := «expression»;«ENDDEFINE»
«DEFINE Effect FOR HostCode»«code»;«ENDDEFINE»
«DEFINE Effect FOR Effect»//ERROR: unknown effect«ENDDEFINE»
«REM» Trigger «ENDREM»
«DEFINE Trigger FOR Value»«toString()»«ENDDEFINE»
«DEFINE Trigger FOR VariableReference»«variable.name»«ENDDEFINE»
«DEFINE Trigger FOR SignalReference»«signal.name»«ENDDEFINE»
«DEFINE Trigger FOR ComplexExpression»
  («FOREACH subExpressions AS sub SEPARATOR " " + operator.toString() + " "» «EXPAND Trigger FOR sub» «ENDFOREACH»)
«ENDDEFINE»
«DEFINE Trigger FOR HostCode»«code»«ENDDEFINE»
«DEFINE Trigger FOR Expression»//ERROR: unknown expression«ENDDEFINE»





