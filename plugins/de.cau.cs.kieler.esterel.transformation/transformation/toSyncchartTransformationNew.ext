import ecore;
import synccharts;
import annotations;
import expressions;
import utilities;
import esterel;

extension feature;
 
/*
 * initial test transformation

Void initial(State s):
	let r = new Region:
	let ns = new State:
	r.states.add(ns) ->
	s.regions.add(r) ->
	ns.setLabel("InnerStateXY") ->
	appendTransformation("initial", ns) ->
	s
;
 */
 
 
Void initial(State s, emf::EObject noneed):
 	let m = ((emf::EObject) s.bodyReference):
 	let mo = (Program) castToEMF(m):
 	let selfTrans = new Transition:
 	ruleModule(s, mo.module.get(0)) -> 
 	s
;

/*
Void sandbox():
	let l = new Loop:
	l
;
*/

/*
 * rule 1 (module)
 */ 
Void ruleModule(State s, Module m):
	let statement = m.modBody.statement.get(0):
	let newState = new State:
	let r = new Region:
	s.regions.add(r) ->
	s.setLabel(m.name) ->
	r.states.add(newState) ->
	newState.setIsInitial(true) ->
	newState.setIsFinal(true) -> 
	// TODO set singals
	// TODO set body content
	setJavaBodyContents(newState, statement) ->
	appendNextTransformation(newState, statement)
;


/*
 * rule 3 (halt)
 */
Void rule(State s, Halt h):
	let r = new Region:
	let ns = new State:
	s.regions.add(r) ->
	s.setLabel("Halt State") ->
	ns.setIsInitial(true) ->
	r.states.add(ns)
;

/*
 * rule 5 (abort)

 Void ruleAbort(State s):
 	let a = (Abort) castToEMF(s.bodyContents):
 	let r = new Region:
 	let initState = new State:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	let caseStates = {}:
 	s.setLabel("Abort State") ->
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	
 	// connect initial and final state in case of a normal termination
 	toFinalTrans.setSourceState(initState) ->
 	toFinalTrans.setTargetState(finalState) ->
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	initState.setIsInitial(true) ->
 	finalState.setIsFinal(true) ->
 	
 	// handle cases (only for ABRO currently)
 	handleAbort(r, initState, a) ->
 	setJavaBodyContents(initState, a.statement) ->
 	appendNextTransformation(a.statement, initState) ->
 	a
 ;
 */
 
 /*
 * rule 5 (abort)
 */
 Void rule(State s, Abort a):
 	let r = new Region:
 	let initState = new State:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	let caseStates = {}:
 	s.setLabel("Abort State") ->
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	
 	// connect initial and final state in case of a normal termination
 	toFinalTrans.setSourceState(initState) ->
 	toFinalTrans.setTargetState(finalState) ->
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	initState.setIsInitial(true) ->
 	finalState.setIsFinal(true) ->
 	
 	// handle cases (only for ABRO currently)
 	handleAbort(r, initState, a) ->
 	setJavaBodyContents(initState, a.statement) ->
 	appendNextTransformation(initState, (emf::EObject) a.statement) ->
 	a
 ;
 
Void handleAbort(Region parent, State s, Abort a):
	let body = (AbortInstance) a.body:
	let final = new State:
	let t = new Transition:
	parent.states.add(final) ->
	final.setIsFinal(true) ->
	t.setSourceState(s) ->
	t.setTargetState(final) ->
	t.setType(TransitionType::STRONGABORT) ->
	//t.setTrigger(body.delay.event.signal)
	s	
;

/*
 * rule 8 (await)
 */
Void rule(State s, Await a):
 	let r = new Region :
 	let initState = new State:
 	let caseStates = {}:
 	s.setLabel("Await State") ->
 	s.regions.add(r) ->
 	initState.setIsInitial(true) ->
 	
 	//(AwaitInstance.isInstance(a.body) ? 
 	ruleAwaitInstance(r, initState, (AwaitInstance) a.body) ->
 	//AwaitCase.isInstance(a.body) ? 
 	// handle cases
 	//((AwaitCase) a.body).cases.handleAwaitCase(caseStates, initState) : "" ->
 	//: a ->
 	// handle instance
 	//->
 	r.states.add(initState) ->
 	r.states.addAll(caseStates)
;
 
ruleAwaitInstance(Region region, State previous, AwaitInstance ai):
	let s = new State:
	let t = new Transition:
	region.states.add(s) ->
	t.setType(TransitionType::STRONGABORT) ->
	t.setSourceState(previous) ->
	t.setTargetState(s) ->
	s.setIsFinal(true)
;
 /*
  * rule 12 (emit)
  */
Void rule(State s, Emit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	s.regions.add(r) ->
	s.setLabel("Emit State") ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	emitTrans.setSourceState(initS) ->
	emitTrans.setTargetState(finalS) ->
	// TODO emit emitTrans.setEffects(e.signal + effect)
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS)
;

/*
 * rule 17 (loop)
 */
Void rule(State s, Loop l):
	let r = new Region:
	let loopState = new State:
 	let selfTrans = new Transition:
	s.setLabel("Loop_State") ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.setSourceState(loopState) ->
 	selfTrans.setTargetState(loopState) ->  
 	
 	loopState.outgoingTransitions.add(selfTrans) ->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
 	appendNextTransformation(loopState, l.body.statement)
 ;
  
  
 /* rule 19 (parallel)
  *
  */
Void rule(State s, Parallel p):
	//let r = new Region:
	s.setLabel("Parallel State") -> 
 	//s.regions.add(r) ->
 	ruleParallelRecursive(s, p.list)
;

Void ruleParallelRecursive(State parent, List[Statement] statements):
	let r = new Region:
	let s = new State:
	parent.regions.add(r) ->
	r.states.add(s) ->
	
	((statements.size > 1) ? ruleParallelRecursive(parent, statements.withoutFirst()) : s) ->
	
	setJavaBodyContents(s, statements.first()) ->
	appendNextTransformation(s, statements.first())  
;

/*
 * rule 23 (sequence)
 */
 Void rule(State s, Sequence seq):
 	let r = new Region:
 	let initial = new State:
	s.setLabel("Sequence State") ->
	s.regions.add(r) ->
	initial.setIsInitial(true) ->
	r.states.add(initial) ->
	
	// call recursively
	(seq.list.size > 1) ? ruleSequenceRecursive(r, initial, seq.list.withoutFirst()) : s
	->
		// body of first sequence state
	setJavaBodyContents(initial, seq.list.first()) ->
	appendNextTransformation(initial, seq.list.first())  
;

Void ruleSequenceRecursive(Region region, State previous, List[Statement] statements):
	let s = new State:
	let t = new Transition:
	region.states.add(s) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	t.setSourceState(previous) ->
	t.setTargetState(s) ->
		
	((statements.size > 1) ? 
	// if more than 1 element we have to handle another one
	ruleSequenceRecursive(region, s, statements.withoutFirst())  
	: 
	// else finished
	s.setIsFinal(true)) ->
	
	setJavaBodyContents(s, statements.first()) ->
	appendNextTransformation(s, statements.first())
;


Void rule(State s, Block b):
	rule(s, (Parallel) b.statement)
;

 
 /*
  * helping method
  * realises a new await case
  */
 Void handleAwaitCase(AbortCaseSingle ac, List[State] fstates, State initState):
 	let finalState = new State:
	let trans = new Transition:
	trans.setType(TransitionType::STRONGABORT) ->
	trans.setSourceState(initState) ->
	trans.setTargetState(finalState) ->
	//trans.setTrigger(ac.delayExpr) ->
	//finalState.setBodyContents(ac.statement) ->
	fstates.add(finalState)
 ;
 
 
 
appendNextTransformation(State s, emf::EObject esterel):
	appendTransformation(createTransformationStatement("rule", s, esterel), 
	"de.cau.cs.kieler.esterel.transformation.impl.E2SDataComponent")
	/*switch {
		case Abort.isInstance(esterel): appendTransformation("ruleAbort", s, esterel)
		case Await.isInstance(esterel): appendTransformation("ruleAwait", s, esterel)
		case Emit.isInstance(esterel): appendTransformation("ruleEmit", s, esterel)
		case Loop.isInstance(esterel): appendTransformation("ruleLoop", s, esterel)
		case Nothing.isInstance(esterel): appendTransformation("ruleNothing",  s, esterel)
		case Pause.isInstance(esterel): appendTransformation("rulePause", s, esterel)
		case Sequence.isInstance(esterel): appendTransformation("ruleSequence", s, esterel)
		default: appendTransformation("ruleAbort", s, esterel)
	}*/
;
 
 
 
Object createTransformationStatement(String str, State syncModel, emf::EObject estModel):
	JAVA de.cau.cs.kieler.esterel.transformation.impl.E2SDataComponent.getTransformationStatement(java.lang.String,
de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;

/*
 * passes information about a new transformation to the data component.
 */
Void appendTransformation(Object o, String s):
	JAVA de.cau.cs.kieler.esterel.transformation.core.XtendToJava.appendTransformation(java.lang.Object, java.lang.String)
; 
 
emf::EObject castToEMF(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.TransformationHelper.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

ecore::EObject castToEcore(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.TransformationHelper.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

Void setJavaBodyContents(State s, emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.TransformationHelper.setBodyReference(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;

 
