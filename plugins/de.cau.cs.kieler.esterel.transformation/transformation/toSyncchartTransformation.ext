import ecore;
import annotations;
import expressions;
import synccharts;
import utilities;
import esterel;

extension feature;
extension org::eclipse::xtend::util::stdlib::cloning;
 
 
/*
 * Some notes: 
 * - keep in mind to add states to their parents first, so potential transitions 
 *   generate a notification which is handled
 * - if the parent state has a label, do not overwrite it
 * - if automatic recursion is desired, use the recursiveRule()
 * - remember to pass the GLOBALVAR "recursive" to the XtendFacade
 * - add / remove bodytext!
 */
 
 
/*
 
   */
   
  Void sandbox(State s):
  let t = new Transition:
  let e = new Effect:
  let de = new DelayExpr:
 // ((synccharts::Action)t).setLabel("foobat") ->
  // addSelfLoop(s)->

s	
  ;




Void recursiveRule(State s, emf::EObject e):
	((boolean) GLOBALVAR recursive) ? rule(s, e) : s
	-> s
;
 
// just dummy for xtend 
Void rule(State s, emf::EObject noneed):
	s.setLabel("damn you")
;
 

// rule for Program, forwards the first module
Void rule(State s, Program p):
 	let m = ((emf::EObject) s.bodyReference):
 	let mo = (Program) castToEMF(m):	
	rule(s, mo.modules.get(0))
;

/*
 * rule 1 (module)
 */ 
Void rule(State s, Module m):
	let statement = m.body.statements.get(0):
	removeBodyText(s) ->
	// always set label here!
	s.setLabel(m.name) ->
	//s.setIsInitial(true) ->
	//s.setIsFinal(true) ->
	// TODO set singals
	m.interface.intSignalDecls.extractSignals(s)->	
	// TODO set body content
	setJavaBodyContents(s, statement) ->
	//appendNextTransformation(newState, statement)
	recursiveRule(s, statement)
;

/*
 * rule 2 (nothing)
 */ 
Void rule(State s, Nothing n):
	let nState = new State:
	let r = new Region:
	s.removeBodyText() ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Nothing State") ->
	r.states.add(nState) ->
	nState.setIsFinal(true) ->
	nState.setIsInitial(true)
;

/*
 * rule 3 (halt)
 */
Void rule(State s, Halt h):
	let r = new Region:
	let ns = new State:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Halt State") ->
	ns.setIsInitial(true) ->
	r.states.add(ns)
;
 
/*
 * rule 4 (pause)
 */
Void rule(State s, Pause p):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	// setup states
	s.removeBodyText() ->
	s.setLabelIfEmpty("Pause State") ->
	s.regions.add(r) ->
	r.states.addAll({initS, finalS}) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	// add transition
	t.setType(TransitionType::STRONGABORT) ->
	t.connectTransition(initS, finalS)
;

 /*
 * rule 5 (abort)
 */
 Void rule(State s, Abort a):
 	let r = new Region:
 	let initState = new State:
 	let caseStates = {}:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	removeBodyText(s) ->
 	s.setLabelIfEmpty("Abort State") ->
 	// add new state
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	// connect initial and final state with of a normal termination
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	toFinalTrans.setPriority(1) ->
	initState.setIsInitial(true) ->
	finalState.setIsFinal(true) ->
	
	// just an instance or cases?
 	(AbortInstance.isInstance(a.body) ?
	 	handleAbortCaseSingle(r, initState, 1,
	 		((AbortInstance)a.body).delay, 
	 		((AbortInstance)a.body).statement)
 	:
 		(toFinalTrans.setPriority(((AbortCase)a.body).cases.size + 1) ->
 		// handle cases (only for ABRO currently)
	 	handleAbortCases(r, initState, 1, ((AbortCase)a.body).cases))
	) -> 	
	// handle abort's body statement
	toFinalTrans.connectTransition(initState, finalState) ->
	setJavaBodyContents(initState, a.statement) ->
	recursiveRule(initState, a.statement)
 ;
		
Void handleAbortCases(Region parent, State source, Integer prio, List[AbortCaseSingle] cases):
	(cases.size > 1) ?
		(handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement) ->
		handleAbortCases(parent, source, prio + 1, cases.withoutFirst()))
		:
		handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement)
;

Void handleAbortCaseSingle(Region parent, State source, Integer prio, DelayExpr expr, Statement body):
	let caseState = new State:
	let trans = new Transition:
	caseState.setIsFinal(true) ->
	parent.states.add(caseState) ->
	
	// create and add transition
	trans.setType(TransitionType::WEAKABORT) ->
	trans.setPriority(prio) ->
	
	// handle delayexpr
	trans.addDelayToTrigger(expr) ->
		
	trans.connectTransition(source, caseState) ->
	
	// care! the "do" body of about might be null
	if (body != null) then
		// set body text 
		(setJavaBodyContents(caseState, body)  ->
		recursiveRule(caseState, body))
;

/*
 * rule 6 (weak abort)
 */
// TODO

/*
 * rule 7 (assign)
 */
 Void rule(State s, esterel::Assignment assign):
 	let r = new Region:
 	let initS = new State:
 	let finalS = new State:
 	let t = new Transition:
 	let sa = new Assignment:
 	s.removeBodyText() ->
 	// setup states
 	s.setLabelIfEmpty("Assign State") ->
 	s.regions.add(r) ->
 	r.states.addAll({initS, finalS}) ->
 	initS.setIsInitial(true) ->
 	finalS.setIsFinal(true) ->
 	// init transition
 	t.connectTransition(initS, finalS) ->
 	sa.setVariable(assign.var) ->
 	if (assign.expr.expr != null) then
 		sa.setExpression(assign.expr.expr)
 	// TODO assignment
 ;

/*
 * rule 8 (await)
 */
Void rule(State s, Await a):
 	let r = new Region :
 	let initState = new State:
 	let caseStates = {}:
	removeBodyText(s) ->
 	s.setLabelIfEmpty("Await State") ->
 	// add state
 	s.regions.add(r) ->
 	initState.setIsInitial(true) ->
 	r.states.add(initState) ->

 	// just one instance or cases?
	AwaitInstance.isInstance(a.body)?
		handleAwaitCaseSingle(r, initState, 1, 
			((AwaitInstance)a.body).delay, 
			((AwaitInstance)a.body).statement)
	:
		handleAwaitCases(r, initState, 1, ((AwaitCase)a.body).cases)
;
 
// as abort and await cases are equal, we use AbortCaseSingles 
Void handleAwaitCases(Region r, State previous, Integer prio, List[AbortCaseSingle] cases):
	handleAbortCases(r, previous, prio, cases)
;

Void handleAwaitCaseSingle(Region r, State previous, Integer prio, DelayExpr expr, Statement body):
	handleAbortCaseSingle(r, previous, prio, expr, body)
;

 /*
  * rule 10 (doupto)
  */

  
  
  


 /*
  * rule 12 (emit)
  */
Void rule(State s, Emit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Emit State") ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.signal) ->
	emission.setNewValue((Expression)clone(e.expr.expr)) ->
	emitTrans.effects.add(emission) ->
	// add transition to state
	emitTrans.setSourceState(initS) ->
	emitTrans.setTargetState(finalS) ->
	initS.outgoingTransitions.add(emitTrans)
;

/*
 * rule 13 (every)
 */
Void rule(State s, EveryDo e):
	let r = new Region:
	let initS = new State:
	let everyS = new State:
	let initT = new Transition:
	let everyT = new Transition:
	s.removeBodyText() ->
	// setup states
	s.setLabelIfEmpty("Every State") ->
	s.regions.add(r) ->
	r.states.addAll({initS, everyS}) ->
	initS.setIsInitial(true) ->
	// init transitions
	initT.setType(TransitionType::STRONGABORT) ->
	everyT.setType(TransitionType::STRONGABORT) ->
	initT.connectTransition(initS, everyS) ->
	everyT.connectTransition(everyS, everyS) ->
	// add delays
	initT.addDelayToTrigger(e.delay) ->
	everyT.addDelayToTrigger(e.delay) ->
	// recursive
	everyS.setJavaBodyContents(e.statement) ->
	everyS.recursiveRule(e.statement)
;

/*
 * rule 15 (localsignal)
 */
Void rule(State s, LocalSignalDecl ls):
	let r = new Region:
	let sigS = new State:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Localsignal State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(sigS) ->
	sigS.setIsInitial(true) ->
	sigS.setIsFinal(true) ->
	
	ls.signalList.extractLocalSignals(s) ->
	
	// recursive
	sigS.setJavaBodyContents(ls.statement) ->
	sigS.recursiveRule(ls.statement)
;


/*
 * rule 16 (localvariable)
 */
Void rule(State s, LocalVariable v):
	let r = new Region:
	let varS = new State:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Localvariable State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(varS) ->
	varS.setIsInitial(true) ->
	varS.setIsFinal(true) ->
	
	// TODO
	//s.interfaceDecls.add((InterfaceDeclaration)clone(v.var)) ->
	
	// recursive
	varS.setJavaBodyContents( v.statement) ->
	varS.recursiveRule(v.statement)
;


/*
 * rule 17 (loop) & rule 18 (loop each)
 */
Void rule(State s, Loop l):
	let r = new Region:
	let loopState = new State:
 	let selfTrans = new Transition:
 	removeBodyText(s) ->
 	// setup state
	(LoopEach.isInstance(l.end) ? s.setLabelIfEmpty("LoopEach State") 
			: s.setLabelIfEmpty("Loop_State")) ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	// setup transition
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.connectTransition(loopState, loopState) ->
 	
 	if LoopEach.isInstance(l.end) then
 		(selfTrans.setType(TransitionType::STRONGABORT) ->
 		 s) -> selfTrans.addDelayToTrigger(((LoopDelay)l.end).delay) ->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
	recursiveRule(loopState, l.body.statement)
 ;
 

 /* 
  * rule 19 (parallel)
  */
Void rule(State s, Parallel p):
	removeBodyText(s) ->
	s.setLabelIfEmpty("Parallel State") -> 
	
 	ruleParallelRecursive(s, p.list)
;

Void ruleParallelRecursive(State parent, List[Statement] statements):
	// if inner parallel, extract the statements
	(Parallel.isInstance(statements.first()) ? 
		(
		statements.addAll(((Parallel)statements.first()).list) ->
		statements.remove(statements.first()) ->
		ruleParallelRecursive(parent, statements)
		)
	: 
		// else create this state and add it to the parallel region
		(
		let r = new Region:
		let s = new State:
		parent.regions.add(r) ->
		r.states.add(s) ->
		// add this to parallel
		s.setIsFinal(true) ->
		s.setIsInitial(true) ->
		
		if(statements.size > 1) then
			ruleParallelRecursive(parent, statements.withoutFirst()) ->
		
		setJavaBodyContents(s, statements.first()) ->
		recursiveRule(s, statements.first())
		)
	)	
;

Void rule(State s, Present p):
	let r = new Region:
	let pS = new State:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Present State") ->
	// setup
	s.regions.add(r) ->
	r.states.add(pS) ->
	pS.setIsInitial(true) ->
	
	(PresentEventBody.isInstance(p.body) ? 
		s // not supported yet 
		:
		handlePresentCases(r, pS, 1, ((PresentCaseList)p.body).cases)
	) 
	
;

Void handlePresentCases(Region parent, State previous, Integer prio, List[PresentCase] cases):
	(cases.size > 1) ?
		(handlePresentCaseSingle(parent, previous, prio, cases.first().event.expression, cases.first().statement) ->
		handlePresentCases(parent, previous, prio, cases.withoutFirst()))
		:
		(handlePresentCaseSingle(parent, previous, prio, cases.first().event.expression, cases.first().statement)
	)
;

Void handlePresentCaseSingle(Region parent, State previous, Integer prio, Expression e, Statement st):
	let newS = new State:
	let t = new Transition:
	// setup
	parent.states.add(newS) ->
	t.setPriority(prio) ->
	t.setTrigger(e) ->
	
	t.connectTransition(previous, newS) ->
	
	// recursive
	newS.setJavaBodyContents(st) ->
	newS.recursiveRule(st)
;

/*
 * rule 23 (sequence)
 */
 Void rule(State s, Sequence seq):
 	let r = new Region:
 	let initial = new State:
 	let list = (List[Statement]){}:
 	s.removeBodyText() ->
 	// create initial state
	s.setLabelIfEmpty("Sequence State") ->
	s.regions.add(r) ->
	initial.setIsInitial(true) ->
	r.states.add(initial) ->
	
	// as the grammar generates nested sequences, we flatten it first
	// this is important to conserve order!
	seq.flattenSequence(list) ->
	
	// call recursively
	ruleSequenceRecursive(r, initial, list.withoutFirst()) ->
	 
	// process body of first sequence state
	setJavaBodyContents(initial, list.first()) ->
	recursiveRule(initial, list.first())
	
;

Void flattenSequence(Statement s, List list):
	Sequence.isInstance(s) ? (
		(Sequence)s).list.flattenSequence(list) 
		:
		(list.add(s))
;

Void ruleSequenceRecursive(Region region, State previous, List[Statement] statements):
	let s = new State:
	let t = new Transition:
	// create the new state and add to the sequence chain
	region.states.add(s) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	t.connectTransition(previous, s) ->
		
	(((statements.size > 1) ? 
	// if more than 1 element we have to handle another one
	ruleSequenceRecursive(region, s, statements.withoutFirst())  
	: 
	// else finished and the last one is a final state!
	s.setIsFinal(true)))
	
	->
	setJavaBodyContents(s, statements.first()) ->
	recursiveRule(s, statements.first())
;


/*
 * rule 24 (suspend)
 */
Void rule(State s, Suspend sus):
	let r = new Region:
	let susState = new State:
	let act = new Action:
	s.removeBodyText() ->
	s.setLabelIfEmpty("Suspend State") ->
	s.regions.add(r) ->
	r.states.add(susState) ->
	
	// setup
	susState.setIsInitial(true) ->
	susState.setIsFinal(true) ->
	// add suspension
	act.addDelayToTrigger(sus.delay) ->
	susState.setSuspensionTrigger(act) ->
	
	// recursive
	susState.setJavaBodyContents(sus.statement) ->
	susState.recursiveRule(sus.statement)
	
;

/*
 * rule 25 (sustain)
 */
Void rule(State s, Sustain sus):
s
;



/*
	omit the block, theres a parallel in it!
*/
Void rule(State s, Block b):
	rule(s, (Parallel) b.statement)
;


 
emf::EObject castToEMF(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

ecore::EObject castToEcore(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

Void setJavaBodyContents(State s, emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.setBodyReference(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;




 /*
  * Convenient methods
  */


// extracts the expression and immediate information of a esterel::DelayExpr
// and adds them to the synccharts::Transition
Void addDelayToTrigger(Action t, DelayExpr delay):
	if delay.isImmediate then t.setIsImmediate(true) ->
	// clone the expression as in should stay in esterel model too
	t.setTrigger((Expression)clone(delay.event.expr)) ->
	if delay.expr != null then
		t -> // TODO not yet supported, as synccharts do not offer a delay expression! 
	t		
;

// extracts all signals from InterfaceSignalDecl and adds them to the state
Void extractSignals(InterfaceSignalDecl decl, State s):
	let clonedDecl = (InterfaceSignalDecl) clone(decl):
	let copy = (List[Signal]) copyList(clonedDecl.signals):
	switch {
		case Input.isInstance(decl) : (copy.setIsInput(true) ->  copy.setIsOutput(false))
		case Output.isInstance(decl) : (copy.setIsInput(false) ->  copy.setIsOutput(true))
		case InputOutput.isInstance(decl) : (copy.setIsInput(true) ->  copy.setIsOutput(true))
   		default : decl //no information about input/output
	} ->
	if clonedDecl.signals.size > 0 then
		copy.addSignalToState(s)
;

// extracts all local signals
Void extractLocalSignals(LocalSignalList lsl, State s):
	if LocalSignal.isInstance(lsl) then
		(let copy = (List[ISignal]) clone(((LocalSignal)lsl).signal):
		copy.addSignalToState(s)
		)
;

// adds sig to the state, does some processing
Void addSignalToState(Signal sig, State st):
	st.signals.add(sig)
;

// connects a transition to the two passed states
Void connectTransition(Transition t, State source, State target):
	t.setSourceState(source) ->
	t.setTargetState(target) ->
	source.outgoingTransitions.add(t)
;

// removes ALL !! body text, set state type to NORMAL
Void removeBodyText(State s):
 	s.bodyText.removeAll(s.bodyText) ->
 	//s.setBodyReference(null) ->
 	s.setType(StateType::NORMAL)
;

// only set the label if there's no previous label
Void setLabelIfEmpty(State s, String label):
	(s.label == null || s.label.trim().length == 0) ? 
		s.setLabel(label) : s
;

List[ISignal] copyList(List[ISignal] list):
	let copy = {}:
	copy.addAll(list)
;