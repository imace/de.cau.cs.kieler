import ecore;
import synccharts;
import annotations;
import expressions;
import utilities;
import esterel;

//extension feature;
extension org::eclipse::xtend::util::stdlib::cloning;
 
 
/*
 * Some notes: 
 * - keep in mind to add states to their parents first, so potential transitions 
 *   generate a notification which is handled
 * - if the parent state has a label, do not overwrite it
 * - if automatic recursion is desired, use the recursiveRule()
 * - remember to pass the GLOBALVAR "recursive" to the XtendFacade
 */
 
 
/*
 
   */
   
  Void sandbox(State s):
  let t = new Transition:
  let e = new Effect:
 
  s
  ;




Void recursiveRule(State s, emf::EObject e):
	((boolean) GLOBALVAR recursive) ? rule(s, e) : s
	-> s
;
 
// just dummy for xtend 
Void rule(State s, emf::EObject noneed):
	s.setLabel("damn you")
;
 

// rule for Program, forwards the first module
Void rule(State s, Program p):
 	let m = ((emf::EObject) s.bodyReference):
 	let mo = (Program) castToEMF(m):	
	rule(s, mo.modules.get(0))
;

/*
 * rule 1 (module)
 */ 
Void rule(State s, Module m):
	let statement = m.body.statements.get(0):
	s.bodyText.removeAll(s.bodyText) ->
	s.setLabel(m.name) ->
	s.setIsInitial(true) ->
	s.setIsFinal(true) ->
	// TODO set singals
	m.interface.intSignalDecls.extractSignals(s)->	
	// TODO set body content
	setJavaBodyContents(s, statement) ->
	//appendNextTransformation(newState, statement)
	recursiveRule(s, statement)
;


/*
 * rule 3 (halt)
 */
Void rule(State s, Halt h):
	let r = new Region:
	let ns = new State:
	s.bodyText.removeAll(s.bodyText) ->
	s.regions.add(r) ->
	s.setLabel("Halt State") ->
	ns.setIsInitial(true) ->
	r.states.add(ns)
;
 
 /*
 * rule 5 (abort)
 */
 Void rule(State s, Abort a):
 	let r = new Region:
 	let initState = new State:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	let caseStates = {}:
 	s.bodyText.removeAll(s.bodyText) ->
 	s.setLabel("Abort State") ->
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	
 	// connect initial and final state in case of a normal termination
 	toFinalTrans.setSourceState(initState) ->
 	toFinalTrans.setTargetState(finalState) ->
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	initState.setIsInitial(true) ->
 	finalState.setIsFinal(true) ->
 	
 	// handle cases (only for ABRO currently)
 	handleAbort(r, initState, a) ->
 	setJavaBodyContents(initState, a.statement) ->
	recursiveRule(initState, a.statement)
 ;
 
Void handleAbort(Region parent, State s, Abort a):
	let body = (AbortInstance) a.body:
	let final = new State:
	let t = new Transition:
	s.bodyText.removeAll(s.bodyText) ->
	parent.states.add(final) ->
	final.setIsFinal(true) ->
	t.setSourceState(s) ->
	t.setTargetState(final) ->
	t.setType(TransitionType::STRONGABORT) ->
	//t.setTrigger(body.delay.event.signal)
	s	
;

/*
 * rule 8 (await)
 */
Void rule(State s, Await a):
 	let r = new Region :
 	let initState = new State:
 	let caseStates = {}:
 	s.bodyText.removeAll(s.bodyText) ->
 	s.setLabel("Await State") ->
 	s.regions.add(r) ->
 	initState.setIsInitial(true) ->
 	s.setType(StateType::NORMAL) ->
 	//(AwaitInstance.isInstance(a.body) ? 
 	ruleAwaitInstance(r, initState, (AwaitInstance) a.body) ->
 	//AwaitCase.isInstance(a.body) ? 
 	// handle cases
 	//((AwaitCase) a.body).cases.handleAwaitCase(caseStates, initState) : "" ->
 	//: a ->
 	// handle instance
 	//->
 	r.states.add(initState) ->
 	r.states.addAll(caseStates)
;
 
ruleAwaitInstance(Region region, State previous, AwaitInstance ai):
	let s = new State:
	let t = new Transition:
	s.bodyText.removeAll(s.bodyText) ->
	region.states.add(s) ->
	t.setType(TransitionType::STRONGABORT) ->
	t.setSourceState(previous) ->
	t.setTargetState(s) ->
	s.setIsFinal(true)
;
 /*
  * rule 12 (emit)
  */
Void rule(State s, Emit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	s.bodyText.removeAll(s.bodyText) ->
	s.regions.add(r) ->
	s.setLabel("Emit State") ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.signal) ->
	emission.setNewValue(e.expr.expr) ->
	emitTrans.effects.add(emission) ->
	// TODO emit emitTrans.setEffects(e.signal + effect)
	emitTrans.setSourceState(initS) ->
	emitTrans.setTargetState(finalS) ->
	initS.outgoingTransitions.add(emitTrans) ->
	finalS.incomingTransitions.add(emitTrans)
;

/*
 * rule 17 (loop)
 */
Void rule(State s, Loop l):
	let r = new Region:
	let loopState = new State:
 	let selfTrans = new Transition:
 	s.bodyText.removeAll(s.bodyText) ->
	(s.label.trim().length == 0) ? s.setLabel("Loop_State") : s ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.setSourceState(loopState) ->
 	selfTrans.setTargetState(loopState) ->  
 	
 	loopState.outgoingTransitions.add(selfTrans) ->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
	recursiveRule(loopState, l.body.statement)
 ;
  
  
 /* rule 19 (parallel)
  *
  */
Void rule(State s, Parallel p):
	//let r = new Region:
	s.setLabel("Parallel State") -> 
	s.bodyText.removeAll(s.bodyText) ->
 	//s.regions.add(r) ->
 	ruleParallelRecursive(s, p.list)
;

Void ruleParallelRecursive(State parent, List[Statement] statements):
	let r = new Region:
	let s = new State:
	parent.regions.add(r) ->
	r.states.add(s) ->
	
	((statements.size > 1) ? ruleParallelRecursive(parent, statements.withoutFirst()) : s) ->
	
	setJavaBodyContents(s, statements.first())
;

/*
 * rule 23 (sequence)
 */
 Void rule(State s, Sequence seq):
 	let r = new Region:
 	let initial = new State:
 	s.bodyText.removeAll(s.bodyText) ->
	s.setLabel("Sequence State") ->
	s.regions.add(r) ->
	initial.setIsInitial(true) ->
	r.states.add(initial) ->
	
	// call recursively
	(seq.list.size > 1) ? ruleSequenceRecursive(r, initial, seq.list.withoutFirst()) : s
	->
		// body of first sequence state
	setJavaBodyContents(initial, seq.list.first()) 
;

Void ruleSequenceRecursive(Region region, State previous, List[Statement] statements):
	let s = new State:
	let t = new Transition:
	region.states.add(s) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	t.setSourceState(previous) ->
	t.setTargetState(s) ->
		
	((statements.size > 1) ? 
	// if more than 1 element we have to handle another one
	ruleSequenceRecursive(region, s, statements.withoutFirst())  
	: 
	// else finished
	s.setIsFinal(true)) ->
	
	setJavaBodyContents(s, statements.first())
;


Void rule(State s, Block b):
	rule(s, (Parallel) b.statement)
;

 
 /*
  * helping method
  * realises a new await case
  */
 Void handleAwaitCase(AbortCaseSingle ac, List[State] fstates, State initState):
 	let finalState = new State:
	let trans = new Transition:
	trans.setType(TransitionType::STRONGABORT) ->
	trans.setSourceState(initState) ->
	trans.setTargetState(finalState) ->
	//trans.setTrigger(ac.delayExpr) ->
	//finalState.setBodyContents(ac.statement) ->
	fstates.add(finalState)
 ;
 
 

 
emf::EObject castToEMF(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

ecore::EObject castToEcore(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

Void setJavaBodyContents(State s, emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.setBodyReference(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;



 /*
  * Convenient methods
  */

// extracts all signals from InterfaceSignalDecl and adds them to the state
Void extractSignals(InterfaceSignalDecl decl, State s):
	let copy = (List[ISignal]) clone(decl.signals):
	copy.addSignalToState(s)
;

// adds sig to the state, does some processing
Void addSignalToState(Signal sig, State st):
	switch {
		case Input.isInstance(sig) : (sig.setIsInput(true) ->  sig.setIsOutput(false))
		case Output.isInstance(sig) : (sig.setIsInput(false) ->  sig.setIsOutput(true))
		case InputOutput.isInstance(sig) : (sig.setIsInput(true) ->  sig.setIsOutput(true))
   		default : sig //no information about input/output
	} ->
	st.signals.add(sig)
;

/*List[ISignal] copyList(List[ISignal] list):
	let copy = {}:
	copy.addAll(list)
;*/