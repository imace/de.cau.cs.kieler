import ecore;
import synccharts;
import annotations;
import expressions;
import utilities;
import esterel;

extension feature;
 
/*
 * initial test transformation

Void initial(State s):
	let r = new Region:
	let ns = new State:
	r.states.add(ns) ->
	s.regions.add(r) ->
	ns.setLabel("InnerStateXY") ->
	appendTransformation("initial", ns) ->
	s
;
 */

 
 
 Void initial(State s, emf::EObject e):
 	let m = ((emf::EObject) s.bodyContents):
 	let mo = (Program) castToEMF(m):
 	let selfTrans = new Transition:
 	ruleModule(s, mo.module.get(0)) -> 
 	s
;

/*
Void sandbox():
	let l = new Loop:
	l
;
*/

/*
 * rule 1 (module)
 */ 
Void ruleModule(State s, Module m):
	let statement = m.modBody.statement.get(0):
	let newState = new State:
	let r = new Region:
	s.regions.add(r) ->
	s.setLabel(m.name) ->
	r.states.add(newState) ->
	newState.setIsInitial(true) ->
	newState.setIsFinal(true) -> 
	// TODO set singals
	// TODO set body content
	setJavaBodyContents(newState, statement) ->
	appendNextTransformation(newState, statement)
;


/*
 * rule 3 (halt)
 */
Void ruleHalt(Region r):
	let s = new State:
	s.setId("s1") ->
	s.setIsInitial(true) ->
	r.states.add(s)
;

/*
 * rule 5 (abort)

 Void ruleAbort(State s):
 	let a = (Abort) castToEMF(s.bodyContents):
 	let r = new Region:
 	let initState = new State:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	let caseStates = {}:
 	s.setLabel("Abort State") ->
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	
 	// connect initial and final state in case of a normal termination
 	toFinalTrans.setSourceState(initState) ->
 	toFinalTrans.setTargetState(finalState) ->
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	initState.setIsInitial(true) ->
 	finalState.setIsFinal(true) ->
 	
 	// handle cases (only for ABRO currently)
 	handleAbort(r, initState, a) ->
 	setJavaBodyContents(initState, a.statement) ->
 	appendNextTransformation(a.statement, initState) ->
 	a
 ;
 */
 
 /*
 * rule 5 (abort)
 */
 Void rule(State s, Abort a):
 	let r = new Region:
 	let initState = new State:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	let caseStates = {}:
 	s.setLabel("Abort State") ->
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	
 	// connect initial and final state in case of a normal termination
 	toFinalTrans.setSourceState(initState) ->
 	toFinalTrans.setTargetState(finalState) ->
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	initState.setIsInitial(true) ->
 	finalState.setIsFinal(true) ->
 	
 	// handle cases (only for ABRO currently)
 	handleAbort(r, initState, a) ->
 	setJavaBodyContents(initState, a.statement) ->
 	appendNextTransformation(initState, (emf::EObject) a.statement) ->
 	a
 ;
 
Void handleAbort(Region parent, State s, Abort a):
	let body = (AbortInstance) a.body:
	let final = new State:
	let t = new Transition:
	parent.states.add(final) ->
	final.setIsFinal(true) ->
	t.setSourceState(s) ->
	t.setTargetState(final) ->
	t.setType(TransitionType::STRONGABORT) ->
	//t.setTrigger(body.delay.event.signal)
	s	
;

/*
 * rule 8 (await)
 */
 Void ruleAwait(Region r, Await a):
 	let initState = new State:
 	let caseStates = {}:
 	AwaitCase.isInstance(a.body) ? 
 	// handle cases
 	((AwaitCase) a.body).cases.handleAwaitCase(caseStates, initState) : "" ->
 	//: a ->
 	// handle instance
 	//->
 	r.states.add(initState) ->
 	r.states.addAll(caseStates)
 ;
 
 
 /*
  * rule 12 (emit)
  */
Void ruleEmit(Region r, Emit e):
	let initS = new State:
	let finalS = new State:
	let emitTrans = new Transition:
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	emitTrans.setSourceState(initS) ->
	emitTrans.setTargetState(finalS) ->
	// TODO emit emitTrans.setEffects(e.signal + effect)
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS)
;

/*
 * rule 17 (loop)

 Void ruleLoop(State s):
 	let r = new Region:
 	let loopState = new State:
 	let selfTrans = new Transition:
 	let l = (Loop) castToEMF(s.bodyContents):
 	s.setLabel("Loop_State") ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.setSourceState(loopState) ->
 	selfTrans.setTargetState(loopState) ->  
 	
 	loopState.outgoingTransitions.add(selfTrans) ->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
 	appendNextTransformation(l.body.statement, loopState)
	// 	loopState.setBodyContents(l.body) ->
 ;
  */
  
  Void rule(State s, Loop l):
 	let r = new Region:
 	let loopState = new State:
 	let selfTrans = new Transition:
 	s.setLabel("Loop_State") ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.setSourceState(loopState) ->
 	selfTrans.setTargetState(loopState) ->  
 	
 	loopState.outgoingTransitions.add(selfTrans) ->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
 	appendNextTransformation(loopState, (emf::EObject) l.body.statement)
	// 	loopState.setBodyContents(l.body) ->
  ;
  
  
 /* rule 19 (parallel)
  *

Void ruleParallel(State parent):
	parent.setLabel("Parallel State") 
 	//p.list.handleParallelStatement(parent)
;
  */
  
  Void rule(State parent, Parallel p):
	parent.setLabel("Parallel State") 
 	//p.list.handleParallelStatement(parent)
;

/*
 * rule 23 (sequence)

Void ruleSequence(Region r, Sequence s):
	s
;
 */
 Void rule(State s, Sequence seq):
	s.setLabel("Sequence State")
;
//transforms sequence
State transSequence (State s, Statement statement):
	//checks wether there is a sequence-operator
	Sequence.isInstance(statement)?
		(let i = new State:
		let r = new Region:
		i.setId("s1") ->
		s.setLabel("Sequence") ->
		i.setIsInitial(true) ->
		r.states.add(i) ->
		s.regions.add(r) ->
		(transSequenceRecursive(r, i,((Sequence)statement).list, 2)).setIsFinal(true))
		:s
	;//(transSequence(s, statement));
	
//recursive helpfunction for sequence transformation
State transSequenceRecursive (Region r, State prev, List[Statement] statement, Integer id):
	let s1 = new State:
	let t = new Transition:
	s1.setId("s"+id) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	r.states.add(s1)->
	Sequence.isInstance(statement.first())?
		(t.setSourceState(transSequenceRecursive(r,prev, ((Sequence)statement.first()).list, (id+1)))->
		t.setTargetState(s1) ->
		s1)
	:
		(t.setSourceState(prev)->
		t.setTargetState(s1)->
		s1);	

/*
 * helper method
 * add a new region with the specified parallel statement
 */
Void handleParallelStatement(Statement s, State parent):
	let r = new Region:
	let newS = new State:
	newS.setIsInitial(true) ->
	newS.setIsFinal(true) ->
	r.states.add(newS) ->
	parent.regions.add(r)	
	// TODO newS.setBodyContents(s. ka
;
 
 /*
  * helping method
  * realises a new await case
  */
 Void handleAwaitCase(AbortCaseSingle ac, List[State] fstates, State initState):
 	let finalState = new State:
	let trans = new Transition:
	trans.setType(TransitionType::STRONGABORT) ->
	trans.setSourceState(initState) ->
	trans.setTargetState(finalState) ->
	//trans.setTrigger(ac.delayExpr) ->
	//finalState.setBodyContents(ac.statement) ->
	fstates.add(finalState)
 ;
 
 
 
appendNextTransformation(State s, emf::EObject esterel):
	appendTransformation("rule", s, esterel)
	/*switch {
		case Abort.isInstance(esterel): appendTransformation("ruleAbort", s, esterel)
		case Await.isInstance(esterel): appendTransformation("ruleAwait", s, esterel)
		case Emit.isInstance(esterel): appendTransformation("ruleEmit", s, esterel)
		case Loop.isInstance(esterel): appendTransformation("ruleLoop", s, esterel)
		case Nothing.isInstance(esterel): appendTransformation("ruleNothing",  s, esterel)
		case Pause.isInstance(esterel): appendTransformation("rulePause", s, esterel)
		case Sequence.isInstance(esterel): appendTransformation("ruleSequence", s, esterel)
		default: appendTransformation("ruleAbort", s, esterel)
	}*/
;
 
 
/*
 * passes information about a new transformation to the data component.
 */
Void appendTransformation(String str, State syncModel, emf::EObject estModel):
       JAVA  de.cau.cs.kieler.esterel.transformation.Est2SyncDataComponent.appendTransformation(java.lang.String,
de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;
 
emf::EObject castToEMF(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.TransformationHelper.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

ecore::EObject castToEcore(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.TransformationHelper.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

Void setJavaBodyContents(State s, emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.TransformationHelper.setBodyContents(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;

 
