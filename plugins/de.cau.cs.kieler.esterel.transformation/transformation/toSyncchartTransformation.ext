import ecore;
import annotations;
import expressions;
import synccharts;
import utilities;
import esterel;

extension feature;
extension org::eclipse::xtend::util::stdlib::cloning;
 
 
/*
 * Some notes: 
 * - keep in mind to add states to their parents first, so potential transitions 
 *   generate a notification which is handled
 * - if the parent state has a label, do not overwrite it
 * - if automatic recursion is desired, use the recursiveRule()
 * - remember to pass the GLOBALVAR "recursive" to the XtendFacade
 * - add / remove bodytext!
 */
 
 
/*
 
   */
   
  Void sandbox(State s):
  let t = new Transition:
  let e = new Effect:
  let de = new DelayExpr:
 // ((synccharts::Action)t).setLabel("foobat") ->
  // addSelfLoop(s)->

s	
  ;




Void recursiveRule(State s, emf::EObject e):
	((boolean) GLOBALVAR recursive) ? rule(s, e) : s
	-> s
;
 
// just dummy for xtend 
Void rule(State s, emf::EObject noneed):
	s.setLabel("damn you")
;
 

// rule for Program, forwards the first module
Void rule(State s, Program p):
 	let m = ((emf::EObject) s.bodyReference):
 	let mo = (Program) castToEMF(m):	
	rule(s, mo.modules.get(0))
;

/*
 * rule 1 (module)
 */ 
Void rule(State s, Module m):
	let statement = m.body.statements.get(0):
	removeBodyText(s) ->
	// always set label here!
	s.setLabel(m.name) ->
	s.setIsInitial(true) ->
	s.setIsFinal(true) ->
	// TODO set singals
	m.interface.intSignalDecls.extractSignals(s)->	
	// TODO set body content
	setJavaBodyContents(s, statement) ->
	//appendNextTransformation(newState, statement)
	recursiveRule(s, statement)
;

/*
 * rule 2 (nothing)
 */ 
Void rule(State s, Nothing n):
	let nState = new State:
	let r = new Region:
	s.removeBodyText() ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Nothing State") ->
	r.states.add(nState) ->
	nState.setIsFinal(true) ->
	nState.setIsInitial(true)
;

/*
 * rule 3 (halt)
 */
Void rule(State s, Halt h):
	let r = new Region:
	let ns = new State:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabelIfEmpty("Halt State") ->
	ns.setIsInitial(true) ->
	r.states.add(ns)
;
 
/*
 * rule 4 (pause)
 */
Void rule(State s, Pause p):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	// setup states
	s.removeBodyText() ->
	s.setLabelIfEmpty("Pause State") ->
	s.regions.add(r) ->
	r.states.addAll({initS, finalS}) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	// add transition
	t.setType(TransitionType::STRONGABORT) ->
	t.connectTransition(initS, finalS)
;

 /*
 * rule 5 (abort)
 */
 Void rule(State s, Abort a):
 	let r = new Region:
 	let initState = new State:
 	let caseStates = {}:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	removeBodyText(s) ->
 	s.setLabelIfEmpty("Abort State") ->
 	// add new state
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	// connect initial and final state with of a normal termination
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	toFinalTrans.setPriority(1) ->
	initState.setIsInitial(true) ->
	finalState.setIsFinal(true) ->
	
	// just an instance or cases?
 	(AbortInstance.isInstance(a.body) ?
	 	handleAbortCaseSingle(r, initState, 1,
	 		((AbortInstance)a.body).delay, 
	 		((AbortInstance)a.body).statement)
 	:
 		(toFinalTrans.setPriority(((AbortCase)a.body).cases.size + 1) ->
 		// handle cases (only for ABRO currently)
	 	handleAbortCases(r, initState, 1, ((AbortCase)a.body).cases))
	) -> 	
	// handle abort's body statement
	toFinalTrans.connectTransition(initState, finalState) ->
	setJavaBodyContents(initState, a.statement) ->
	recursiveRule(initState, a.statement)
 ;
		
Void handleAbortCases(Region parent, State source, Integer prio, List[AbortCaseSingle] cases):
	(cases.size > 1) ?
		(handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement) ->
		handleAbortCases(parent, source, prio + 1, cases.withoutFirst()))
		:
		handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement)
;

Void handleAbortCaseSingle(Region parent, State source, Integer prio, DelayExpr expr, Statement body):
	let caseState = new State:
	let trans = new Transition:
	caseState.setIsFinal(true) ->
	parent.states.add(caseState) ->
	
	// create and add transition
	trans.setType(TransitionType::STRONGABORT) ->
	trans.setPriority(prio) ->
	// TODO correct adding of delayevent
	if (expr.event != null  && expr.event.signal != null) then
		trans.setLabel(expr.event.signal.name)
		->
		
	trans.connectTransition(source, caseState) ->
	// set body text
	setJavaBodyContents(caseState, body)  ->
	recursiveRule(caseState, body)
;

/*
 * rule 6 (weak abort)
 */
// TODO

/*
 * rule 7 (assign)
 */
 Void rule(State s, esterel::Assignment assign):
 	let r = new Region:
 	let initS = new State:
 	let finalS = new State:
 	let t = new Transition:
 	let sa = new Assignment:
 	s.removeBodyText() ->
 	// setup states
 	s.setLabelIfEmpty("Assign State") ->
 	s.regions.add(r) ->
 	r.states.addAll({initS, finalS}) ->
 	initS.setIsInitial(true) ->
 	finalS.setIsFinal(true) ->
 	// init transition
 	t.connectTransition(initS, finalS) ->
 	sa.setVariable(assign.var) ->
 	if (assign.expr.expr != null) then
 		sa.setExpression(assign.expr.expr)
 	// TODO assignment
 ;

/*
 * rule 8 (await)
 */
Void rule(State s, Await a):
 	let r = new Region :
 	let initState = new State:
 	let caseStates = {}:
	removeBodyText(s) ->
 	s.setLabelIfEmpty("Await State") ->
 	// add state
 	s.regions.add(r) ->
 	initState.setIsInitial(true) ->
 	r.states.add(initState) ->

 	// just one instance or cases?
	AwaitInstance.isInstance(a.body)?
		handleAwaitCaseSingle(r, initState, 1, 
			((AwaitInstance)a.body).delay, 
			((AwaitInstance)a.body).statement)
	:
		handleAwaitCases(r, initState, 1, ((AwaitCase)a.body).cases)
;
 
// as abort and await cases are equal, we use AbortCaseSingles 
Void handleAwaitCases(Region r, State previous, Integer prio, List[AbortCaseSingle] cases):
	handleAbortCases(r, previous, prio, cases)
;

Void handleAwaitCaseSingle(Region r, State previous, Integer prio, DelayExpr expr, Statement body):
	handleAbortCaseSingle(r, previous, prio, expr, body)
;

 /*
  * rule 12 (emit)
  */
Void rule(State s, Emit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	removeBodyText(s) ->
	s.regions.add(r) ->
	s.setLabel("Emit State") ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.signal) ->
	emission.setNewValue(e.expr.expr) ->
	emitTrans.effects.add(emission) ->
	// add transition to state
	emitTrans.setSourceState(initS) ->
	emitTrans.setTargetState(finalS) ->
	initS.outgoingTransitions.add(emitTrans)
;

/*
 * rule 13 (every)
 */
Void rule(State s, EveryDo e):
	let r = new Region:
	let initS = new State:
	let everyS = new State:
	let initT = new Transition:
	let everyT = new Transition:
	s.removeBodyText() ->
	// setup states
	s.setLabelIfEmpty("Every State") ->
	s.regions.add(r) ->
	r.states.addAll({initS, everyS}) ->
	initS.setIsInitial(true) ->
	// init transitions
	initT.setType(TransitionType::STRONGABORT) ->
	everyT.setType(TransitionType::STRONGABORT) ->
	initT.connectTransition(initS, everyS) ->
	everyT.connectTransition(everyS, everyS) ->
	// TODO Delays
	
	// recursive
	everyS.setJavaBodyContents(e.statement) ->
	everyS.recursiveRule(e.statement)
;


/*
 * rule 17 (loop) & rule 18 (loop each)
 */
Void rule(State s, Loop l):
	let r = new Region:
	let loopState = new State:
 	let selfTrans = new Transition:
 	removeBodyText(s) ->
 	// setup state
	(LoopEach.isInstance(l.end) ? s.setLabelIfEmpty("LoopEach State") 
			: s.setLabelIfEmpty("Loop_State")) ->
 	s.regions.add(r) ->
 	r.states.add(loopState) ->
 	loopState.setIsInitial(true) ->
 	// setup transition
 	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.connectTransition(loopState, loopState) ->
 	
 	if LoopEach.isInstance(l.end) then
 		(selfTrans.setType(TransitionType::STRONGABORT) ->
 		 s) -> // TODO add delay!!)->
 	
 	setJavaBodyContents(loopState, l.body.statement) ->
	recursiveRule(loopState, l.body.statement)
 ;
 

 /* 
  * rule 19 (parallel)
  */
Void rule(State s, Parallel p):
	removeBodyText(s) ->
	s.setLabelIfEmpty("Parallel State") -> 
	
 	ruleParallelRecursive(s, p.list)
;

Void ruleParallelRecursive(State parent, List[Statement] statements):
	// if inner parallel, extract the statements
	(Parallel.isInstance(statements.first()) ? 
		(
		statements.addAll(((Parallel)statements.first()).list) ->
		statements.remove(statements.first()) ->
		ruleParallelRecursive(parent, statements)
		)
	: 
		// else create this state and add it to the parallel region
		(
		let r = new Region:
		let s = new State:
		parent.regions.add(r) ->
		r.states.add(s) ->
		// add this to parallel
		s.setIsFinal(true) ->
		s.setIsInitial(true) ->
		
		if(statements.size > 1) then
			ruleParallelRecursive(parent, statements.withoutFirst()) ->
		
		setJavaBodyContents(s, statements.first()) ->
		recursiveRule(s, statements.first())
		)
	)	
;

/*
 * rule 23 (sequence)
 */
 Void rule(State s, Sequence seq):
 	let r = new Region:
 	let initial = new State:
 	let list = (List[Statement]){}:
 	s.removeBodyText() ->
 	// create initial state
	s.setLabelIfEmpty("Sequence State") ->
	s.regions.add(r) ->
	initial.setIsInitial(true) ->
	r.states.add(initial) ->
	
	// as the grammar generates nested sequences, we flatten it first
	// this is important to conserve order!
	seq.flattenSequence(list) ->
	
	// call recursively
	ruleSequenceRecursive(r, initial, list.withoutFirst()) ->
	 
	// process body of first sequence state
	setJavaBodyContents(initial, list.first()) ->
	recursiveRule(initial, list.first())
	
;

Void flattenSequence(Statement s, List list):
	Sequence.isInstance(s) ? (
		(Sequence)s).list.flattenSequence(list) 
		:
		(list.add(s))
;

Void ruleSequenceRecursive(Region region, State previous, List[Statement] statements):
	let s = new State:
	let t = new Transition:
	// create the new state and add to the sequence chain
	region.states.add(s) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	t.connectTransition(previous, s) ->
		
	(((statements.size > 1) ? 
	// if more than 1 element we have to handle another one
	ruleSequenceRecursive(region, s, statements.withoutFirst())  
	: 
	// else finished and the last one is a final state!
	s.setIsFinal(true)))
	
	->
	setJavaBodyContents(s, statements.first()) ->
	recursiveRule(s, statements.first())
;


/*
	omit the block, theres a parallel in it!
*/
Void rule(State s, Block b):
	rule(s, (Parallel) b.statement)
;


 
emf::EObject castToEMF(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

ecore::EObject castToEcore(emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.castToEObjcet(org.eclipse.emf.ecore.EObject)
;

Void setJavaBodyContents(State s, emf::EObject o):
	JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.setBodyReference(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;




 /*
  * Convenient methods
  */

// extracts all signals from InterfaceSignalDecl and adds them to the state
Void extractSignals(InterfaceSignalDecl decl, State s):
	let copy = (List[ISignal]) clone(decl.signals):
	if copy.size > 0 then
		copy.addSignalToState(s)
;

// adds sig to the state, does some processing
Void addSignalToState(Signal sig, State st):
	switch {
		case Input.isInstance(sig) : (sig.setIsInput(true) ->  sig.setIsOutput(false))
		case Output.isInstance(sig) : (sig.setIsInput(false) ->  sig.setIsOutput(true))
		case InputOutput.isInstance(sig) : (sig.setIsInput(true) ->  sig.setIsOutput(true))
   		default : sig //no information about input/output
	} ->
	st.signals.add(sig)
;

// connects a transition to the two passed states
Void connectTransition(Transition t, State source, State target):
	t.setSourceState(source) ->
	t.setTargetState(target) ->
	source.outgoingTransitions.add(t)
;

// removes ALL !! body text, set state type to NORMAL
Void removeBodyText(State s):
 	s.bodyText.removeAll(s.bodyText) ->
 	s.setType(StateType::NORMAL)
;

// only set the label if there's no previous label
Void setLabelIfEmpty(State s, String label):
	(s.label.trim().length == 0) ? s.setLabel(label) : s
;

/*List[ISignal] copyList(List[ISignal] list):
	let copy = {}:
	copy.addAll(list)
;*/