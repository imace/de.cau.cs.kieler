import esterel;
import synccharts;

//starts the transformation of the Esterel-program
transformEsterel(Program p):
	let r = new Region: 
	transModule (r,p.module.first()) ->
	r;

//transforms a Module
//@r: rootregion of the syncChart
//@m: Esterel-module, source of transformation
transModule(Region r, Module m):
	let s = new State:
	let ri = new Region:
	let i = new State:
	//module name -> SnycChart name
	s.setId("s1") ->
	i.setId("s1") ->
	s.setLabel(m.name)->
	//transform interface if there is one
	m.modInt == null?
		s
	:
		s.setSignals(transIntSignalDecl(m.modInt.intSignalDecl)) ->
	//configure inner macrostate an start transformation of module body
	i.setIsInitial(true) ->
	i.setIsFinal(true) ->
	transStatement(i,m.modBody.statement.first()) ->
	//link regions and states
	ri.innerStates.add(i) ->
	s.regions.add(ri) ->
	r.innerStates.add(s) ->
	s;

//transforms a Signal Declaration
List[synccharts::Signal] transIntSignalDecl(List[SignalDecl] sigDec):
	let list = {}:
	sigDec.size == 1 ?
		transSignalList (sigDec.first(), list, sigDec.first().signal) 
	:
		transSignalList (sigDec.first(), list, sigDec.first().signal).union(transIntSignalDecl(sigDec.withoutFirst())).flatten();

//transforms a Signal List	
List[synccharts::Signal] transSignalList (SignalDecl sigDec, List[synccharts::Signal] sSigList,List[esterel::Signal] eSigList):
	let sig = new synccharts::Signal:
	// set the properties of the Signal
	sig.setName(eSigList.first().name) -> 
	switch {
		case Input.isInstance(sigDec) : (sig.setIsInput(true) ->  sig.setIsOutput(false))
		case Output.isInstance(sigDec) : (sig.setIsInput(false) ->  sig.setIsOutput(true))
		case InputOutput.isInstance(sigDec) : (sig.setIsInput(true) ->  sig.setIsOutput(true))
   		default : sig //no information about input/output
	} ->
	// transform channel
	eSigList.first().channel == null?
		sig
	:
		transChannelType(sig, eSigList.first())
	->
	// add Signal to syncchart and transform next one
	eSigList.size == 1 ? 
	sSigList.add(sig).flatten():
	transSignalList (sigDec, sSigList.add(sig).flatten(), eSigList.withoutFirst());
	
transChannelType(synccharts::Signal ssig, esterel::Signal esig):
	switch{
		case esig.channel.type.type == "integer" : ssig.setType(ValueType::INTEGER)
		case esig.channel.type.type == "boolean" : ssig.setType(ValueType::BOOL)
		case esig.channel.type.type == "float" : ssig.setType(ValueType::FLOAT)
		default: 	(ssig.setType(ValueType::HOST) ->
					ssig.setHostType(esig.channel.type.type))
	} ->
	esig.channel.type.func == null? 
	ssig
	:
	ssig.setHostCombineOperator(esig.channel.type.func.toString().toString());
	
//starts the transformation of a statement -> transform parallel
State transStatement (State s, Statement statement):
	//checks wether there is a parallel-operator
	Parallel.isInstance(statement)?
		(s.setLabel("Parallel") -> (transStateRecursive(s, ((Parallel)statement).list)))
	:
		(transSequence(s, statement));
	
//recursive helpfunction for parallel transformation
State transStateRecursive (State s, List[Statement] statement):
	Parallel.isInstance(statement.first())?
		(transStateRecursive(s,((Parallel)statement.first()).list))
	:
		(let r = new Region:
		let s1 = new State:
		s1.setId("s1") ->
		s1.setIsInitial(true) ->
		s1.setIsFinal(true) ->
		transSequence(s1,statement.first())->
		r.innerStates.add(s1) ->
		s.regions.add(r))->
	statement.size > 1?
		transStateRecursive(s,statement.withoutFirst())
	:
		s;
	
//transforms sequence
State transSequence (State s, Statement statement):
	//checks wether there is a sequence-operator
	Sequence.isInstance(statement)?
		(let i = new State:
		let r = new Region:
		i.setId("s1") ->
		s.setLabel("Sequence") ->
		i.setIsInitial(true) ->
		r.innerStates.add(i) ->
		s.regions.add(r) ->
		(transSequenceRecursive(r, i,((Sequence)statement).list, 2)).setIsFinal(true))
	:
		(transAtomicStatement (s, statement));//(transSequence(s, statement));
	
//recursive helpfunction for sequence transformation
State transSequenceRecursive (Region r, State prev, List[Statement] statement, Integer id):
	let s1 = new State:
	let t = new Transition:
	s1.setId("s"+id) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	r.innerStates.add(s1)->
	Sequence.isInstance(statement.first())?
		(t.setSourceState(transSequenceRecursive(r,prev, ((Sequence)statement.first()).list, (id+1)))->
		t.setTargetState(s1) ->
		transAtomicStatement (s1, statement.withoutFirst().first())->
		s1)
	:
		(t.setSourceState(prev)->
		t.setTargetState(s1)->
		transAtomicStatement (prev, statement.first())->
		transAtomicStatement (s1, statement.withoutFirst().first())->
		s1);	
	
//transforms an atomic statement
transAtomicStatement (State s, Statement atomic):
	switch {
		case Abort.isInstance(atomic): transAbortStatement(s, (Abort) atomic)
		case Assignment.isInstance(atomic): transAssignmentStatement(s, (Assignment) atomic)
		case Await.isInstance(atomic): transAwaitStatement(s, (Await)atomic)
		case Block.isInstance(atomic): transBlockStatement(s, (Block) atomic)
		case Do.isInstance(atomic): transDoStatement(s, (Do) atomic)
		case Emit.isInstance(atomic): transEmitStatement(s, (Emit) atomic)
		case EveryDo.isInstance(atomic): transEveryStatement(s, (EveryDo) atomic)
		case Exit.isInstance(atomic): transExitStatement(s, (Exit) atomic)
		case Halt.isInstance(atomic): transHaltStatement(s, (Halt) atomic)
		case IfTest.isInstance(atomic): transIfStatement(s, (IfTest) atomic)
		case LocalSignalDecl.isInstance(atomic): transLocalSignal(s, (LocalSignalDecl) atomic)
		case Loop.isInstance(atomic): transLoopStatement(s,(Loop) atomic)
		case Nothing.isInstance(atomic): transNothingStatement(s, (Nothing) atomic)
		case Pause.isInstance(atomic): transPauseStatement(s, (Pause) atomic)
		case Present.isInstance(atomic): transPresent(s, (Present) atomic)
		case Suspend.isInstance(atomic): transSuspend(s, (Suspend) atomic)
		case Sustain.isInstance(atomic): transSustain(s, (Sustain) atomic)
		case Trap.isInstance(atomic): transTrap(s, (Trap) atomic)
		case esterel::Variable.isInstance(atomic): transLocalVariable(s, (esterel::Variable) atomic)
		// default transforms unknown statements 
		default: 	(s.setType(StateType::TEXTUAL) ->
					s.setBodyText(atomic.toString().toString()) ->
					s.setLabel("Unknown_Statement"))
	};
	
//transforms abort
transAbortStatement(State s, Abort abort):
	let s1 = new State:
	let r = new Region:
	s1.setId("s1") ->
	s.setLabel("Abort") ->
	s1.setIsInitial(true) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	transStatement(s1, abort.statement) ->
	AbortInstance.isInstance(abort.body)?
		transAwaitCaseSingle(r, s1, 1, ((AbortInstance)abort.body).delay, ((AbortInstance)abort.body).statement)
	:
		(let f = new State:
		let tf = new Transition:
		transAwaitCaseHelp(r, s1, 1, ((AbortCase)abort.body).cases) ->
		f.setIsFinal(true) ->
		r.innerStates.add(f) ->
		tf.setSourceState(s1) ->
		tf.setTargetState(f) ->
		tf.setType(TransitionType::NORMALTERMINATION) ->
		tf.setPriority(((AbortCase)abort.body).cases.size + 1))	;

//transforms assign
transAssignmentStatement(State s, Assignment assign):
	let i = new State:
	let s1 = new State:
	let t = new Transition:
	let r = new Region:
	i.setId("s1") ->
	s1.setId("s2") ->
	s.setLabel("Assignment") ->
	i.setIsInitial(true) ->
	s1.setIsFinal(true) ->
	t.setSourceState(i) ->
	t.setTargetState(s1) ->
	t.setIsImmediate(true) ->
	t.setTriggersAndEffects(transDataExpr(assign.expr)) -> 
	r.innerStates.add(i) ->
	r.innerStates.add(s1) ->
	s.regions.add(r);

//transforms await
transAwaitStatement(State s, Await await):
	let r = new Region:
	let s1 = new State:
	s1.setId("s1") ->
	s.setLabel("Await") ->
	s1.setIsInitial(true) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	AwaitInstance.isInstance(await.body)?
		transAwaitCaseSingle(r, s1, 1, ((AwaitInstance)await.body).delay, ((AwaitInstance)await.body).statement)
	:
		transAwaitCaseHelp(r, s1, 1, ((AwaitCase)await.body).cases)
	;
	
//help function for transformation of await-cases
State transAwaitCaseHelp(Region r, State source, Integer prio, List[AbortCaseSingle] list):
	list.size > 1?
		(transAwaitCaseSingle(r, source, prio, list.first().delay, list.first().statement) ->
		transAwaitCaseHelp(r, source, (prio+1), list.withoutFirst()))
	:
		transAwaitCaseSingle(r, source, prio, list.first().delay, list.first().statement) ;
	
//help function for transformation of await-cases
transAwaitCaseSingle(Region r, State source, Integer prio, DelayExpr delay, Statement statement):
	let t = new Transition:
	let s1 = new State:
	let t = new Transition:
	s1.setId("s"+(prio+1)) ->
	s1.setIsFinal(true) ->
	t.setSourceState(source) ->
	t.setTargetState(s1) ->
	t.setType(TransitionType::STRONGABORT) ->
	r.innerStates.add(s1) ->
	t.setPriority(prio) ->
	t.setTriggersAndEffects(transDelayExpr(delay)) -> 
	statement == null ?
		s1
	:
		((transStatement(s1, statement)) -> s1);
	
//transforms block
transBlockStatement(State s, Block block):
	transStatement(s, block.statement);
	
//transforms do
transDoStatement(State s, Do do):
	let s1 = new State:
	let r = new Region:
	s1.setId("s1") ->
	s1.setIsInitial(true) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	transStatement(s1,do.statement) ->
	do.endWatch == null?
		(let f = new State:
		let tf = new Transition:
		f.setId("s2") ->
		s.setLabel("Do_Upto") -> 
		r.innerStates.add(f) ->
		f.setIsFinal(true) ->
		tf.setSourceState(s1) ->
		tf.setTargetState(f) ->
		tf.setType(TransitionType::STRONGABORT) ->
		tf.setTriggersAndEffects(transDelayExpr(do.endUp.expr))
		)
	:
		(let f = new State:
		let tf = new Transition:
		let n = new State:
		let tn = new Transition:
		f.setId("s2") ->
		n.setId("s3") ->
		s.setLabel("Do_Watching") ->
		r.innerStates.add(f) ->
		f.setIsFinal(true) ->
		tf.setSourceState(s1) ->
		tf.setTargetState(f) ->
		tf.setType(TransitionType::STRONGABORT) ->
		r.innerStates.add(n) ->
		n.setIsFinal(true) ->
		tn.setSourceState(s1) ->
		tn.setTargetState(n) ->
		tn.setType(TransitionType::NORMALTERMINATION) ->
		tn.setPriority(2) ->
		tf.setTriggersAndEffects(transDelayExpr(do.endWatch.delay)) -> 
		((DoWatching)do.endWatch).end == null
		?
			f
		: 
			transStatement(f, ((DoWatching)do.endWatch).end.statement )		
		)
	;
	
//transforms emit
transEmitStatement(State s, Emit emit):
	let i = new State:
	let s1 = new State:
	let t = new Transition:
	let r = new Region:
	i.setId("s1") ->
	s1.setId("s2") ->
	s.setLabel("Emit") ->
	i.setIsInitial(true) ->
	s1.setIsFinal(true) ->
	t.setIsImmediate(true) ->
	t.setSourceState(i) ->
	t.setTargetState(s1) ->
	emit.signal == null?
	t:
	(t.setTriggersAndEffects("# / "+emit.signal.name)) -> 
	s.regions.add(r) ->
	r.innerStates.add(i) ->
	r.innerStates.add(s1);
	
//transforms every
transEveryStatement(State s, EveryDo every):
	let r = new Region:
	let t2 = new Transition:
	let t3 = new Transition:
	let s1 = new State:
	let s2 = new State:
	s1.setId("s1") ->
	s2.setId("s2") ->
	s.setLabel("Every") ->
	s1.setIsInitial(true) ->
	t2.setSourceState(s1) ->
	t2.setTargetState(s2) ->
	t2.setType(TransitionType::STRONGABORT) ->
	t2.setTriggersAndEffects(transDelayExpr(every.delay)) ->
	t3.setSourceState(s2) ->
	t3.setTargetState(s2) ->
	t3.setType(TransitionType::STRONGABORT) ->
	t3.setTriggersAndEffects(transDelayExpr(every.delay)) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	r.innerStates.add(s2) ->
	transStatement(s2, every.statement);
	
//transforms exit
transExitStatement(State s, Exit exit):
	let i = new State:
	let s1 = new State:
	let t = new Transition:
	let r = new Region:
	i.setId("s1") -> 
	s1.setId("s2") ->
	s.setLabel("Exit") ->
	i.setIsInitial(true) ->
	t.setIsImmediate(true) ->
	t.setSourceState(i) ->
	t.setTargetState(s1) ->
	t.setTriggersAndEffects("# / "+transExitEmission(exit)) ->
	s.regions.add(r) ->
	r.innerStates.add(i) ->
	r.innerStates.add(s1);
	
//transforms halt
transHaltStatement(State s, Halt halt):
	let i = new State:
	let s1 = new State:
	let t = new Transition:
	let r = new Region:
	i.setId("s1") ->
	s1.setId("s2") ->
	s.setLabel("Halt_"+s.id) ->
	i.setIsInitial(true) ->
	t.setIsImmediate(true) ->
	t.setTriggersAndEffects("#") ->
	t.setSourceState(i) ->
	t.setTargetState(s1) ->
	s.regions.add(r) ->
	r.innerStates.add(i) ->
	r.innerStates.add(s1);
	
//transforms if
transIfStatement(State s, IfTest iftest):
	let c = new State:
	let i = new State:
	let t = new Transition:
	let r = new Region:
	let s1 = new State:
	let t1 = new Transition:
	c.setId("s1") ->
	i.setId("s2") ->
	s1.setId("s3") ->
	s.setLabel("If") ->
	i.setIsInitial(true) ->
	c.setType(StateType::CONDITIONAL) ->
	t.setIsImmediate(true) ->
	t.setTriggersAndEffects("#") ->
	t.setSourceState(i) ->
	t.setTargetState(c) ->
	s.regions.add(r) ->
	r.innerStates.add(i) ->
	r.innerStates.add(c) ->
	//here the if/else cases are transformed
	s1.setIsFinal(true) ->
	r.innerStates.add(s1) ->
	t1.setIsImmediate(true) ->
	t1.setTriggersAndEffects("#") ->
	t1.setSourceState(c) ->
	t1.setTargetState(s1) ->
	t1.setTriggersAndEffects(transDataExpr(iftest.expr)) ->
	// transform thenPart, if it exists
	iftest.thenPart == null?
		s1
	:
		transStatement(s1, iftest.thenPart.statement) ->
	// transform elsif, if it exists
	iftest.elseIf == null?
		// transform else, when no elsif
		(iftest.elsePart == null?
			s1
		:
			(let sn = new State:
			let tn = new Transition:
			sn.setId("s4") ->
			sn.setIsFinal(true) ->
			tn.setIsImmediate(true) ->
			tn.setTriggersAndEffects("#") ->
			tn.setSourceState(c) ->
			tn.setTargetState(sn) ->
			r.innerStates.add(sn) ->
			tn.setPriority(2) ->
			transStatement(sn, iftest.elsePart.statement)
			)
		)
	:
		// transform else, when there are also elsif
		(iftest.elsePart == null?
			transElsIf(r, c, 2, iftest.elseIf.elsif)
		:
			(let sn = new State:
			let tn = new Transition:
			let prio = transElsIf(r, c, 2, iftest.elseIf.elsif):
			sn.setId("s4") ->
			sn.setIsFinal(true) ->
			tn.setIsImmediate(true) ->
			tn.setTriggersAndEffects("#") ->
			tn.setSourceState(c) ->
			tn.setTargetState(sn) ->
			r.innerStates.add(sn) ->
			tn.setPriority(prio+1) ->
			transStatement(sn, iftest.elsePart.statement)
			)
		)
	;
	
	
// transforms the elsif part and returns the highest prioritie used
Integer transElsIf(Region r, State c, Integer prio, List[ElsIf] elsif):
	let t = new Transition:
	let s = new State:
	s.setId("s"+(prio+3)) ->
	s.setIsFinal(true) ->
	r.innerStates.add(s) ->
	t.setIsImmediate(true) ->
	t.setTriggersAndEffects("#") ->
	t.setSourceState(c) ->
	t.setTargetState(s) ->
	t.setPriority(prio) ->
	t.setTriggersAndEffects(transDataExpr(elsif.first().expr)) -> 
	elsif.first().thenPart == null?
		s
	:
		transStatement(s, elsif.first().thenPart.statement) ->
	elsif.size >1?
		transElsIf(r, c, prio+1, elsif.withoutFirst())
	:
		prio	
	;
	
//transforms local signal
transLocalSignal(State s, LocalSignalDecl localSignal):
	let s1 = new State:
	let r = new Region:
	s1.setId("s1") ->
	s1.setIsInitial(true) ->
	s1.setIsFinal(true) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	s.setLabel("Local_Signal") ->
	transLocalSignalList(s, ((LocalSignal)localSignal.signalList).signal) ->	
	transStatement(s1, localSignal.statement);

//help function for local signal transformation
State transLocalSignalList(State s, List[Signal] list):
	let sig = new synccharts::Signal :
	sig.setName(list.first().name) ->
	list.first().channel == null?
		sig
	:
		transChannelType(sig, list.first())
	->
	s.signals.add(sig) ->
	list.size > 1?
	transLocalSignalList(s, list.withoutFirst()):
	s;
	
//transforms loop
transLoopStatement(State s, Loop loop):
	let s1 = new State:
	let tl = new Transition:
	let r = new Region:
	s1.setId("s1") ->
	s1.setIsInitial(true) ->
	tl.setSourceState(s1) ->
	tl.setTargetState(s1) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	transStatement(s1, loop.body.statement)->
	LoopEach.isInstance(loop.end)?
	(s.setLabel("Loop_Each") ->
	tl.setType(TransitionType::STRONGABORT) ->
	tl.setTriggersAndEffects(transDelayExpr(((LoopDelay)loop.end).delay))): 
	(s.setLabel("Loop") ->
	tl.setType(TransitionType::NORMALTERMINATION));	

//transforms nothing-statement
transNothingStatement(State s, Nothing nothing):
	let i = new State:
	let s1 = new State:
	let t = new Transition:
	let r = new Region:
	i.setId("s1") ->
	s1.setId("s2") ->
	s.setLabel("Nothing") ->
	i.setIsInitial(true) ->
	s1.setIsFinal(true) ->
	t.setIsImmediate(true) ->
	t.setTriggersAndEffects("#") ->
	t.setSourceState(i) ->
	t.setTargetState(s1) ->
	s.regions.add(r) ->
	r.innerStates.add(i) ->
	r.innerStates.add(s1);

//transforms pause
transPauseStatement(State s, Pause pause):
	let s1 = new State:
	let f = new State:
	let tf = new Transition:
	let r = new Region:
	s1.setId("s1") ->
	f.setId("s2") ->
	s.setLabel("Pause") ->
	s1.setIsInitial(true) ->
	f.setIsFinal(true) ->
	tf.setSourceState(s1) ->
	tf.setTargetState(f) ->
	tf.setType(TransitionType::STRONGABORT) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	r.innerStates.add(f);

//transforms present
transPresent(State s, Present present):
	let i = new State:
	let s1 = new State:
	let f = new State:
	let t = new Transition:
	let tf = new Transition:
	let r = new Region:
	s.setLabel("Present") ;
	
transSuspend(State s, Suspend suspend):
	let a = new Action:
	let s1 = new State:
	let r = new Region:
	s1.setId("s1") ->
	s.setLabel("Suspend") ->
	s1.setIsInitial(true) ->
	s1.setIsFinal(true) ->
	a.setTriggersAndEffects(transDelayExpr(suspend.delay)) ->
	s1.setSuspensionTrigger(a) ->
	transStatement(s1, suspend.statement) ->
	s.regions.add(r) ->
	r.innerStates.add(s1);
	
transSustain(State s, Sustain sustain):
	let s1 = new State:
	let r = new Region:
	let t = new Transition:
	s1.setId("s1") ->
	s.setLabel("Sustain") ->
	s1.setIsInitial(true) ->
	t.setSourceState(s1) ->
	t.setTargetState(s1) ->
	t.setType(TransitionType::STRONGABORT) ->
	t.setTriggersAndEffects("/ "+sustain.signal.name) -> 
	s.regions.add(r) ->
	r.innerStates.add(s1);
	
transTrap(State s, Trap trap):
	let traphalt = new synccharts::Signal:
	let s1 = new State:

	//normal termination
	let sf = new State:
	let tf = new Transition:
	//halt branch
	let sh = new State:
	let th = new Transition:
	//exception branch
	let se = new State:
	let te = new Transition:
	let r = new Region:
	s1.setId("s1") ->
	sf.setId("s2") ->
	sh.setId("s3") ->
	se.setId("s4") ->
	s.setLabel("Trap") ->
	traphalt.setName("traphalt") ->
	s.signals.add(traphalt) ->
	//s.signals.union(transTrapList(trap.trapDeclList.trapDecl)) ->
	//halt branch
	th.setPriority(1) ->
	th.setSourceState(s1) ->
	th.setTargetState(sh) ->
	th.setTriggersAndEffects("# "+traphalt.name) ->
	//exception branch
	se.setIsFinal(true) ->
	//transTrapHandler() ->
	te.setPriority(2) ->
	te.setSourceState(s1) ->
	te.setTargetState(se) ->
	te.setTriggersAndEffects("# ") ->  
	//normal termination
	sf.setIsFinal(true) ->
	tf.setPriority(3) ->
	tf.setSourceState(s1) ->
	tf.setTargetState(sf) ->
	tf.setType(TransitionType::NORMALTERMINATION) ->
	transStatement(s1,trap.statement);

//helpfunction for trap
List[synccharts::Signal] transTrapList(List[TrapDecl] list):
	list
;

transWeakAbort(State s, WeakAbort abort):
	let s1 = new State:
	//let sh = new State:
	//let th = new Transition:
	let r = new Region:
	s1.setId("s1") ->
	s.setLabel("Abort") ->
	s1.setIsInitial(true) ->
	//th.setSourceState(s1) ->
	//th.setTargetState(sh) ->
	//th.setPriority(1) ->
	s.regions.add(r) ->
	r.innerStates.add(s1) ->
	transStatement(s1, abort.statement) ->
	WeakAbortInstance.isInstance(abort.weakAbortBody)?
		transWeakAbortCaseSingle(r, s1, 1, ((WeakAbortInstance)abort.weakAbortBody).delay, ((WeakAbortInstance)abort.weakAbortBody).statement)
	:
		(let f = new State:
		let tf = new Transition:
		transWeakAbortCaseHelp(r, s1, 1, ((WeakAbortCase)abort.weakAbortBody).cases) ->
		f.setIsFinal(true) ->
		r.innerStates.add(f) ->
		tf.setSourceState(s1) ->
		tf.setTargetState(f) ->
		tf.setType(TransitionType::NORMALTERMINATION) ->
		tf.setPriority(((WeakAbortCase)abort.weakAbortBody).cases.size + 1)) ;
		
transWeakAbortCaseSingle(Region r, State source, Integer prio, DelayExpr delay, Statement statement):
	let t = new Transition:
	let s1 = new State:
	let t = new Transition:
	s1.setId("s"+(prio+1)) ->
	s1.setIsFinal(true) ->
	t.setSourceState(source) ->
	t.setTargetState(s1) ->
	r.innerStates.add(s1) ->
	t.setPriority(prio) ->
	t.setTriggersAndEffects(transDelayExpr(delay)) -> 
	statement == null ?
		s1
	:
		((transStatement(s1, statement)) -> s1);
		
State transWeakAbortCaseHelp(Region r, State source, Integer prio, List[AbortCaseSingle] list):
	list.size > 1?
		(transWeakAbortCaseSingle(r, source, prio, list.first().delay, list.first().statement) ->
		transWeakAbortCaseHelp(r, source, (prio+1), list.withoutFirst()))
	:
		transWeakAbortCaseSingle(r, source, prio, list.first().delay, list.first().statement) ;
	
// transforms local variable
transLocalVariable(State s, esterel::Variable var):
	let r = new Region:
	let s1 = new State:
	s1.setId("s1") ->
	s1.setIsInitial(true) ->
	s1.setIsFinal(true) ->
	r.innerStates.add(s1) ->
	s.regions.add(r) ->
	
	transStatement(s1, var.statement);
	
List[esterel::Variable] transVariableDecl(VariableDecl varDec):
		{transVariableList(varDec.varList)}
	;
	
esterel::Variable transVariableList(VariableList list):
	let v = new synccharts::Variable:
	let v2 = new synccharts::Variable:
	v.setName(list.variable);
	
/*transAtomicToText(State s, AtomicStatement atomic):
	let s1 = new State:
	let r = new Region:
		s1.setBodyText(atomic.toString().toString()) ->
		r.setParentState(s) ->
		r.innerStates.add(s1);

transEmitStatement(State s, Emit emit):
	let e = new Emission:
	let t = new Transition:
	let i = new State:
	let s1 = new State:
	let r = new Region:
		i.setIsInitial(true) ->
		s1.setIsFinal(true) ->
		t.setSourceState(i) ->
		t.setTargetState(s1) ->
		e.setSignal(
			(let sigList = {}:
				getAllSignals(s, sigList).selectFirst( signal | (emit.signal == signal))		
		)) ->
		e.setParentEAction(t);
		
		
List[synccharts::Signal] getAllSignals(State s, List[Signal] list):
	s.signals.union(getAllSignals (s.parentRegion.parentState, list)).flatten();
	
*/

String transDataExpr(DataExpr expr):
	expr.toString();
	
String transDelayExpr(DelayExpr delay):
	delay.expr == null?
		transDelayEvent(delay.event)
	: 
		(transDataExpr(delay.expr)+ " "+ transDelayEvent(delay.event));
	
String transDelayEvent(DelayEvent event):
	event.signal == null?
		event.toString()
	:
		event.signal.name;
		
transSigExpr(SigExpr expr):
	expr.toString();
	
String transExitEmission(Exit exit):
	exit.dataExpr.toString();