import synccharts;
import annotations;
import expressions;
import utilities;
import esterel;
import ecore;

extension feature; 
extension org::eclipse::xtend::util::stdlib::cloning;

/*
 	Main algorithm
*/
Boolean rule(List[State] states, Integer max):
	//if rule2applies(s) then rule2(s) ->
	//if rule5applies(s) then rule5(s) ->
	//if rule6applies(s) then rule6(s) 
	let s = states.first():
	switch{
		case max > 100:
			s
		case rule2applies(s) :
			(rule2(s) -> recursiveRule(states, max))
		case rule4applies(s):
			(rule4(s) -> recursiveRule(states, max))
		case rule5applies(s) :
			(rule5(s) -> recursiveRule(states, max))	 
		case rule6applies(s) :
			(rule6(s, states) -> recursiveRule(states, max)) 
		default :
		(states.remove(states.first()) -> ruleAll(states, max))
	} ->
	// clear the body references
	s.clearBodyReferences()
;

Void ruleAll(List[State] states, Integer max):
	//states.remove(states.first()) ->
	if states.size > 0 then 
		rule(states, max + 1) 
;

Void recursiveRule(List[State] states, Integer max):
	 if ((boolean) GLOBALVAR recursive) then
		ruleAll(states, max)
		
	;

/*
	rule1 : Remove unnecessary conditional state 
		if conditional, one plain outgoing transition
*/
Boolean rule1applies(State s):
	switch {
		case isConditional(s) && isOneOutTransition(s) : 
			(isTransitionWithout(s.outgoingTransitions.get(0)) ? true : false)
		default : false
	}
	
;

/*
	rule2 : Remove unnecessary plain states
		if simplestate, is not final nor initial, has only one outgoing transition
		an trigger = #tick
*/
Boolean rule2applies(State s):
	switch {
		case isSimpleState(s) && !s.isFinal && !s.isInitial &&
			isOneOutTransition(s) && isOutTransitionTick(s.outgoingTransitions.get(0)):
				true
		default : false
	}
;

Void rule2(State s):
	let incomingTrans = s.incomingTransitions.copyList():
	let outgoingTrans = s.outgoingTransitions.first():
	let effects = outgoingTrans.effects:
	// bend transitions
	incomingTrans.setTargetState(outgoingTrans.targetState) ->
	// append effects
	incomingTrans.addEffects(effects) ->

	// remove state and outgoing transition
	outgoingTrans.removeTransition() ->
	s.parentRegion.states.remove(s)
;

/*
	rule2.2 : remove unnecessary plain states where in and out have the same trigger (not immediate)
*/
// TODO



/*
	rule4: Remove simple final states if there is more than one and bend transitions
		more than 1 final simplestate
*/
Boolean rule4applies(State s):
	switch {
		case hasMultipleSimpleFinalSubStates(s) : 
			true
		default: false
	}
;

Void rule4(State s):
	let regions = (List[Region]) s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	regions.handleRule4()	
;

Void handleRule4(Region r):
	let simpleFinals = r.states.select(e|e.isSimpleState() && e.isFinal):
	let firstFinal = simpleFinals.first():
	let simpleWithoutFirst = simpleFinals.withoutFirst():
	simpleWithoutFirst.handleRule4rec(firstFinal)
;

Void handleRule4rec(State s, State to):
	let incomings = s.incomingTransitions.copyList():
	incomings.bendAndRemove(to)
;

Void bendAndRemove(Transition t, State to):
	let oldTarget = t.targetState:
	t.setTargetState(to) ->
	oldTarget.removeStateFromRegion()
;

/*
	rule5 : Remove unnecessary normal terminations
		macro state with no final states and outgoing transition
*/
Boolean rule5applies(State s):
	switch {
		case !isSimpleState(s) && hasOutNormalTransitions(s) && !hasFinalSubState(s):
				true
		default: false
	}
;

Void rule5(State s):
	let outTrans = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION
		&& (s.isInitial || e.sourceState != e.targetState)).copyList():
	outTrans.removeTransAndPossiblyState()
;

Void removeTransAndPossiblyState(Transition t):
	let target = t.targetState:
	t.removeTransition() ->
	if(target.incomingTransitions.isEmpty) then
		removeStateFromRegion(target)
;

/*
	rule6 : remove unnecessary macro states
		if no outgoing weak/strong abortions, no signals or variables, 
		is no parallel macro state, has a parent macro state 
*/
Boolean rule6applies(State s):
	switch {
		// TODO check if just test for interfaceDecls or signals and vars
		case !hasOutWeakTransitions(s) && !hasOutStrongTransitions(s) && !isSimpleState(s) &&
			!hasSignalsVariables(s) && hasParentMacroState(s) && !isParallelMacroState(s):
				true
		default: false
	}
;

Void rule6(State s, List[State] states):
	let r = s.regions.first():
	let initial = findInitialState(r):
	let finalMacros = r.states.select(e|!isSimpleState(e) && e.isFinal):
	let finalSimples = r.states.select(e|isSimpleState(e) && e.isFinal):
	let incomingTrans = s.incomingTransitions.copyList():
	let normalTerms = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	
	if (!incomingTrans.isEmpty) then
		(if (!s.hasOnlySelfLoop()) then
			initial.setIsInitial(false)) ->
			
	// reroute all incoming transitions to the initial state
	incomingTrans.setTargetState(initial) ->
	initial.incomingTransitions.addAll(incomingTrans) ->
		
	// if normal termination exist 
	(s.outgoingTransitions.size == 1) ?
	(
	// final macros become nonfinal 
	finalMacros.setIsFinal(false) ->
	// final simples become nonfinal
	finalSimples.setIsFinal(false) ->
	
	finalSimples.createWeakAbortTo(s.outgoingTransitions.get(0).targetState) ->
	if !normalTerms.isEmpty then
		finalMacros.copyNormalTransitionFrom(normalTerms.get(0))
	)
	: s
	
	// copy whole stuff 
	->
	(let copyStates = r.states.copyList():
	s.parentRegion.states.addAll(copyStates) ->
	// add the inner states to the list, as there might be new optimization potential
	//states.addAll(copyStates)
	states.addToFrontOfList(copyStates)
	) 
	
	->
	
	
	
	
	// remove old normal termination and old state
	if (!normalTerms.isEmpty) then
		normalTerms.removeTransition() ->
	s.removeStateFromRegion()
;


/*
	Predicates
*/

Boolean isConditional(State s):
	s.type == StateType::CONDITIONAL
;

Boolean isOneOutTransition(State s):
	s.outgoingTransitions.size == 1
;

Boolean isTransitionWithout(Transition t):
	t.trigger == null && t.effects.size == 0
;

Boolean isOutTransitionTick(Transition t):
	// TODO add "tick"
	t.isImmediate && true
;

Boolean hasOnlySelfLoop(State s):
	let self = s.incomingTransitions.select(e|e.targetState == e.sourceState):
	self.size > 0 && self.size == s.outgoingTransitions.size
;

Boolean hasOutTransitions(State s):
	!s.outgoingTransitions.isEmpty
;
Boolean hasOutWeakTransitions(State s):
	let weaks = s.outgoingTransitions.select(e|e.type == TransitionType::WEAKABORT):
	weaks.size > 0
;

Boolean hasOutNormalTransitions(State s):
	let normals = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	normals.size > 0
;

Boolean hasOutStrongTransitions(State s):
	let strongs = s.outgoingTransitions.select(e|e.type == TransitionType::STRONGABORT):
	strongs.size > 0 
;

Boolean hasInterfaceDeclaration(State s):
	s// TODO s.interfaceDecls.size == 0
;

Boolean hasFinalSubState(State s):
	let regs = s.regions:
	let states = regs.states:
	let finalStates = states.select(e|e.isFinal):
	!finalStates.isEmpty
;

Boolean hasMultipleSimpleFinalSubStates(State s):
	let regions = s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	!regions.isEmpty
;

Boolean hasParentMacroState(State s):
	s.parentRegion.parentState != null
;

Boolean isParallelMacroState(State s):
	s.regions.size > 1	
;

/*
	convinient methods
*/
State findInitialState(Region r):
	let initials = r.states.select(e|e.isInitial):
	initials.get(0)
;

/*
	creation methods
*/
Void createWeakAbortTo(State from, State to):
	let t = new Transition:
	from.outgoingTransitions.add(t) ->
	t.setSourceState(from) ->
	t.setTargetState(to) ->
	to.incomingTransitions.add(t) ->
	
	
	t.setType(TransitionType::WEAKABORT) ->
	t.setIsImmediate(true)
	// todo t.setTrigger tick
;

Void copyNormalTransitionFrom(State from, Transition t):
	/*let newT = (Transition) clone(t):
	newT.setType(TransitionType::NORMALTERMINATION) ->
	newT.setSourceState(from) ->
	from.outgoingTransitions.add(newT)
*/

	let newT = new Transition:
	newT.setSourceState(from) ->
	newT.setType(t.type) ->
	newT.setTrigger((Expression) clone(t.trigger)) -> 
	newT.setEffects((List[Effect]) clone(t.effects)) ->
	newT.setTargetState(t.targetState) ->
	from.outgoingTransitions.add(newT) ->
	t.targetState.incomingTransitions.add(newT)
	
;

Void addEffects(Transition t, List[Effect] effects):
	// make sure to clone! as it's containment
	t.effects.addAll(clone(effects))
; 

List[Transition] copyList(List[Transition] list):
	let copy = {}:
	copy.addAll(list)
;

Void removeTransition(Transition t):
	let source = t.sourceState:
	let target = t.targetState:
	t.setTargetState(null) ->
	t.setSourceState(null) ->
	source.outgoingTransitions.remove(t) ->
	target.incomingTransitions.remove(t)
;

// remove a state from the region
Void removeStateFromRegion(State state):
 state.outgoingTransitions.removeAll(state.outgoingTransitions) ->
 state.incomingTransitions.removeAll(state.incomingTransitions) ->
 state.parentRegion.states.remove(state)
;
  
Void clearBodyReferences(State s):
	let states = (Set[State]) s.eAllContents.select(e| State.isInstance(e) && ((State)e).bodyReference != null):
	states.add(s) ->
	states.setBodyReference(null)
;
  
Void addToFrontOfList(List list, List list2):
	//JAVA  de.cau.cs.kieler.esterel.transformation.util.TransformationUtil.addToFrontOfList(java.util.List, java.util.List)
	list
;
