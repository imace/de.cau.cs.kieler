import synccharts;
import annotations;
import expressions;
import utilities;
import esterel;
import ecore;

extension feature; 
extension org::eclipse::xtend::util::stdlib::cloning;

/*
 	Main algorithm
*/
Void rule(State s):
	if rule2applies(s) then rule2(s) ->
	if rule5applies(s) then rule5(s) ->
	if rule6applies(s) then rule6(s) 
;



/*
	rule1 : Remove unnecessary conditional state 
		if conditional, one plain outgoing transition
*/
Boolean rule1applies(State s):
	switch {
		case isConditional(s) && isOneOutTransition(s) : 
			(isTransitionWithout(s.outgoingTransitions.get(0)) ? true : false)
		default : false
	}
;

/*
	rule2 : Remove unnecessary plain states
		if simplestate, is not final nor initial, has only one outgoing transition
		an trigger = #tick
*/
Boolean rule2applies(State s):
	switch {
		case isSimpleState(s) && !s.isFinal && !s.isInitial &&
			isOneOutTransition(s) && isOutTransitionTick(s.outgoingTransitions.get(0)):
				true
		default : false
	}
;

Void rule2(State s):
	let incomingTrans = s.incomingTransitions.copyList():
	let outgoingTrans = s.outgoingTransitions.first():
	let effects = outgoingTrans.effects:
	// bend transitions
	incomingTrans.setTargetState(outgoingTrans.targetState) ->
	// append effects
	incomingTrans.addEffects(effects) ->

	// remove state and outgoing transition
	outgoingTrans.removeTransition() ->
	s.parentRegion.states.remove(s)
;

/*
	rule2.2 : remove unnecessary plain states where in and out have the same trigger (not immediate)
*/
// TODO




/*
	rule5 : Remove unnecessary normal terminations
		macro state with no final states and outgoing transition
*/
Boolean rule5applies(State s):
	switch {
		case !isSimpleState(s) && hasOutTransitions(s) && !hasFinalSubState(s):
				true
		default: false
	}
;

Void rule5(State s):
	let outTrans = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION
		&& (s.isInitial || e.sourceState != e.targetState)).copyList():
	outTrans.removeTransAndPossiblyState()
;

Void removeTransAndPossiblyState(Transition t):
	let target = t.targetState:
	t.removeTransition() ->
	if(target.incomingTransitions.isEmpty) then
		removeStateFromRegion(target)
;

/*
	rule6 : remove unnecessary macro states
		if no outgoing weak/strong abortions, no signals or variables, 
		is no parallel macro state, has a parent macro state 
*/
Boolean rule6applies(State s):
	switch {
		// TODO check if just test for interfaceDecls or signals and vars
		case !hasOutWeakTransitions(s) && !hasOutStrongTransitions(s) && !isSimpleState(s) &&
			!hasSignalsVariables(s) && hasParentMacroState(s) && !isParallelMacroState(s):
				true
		default: false
	}
;

Void rule6(State s):
	let r = s.regions.first():
	let initial = findInitialState(r):
	let finalMacros = r.states.select(e|!isSimpleState(e) && e.isFinal):
	let finalSimples = r.states.select(e|isSimpleState(e) && e.isFinal):
	let incomingTrans = s.incomingTransitions.copyList():
	
	// reroute all incoming transitions to the initial state
	incomingTrans.setTargetState(initial) ->
	initial.incomingTransitions.addAll(incomingTrans) ->
	initial.setIsInitial(false) ->
	
	// if normal termination exist 
	(s.outgoingTransitions.size == 1) ?
	(
	// final macros become nonfinal 
	finalMacros.setIsFinal(false) ->
	// final simples become nonfinal
	finalSimples.setIsFinal(false) ->
	
	finalSimples.createStrongAbortTo(s.outgoingTransitions.get(0).targetState) ->
	finalMacros.copyNormalTransitionFrom(s.outgoingTransitions.get(0))
	)
	: s
	
	// copy whole stuff 
	->
	s.parentRegion.states.addAll(r.states.copyList()) ->
	if (s.outgoingTransitions.size > 0) then
		s.outgoingTransitions.remove(s.outgoingTransitions.get(0)) ->
	s.removeStateFromRegion()
;


/*
	Predicates
*/

Boolean isConditional(State s):
	s.type == StateType::CONDITIONAL
;

Boolean isOneOutTransition(State s):
	s.outgoingTransitions.size == 1
;

Boolean isTransitionWithout(Transition t):
	t.trigger == null && t.effects.size == 0
;

Boolean isOutTransitionTick(Transition t):
	// TODO add "tick"
	t.isImmediate && true
;

Boolean hasOutTransitions(State s):
	!s.outgoingTransitions.isEmpty
;
Boolean hasOutWeakTransitions(State s):
	let weaks = s.outgoingTransitions.select(e|e.type == TransitionType::WEAKABORT):
	weaks.size > 0
;

Boolean hasOutStrongTransitions(State s):
	let strongs = s.outgoingTransitions.select(e|e.type == TransitionType::STRONGABORT):
	strongs.size > 0 
;

Boolean hasInterfaceDeclaration(State s):
	s.interfaceDecls.size == 0
;

Boolean hasFinalSubState(State s):
	let regs = s.regions:
	let states = regs.states:
	let finalStates = states.select(e|e.isFinal):
	!finalStates.isEmpty
;

Boolean hasParentMacroState(State s):
	s.parentRegion.parentState != null
;

Boolean isParallelMacroState(State s):
	s.regions.size > 1	
;

/*
	convinient methods
*/
State findInitialState(Region r):
	let initials = r.states.select(e|e.isInitial):
	initials.get(0)
;

/*
	creation methods
*/
Void createStrongAbortTo(State from, State to):
	let t = new Transition:
	t.setType(TransitionType::STRONGABORT) ->
	t.setSourceState(from) ->
	t.setTargetState(to) ->
	t.setIsImmediate(true) ->
	// todo t.setTrigger tick
	from.outgoingTransitions.add(t) ->
	to.incomingTransitions.add(t)
;

Void copyNormalTransitionFrom(State from, Transition t):
	let newT = new Transition:
	newT.setSourceState(from) ->
	newT.setType(t.type) ->
	newT.setTrigger(t.trigger) -> 
	newT.setEffects(t.effects) ->
	newT.setTargetState(t.targetState) ->
	from.outgoingTransitions.add(newT) ->
	t.targetState.incomingTransitions.add(newT)
;

Void addEffects(Transition t, List[Effect] effects):
	// make sure to clone! as it's containment
	t.effects.addAll(clone(effects))
; 

List[Transition] copyList(List[Transition] list):
	let copy = {}:
	copy.addAll(list)
;

Void removeTransition(Transition t):
	let source = t.sourceState:
	let target = t.targetState:
	source.outgoingTransitions.remove(t) ->
	target.incomingTransitions.remove(t) ->
	t.setTargetState(null) ->
	t.setSourceState(null)
;

// remove a state from the region
Void removeStateFromRegion(State state):
 state.outgoingTransitions.removeAll(state.outgoingTransitions) ->
 state.incomingTransitions.removeAll(state.incomingTransitions) ->
 state.parentRegion.states.remove(state)
;
