import kaom;
import annotations;
import Moml;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;  // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

//-----------------------------------------------------------------------------
//     Ptolemy - 2 - KAOM    TRANSFORMATION    
//     @author: haf
//-----------------------------------------------------------------------------
  
//Start Model Transformation here.
Entity transform(DocumentRoot root):
 	let entity = transform(root.entity) :
 	entity.optimize() ->
 	entity
;   

create Entity this transform(Moml::EntityType entity):
	let list = {}:
	this.setName(entity.name) ->
	createTrace(this,entity,"ptolemy","kaom") ->
	info("Created entity "+entity.name) ->
	addProperties(this, entity.property) ->
	addChildPorts(this) ->
	addChildEntities(this, entity.entity) ->
	addChildRelations(this, entity.relation) ->
	addChildLinks(this, entity.link) 
;

create Relation this transform(Moml::RelationType relation):
	this.setName(relation.name) ->
	createTrace(this,relation,"ptolemy","kaom") ->
	addProperties(this, relation.property)
;

// create a new link in kaom from a Ptolemy link. The problem is that a ptolemy link
// is (1) undirected and (2) has multiple possible attributes for head and tail, because
// it can connect a port and a relation or two relations, e.g.
// <link port="Ramp.output" relation="relation1"/>
// <link relation1="relation20" relation2="relation21"/>
create Link this transform(Moml::LinkType link, Entity parent):
	let relation = parent.getRelation(link.relation):
	let relation1 = parent.getRelation(link.relation1):
	let relation2 = parent.getRelation(link.relation2):
	let port = if(link.port == null) then null else parent.getPort(link.port):
	let linkables = {}:
	createTrace(this,link,"ptolemy","kaom") ->
	(if(port != null) then (linkables.add(port)) else (null)) ->
	(if(relation != null) then (linkables.add(relation)) else (null)) ->
	(if(relation1 != null) then (linkables.add(relation1)) else (null)) ->
	(if(relation2 != null) then (linkables.add(relation2)) else (null)) ->
	(if(linkables.size == 2) then (this.setSource(linkables.get(0)) -> this.setTarget(linkables.get(1)))	else (null)) ->
	// initially set all relations to be undirected
	this.addUndirectedAnnotation()
;

Void addChildEntities(Entity parent, List[EntityType] ptolemyEntities):
	let ptolemyEntity = ptolemyEntities.first():
	if(ptolemyEntities.isEmpty) then null else
		parent.childEntities.add(transform(ptolemyEntity)) ->
		addChildEntities(parent, ptolemyEntities.withoutFirst())
;

Void addChildRelations(Entity parent, List[RelationType] ptolemyRelations):
	let ptolemyRelation = ptolemyRelations.first():
	if(ptolemyRelations.isEmpty) then null else
		parent.childRelations.add(transform(ptolemyRelation)) ->
		addChildRelations(parent, ptolemyRelations.withoutFirst())
;

Void addChildLinks(Entity parent, List[LinkType] ptolemyLinks):
	let ptolemyLink = ptolemyLinks.first():
	if(ptolemyLinks.isEmpty) then null else
		parent.childLinks.add(transform(ptolemyLink, parent)) ->
		addChildLinks(parent, ptolemyLinks.withoutFirst())
;

Void addProperties(Annotatable annotatable, List[PropertyType] properties):
	let property = properties.first():
	let stringAnnotation = new StringAnnotation:
	let classType = new StringAnnotation:
	if(properties.isEmpty) then null else
		stringAnnotation.setName(property.name) ->
		stringAnnotation.setValue(property.value) ->
		classType.setName("ptolemyClass") ->
		classType.setValue(property.class) ->
		stringAnnotation.annotations.add(classType) ->
		annotatable.annotations.add(stringAnnotation)->
		// recursively add nested annotations
		stringAnnotation.addProperties(property.property) ->
		// now add remaining properties
		addProperties(annotatable, properties.withoutFirst())
;



// Ports are not necessarily explicit objects in a ptolemy model. Usually they are
// created implicitly in an Actor's Java implementation. Hence to see what ports
// an entity has, we need to instanciate that actor in Ptolemy. If the actor is not available
// in KIELER's Ptolemy library, this might fail and will not set up the ports
// correctly. Then the ports will be added when they are first referenced later on. However, then
// specific attributes of the ports (e.g. input or output) will be unavailable.
Void addChildPorts(Entity entity):
	let ptolemyEntity = (EntityType)entity.getSingleTraceTarget("ptolemy"):
	let entityList = {ptolemyEntity}:
	entity.childPorts.addAll(getExplicitPorts(ptolemyEntity.port)) ->
	entity.childPorts.addAll(getPorts(entityList))
;

List[Port] getExplicitPorts(List[Moml::PortType] ptolemyPorts):
	let kaomPorts = {}:
	if(ptolemyPorts.isEmpty) then (info("empty") -> kaomPorts) else
		(info("full") -> kaomPorts.add(transform(ptolemyPorts.first())) 
		 -> kaomPorts.addAll(getExplicitPorts(ptolemyPorts.withoutFirst()))
		 -> kaomPorts)  
;

create Port this transform(Moml::PortType ptolemyPort):
	info("Creating explicit port: "+ptolemyPort.name) ->
	this.setName(ptolemyPort.name) -> 
	createTrace(this,ptolemyPort,"ptolemy","kaom") ->
	(if( ptolemyPort.property.select(p|p.name == "input").isEmpty ) then this else this.addBooleanAnnotation("isInput",true)) ->
	(if( ptolemyPort.property.select(p|p.name == "output").isEmpty ) then this else this.addBooleanAnnotation("isOutput",true)) 
;

Relation getRelation(Entity parent,String relationName):
	let relation = parent.childRelations.selectFirst(r|r.name == relationName):
	relation
;

// get a port with a name like "Ramp.output", where the first part is the actor in the
// given parent and the second is the port name
// search for such existing port. If it does not exist, create it and add it to the model.
Port getPort(Entity parent, String portName):
	let newPort = new Port:
	let splitName = portName.split("\\."):
	let actor = splitName.size > 0 ? parent.childEntities.selectFirst(a|a.name == splitName.get(0)): null:
	let port = switch{
		case splitName.size > 1 : actor.childPorts.selectFirst(p|p.name == splitName.get(1))
		case splitName.size == 1: parent.childPorts.selectFirst(p|p.name == portName)
		default: null
	}:
	switch{
		case portName == null :  
			(reportWarning("Port with no name requested for Entity "+parent.name)->
			null)
		case port != null : port
		default: 
			(newPort.setName(splitName.get(1)) ->
			actor.childPorts.add(newPort) ->
			newPort)
	}
;

String getName(Object o):
	if(NamedObject.isInstance(o)) then ((NamedObject)o).name else ""
;

List getPorts(List[EntityType] entities) :
  JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.getPorts(java.util.List) 
;

// --------------------------------------------------------------------------------------------
//    OPTIMIZATION RULES
// --------------------------------------------------------------------------------------------

// entry points for optimizations
Void optimize(Entity entity):
	analyzeLinkDirections(entity) ->
	optimizeSingleRelations(entity) ->
	optimizeAnnotationRepresentation(entity)
;

// --------------------------------------------------------------------------------------------
//    Analysis of Link directions (Ptolemy Links are undirected)
// --------------------------------------------------------------------------------------------

Void analyzeLinkDirections(Entity entity):
	analyzeLinkDirections(entity.childEntities) -> // depth first 
	// set directions for links connected directly to inputs/outputs
	analyzeLinkDirectionsForPorts(entity.childPorts) ->
	// then analyze other links from the neighbor information
	analyzeLinkDirectionsForLinksFixpoint(entity.childLinks)
;

// Set Link directions for all connected Links to a List of Entities 
// using the port input/output information
Void analyzeLinkDirections(List[Entity] entities):
	if(entities.size <= 0) then null else (
		analyzeLinkDirections(entities.first()) ->
		analyzeLinkDirections(entities.withoutFirst()))
;

// Set Link directions for all connected Links to a List of Ports 
// using the port input/output information
Void analyzeLinkDirectionsForPorts(List[Port] ports):
	if(ports.size <= 0) then null else ( 
		analyzeLinkDirections(ports.first()) ->
		analyzeLinkDirectionsForPorts(ports.withoutFirst()))
;

// Set Link directions for all connected Links to a Port 
// using the port input/output information
Void analyzeLinkDirections(Port port):
	let isInput = port.isBooleanAnnotation("isInput"):
	let isOutput = port.isBooleanAnnotation("isOutput"):
	switch{
		case isInput && isOutput : null
		case isInput : setLinkDirection(port.getConnectedLinks(), port, true)
		case isOutput: setLinkDirection(port.getConnectedLinks(), port, false)
		default: null
	}
;

// Set directions of all links to a port which is known to be an input or output
Void setLinkDirection(List[Link] links, Port port, Boolean isInput):
	let link = links.first():
	switch{
		case links.isEmpty: null
		case isInput == true  && link.eContainer == port.eContainer : link.swapSourceTo(port)
		case isInput == false && link.eContainer == port.eContainer : link.swapTargetTo(port)
		case isInput == true  && link.eContainer != port.eContainer : link.swapTargetTo(port)
		case isInput == false && link.eContainer != port.eContainer : link.swapSourceTo(port)
		default: null
	} ->
	// recursively for all links in the list
	if(! links.isEmpty) then setLinkDirection(links.withoutFirst(),port,isInput) else null 
;

// Do a fixpoint iteration on a set of Links and try to deduce link directions from
// neighbor edges
Void analyzeLinkDirectionsForLinksFixpoint(List[Link] links):
	let hasChanged = analyzeLinkDirectionsForLinks(links):
	if(hasChanged) then analyzeLinkDirectionsForLinksFixpoint(links) else null
;

// returns true if it found some link which it could specify the direction
Boolean analyzeLinkDirectionsForLinks(List[Link] links):
	let link = links.first():
	let connectedRelations = {link.source, link.target}.typeSelect(kaom::Relation):
	let switchedLink = if(links.isEmpty || connectedRelations.isEmpty || !link.isUndirected()) then false else 
	       analyzeLinkDirectionForLink(link, connectedRelations):
	let switchedOthers = if(links.isEmpty) then false else analyzeLinkDirectionsForLinks(links.withoutFirst()):
	switchedLink || switchedOthers	
;

// Given a link and up to two relations, deduce from neighbor links the link's direction
Boolean analyzeLinkDirectionForLink(Link link, List[Relation] relations):
	let switchedAtRel1 = if(relations.size <1) then false else analyzeLinkDirectionForLink(link,relations.get(0)):
	let switchedAtRel2 = if(relations.size <2) then false else analyzeLinkDirectionForLink(link,relations.get(1)):
	switchedAtRel1 || switchedAtRel2
;

// Given a link and one relation, deduce from neighbor links the link's direction
Boolean analyzeLinkDirectionForLink(Link link, Relation relation):
	let neighborLinks = {relation.outgoingLinks, relation.incomingLinks} : 
	analyzeLinkDirectionForLink(link, neighborLinks, relation)
;

Boolean analyzeLinkDirectionForLink(Link link, List[Link] neighborLinks, Relation relation):
	let hasFirstSwitched = switch{
		case (neighborLinks.isEmpty || link.source == link.target) : false
		case ( (neighborLinks.first().target == relation) && (!neighborLinks.first().isUndirected())):
			(link.swapSourceTo(relation) -> true)
		case ( (neighborLinks.first().source == relation) && (!neighborLinks.first().isUndirected())):
			(link.swapTargetTo(relation) -> true)
		default : false
	}:
	let haveOthersSwitched = if (neighborLinks.isEmpty) then false else analyzeLinkDirectionForLink(link, neighborLinks.withoutFirst(), relation):
	hasFirstSwitched || haveOthersSwitched		
;

Void swapSourceTo(Link link, Linkable linkable):
	let source = link.source:
	let target = link.target:
	switch{
		case source == target: null // check for selfloop
		case target == linkable: link.setTarget(source)
		default: null
	}->
	link.setSource(linkable) ->
	link.removeUndirectedAnnotation()
;

Void swapTargetTo(Link link, Linkable linkable):
	let source = link.source:
	let target = link.target:
	switch{
		case source == target: null // check for selfloop
		case source == linkable: link.setSource(target)
		default: null
	}->
	link.setTarget(linkable) ->
	link.removeUndirectedAnnotation()
;


// --------------------------------------------------------------------------------------------
//    Optimization of single Relations (Ptolemy has always one relation)
// --------------------------------------------------------------------------------------------

Void optimizeSingleRelations(Entity entity):
	//let relations = entity.childRelations:
	//optimizeSingleRelations(relations)
	entity.childRelations.optimizeSingleRelation() ->
	// remove in a second iteration to avoid concurrent modification exceptions
	entity.childLinks.select(a|a.getAnnotation("toBeRemoved")!=null).remove() ->
	entity.childRelations.select(a|a.getAnnotation("toBeRemoved")!=null).remove() ->
	entity.childEntities.optimizeSingleRelations()
;

//Void optimizeSingleRelations(List[Relation] relations):
//	if(relations.isEmpty) then null else(
//		optimizeSingleRelation(relations.first()) ->
//		optimizeSingleRelations(relations.withoutFirst())
//	)
//;

Void optimizeSingleRelation(Relation relation):
	let inLink  = relation.incomingLinks.first():
	let outLink = relation.outgoingLinks.first():
	info("looking at: "+relation.eContainer.getName()+"."+relation.name) ->
	if( (relation.incomingLinks.size == 1) && (relation.outgoingLinks.size == 1) ) then(
		inLink.setTarget(outLink.target) -> 
		outLink.addAnnotation("toBeRemoved") ->
		relation.addAnnotation("toBeRemoved")
	) else null	
;

Void remove(Relation relation):
	((Entity)relation.eContainer).childRelations.remove(relation)
;

Void remove(Link link):
	link.setSource(null) 
	-> link.setTarget(null)
	-> ((Entity)link.eContainer).childLinks.remove(link) 
;

// --------------------------------------------------------------------------------------------
//    Transform some special Annotations to visible Entities
// --------------------------------------------------------------------------------------------

Void optimizeAnnotationRepresentation(Entity entity):
	entity.annotations.optimizeAnnotationRepresentation() ->
	entity.annotations.removeAll(entity.annotations.select(a|a.getAnnotation("toBeRemoved")!=null)) ->
	entity.childEntities.optimizeAnnotationRepresentation() 
;

// Marks an Annotation as "toBeRemoved". In another iteration it may be removed. This is
// necessary to avoid concurrent modification exceptions during iteration of an annotation list.
Void optimizeAnnotationRepresentation(Annotation annotation):
	let isTopLevel = Entity.isInstance(annotation.eContainer) :
	let topLevel = (Entity)annotation.eContainer :
	let newEntity = new Entity: 
	// need to clone the attribute to avoid concurrent modification (remove while iterating)
	let clonedAnnotation = annotation.clone():
	let marker = new Annotation:
	let annoMarker = new Annotation:
	switch{
		// if the entity already is an annotation representation, don't do anything
		case topLevel.getAnnotation("annotationNode") != null : null
		case isTopLevel && annotation.getAnnotation("ptolemyClass").value.matches(".*Director") : (
			newEntity.setName(annotation.getName()) ->
			marker.setName("annotationNode") ->
			newEntity.annotations.add(marker) ->
			newEntity.annotations.add(clonedAnnotation) -> // move annotation to the new Entity
			topLevel.childEntities.add(newEntity) ->
			annoMarker.setName("toBeRemoved") ->
			annotation.annotations.add(annoMarker)
		) 
		case isTopLevel && annotation.getAnnotation("ptolemyClass").value.matches("ptolemy.vergil.kernel.attributes.TextAttribute") : (
			// TODO: stupid way to display a big text
			newEntity.setName(annotation.getAnnotation("text").value) ->
			marker.setName("annotationNode") ->
			newEntity.annotations.add(marker) ->
			newEntity.annotations.add(clonedAnnotation) -> // move annotation to the new Entity
			topLevel.childEntities.add(newEntity) ->
			annoMarker.setName("toBeRemoved") ->
			annotation.annotations.add(annoMarker)
		)
		default: null	
	}
;

// --------------------------------------------------------------------------------------------
//    Helper functions
// --------------------------------------------------------------------------------------------

Boolean isBooleanAnnotation(Annotatable annotatable, String key):
	let annotation = annotatable.getAnnotation(key):
	switch {
		case annotation == null: false
		case BooleanAnnotation.isInstance(annotation) : ((BooleanAnnotation)annotation).value
		default: false
	}
;

Void addBooleanAnnotation(Annotatable annotatable, String key, Boolean value):
	let annotation = new BooleanAnnotation:
	annotation.setName(key) ->
	annotation.setValue(value) ->
	annotatable.annotations.add(annotation)
;

Void addAnnotation(Annotatable annotatable, String key, String value):
	let annotation = new StringAnnotation:
	annotation.setName(key) ->
	annotation.setValue(value) ->
	annotatable.annotations.add(annotation)
;

Void addAnnotation(Annotatable annotatable, String key):
	let annotation = new Annotation:
	annotation.setName(key) ->
	annotatable.annotations.add(annotation)
;

List[Link] getConnectedLinks(Port port):
	let links = {}:
	links.addAll(port.incomingLinks) ->
	links.addAll(port.outgoingLinks) ->
	links
;

Void addUndirectedAnnotation(Link link):
	let annotation = new Annotation:
	annotation.setName("undirected") ->
	link.annotations.add(annotation)
;

Boolean isUndirected(Link link):
	(link.getAnnotation("undirected") != null)
;

Void removeUndirectedAnnotation(Link link):
	let annotation = link.getAnnotation("undirected"):
	if(annotation != null) then link.annotations.remove(annotation) else null 
;

List infoAndReturn(List input):
	info(input) -> input
;