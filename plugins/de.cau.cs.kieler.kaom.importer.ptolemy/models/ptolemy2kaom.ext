/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2010 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */

import kaom;
import annotations;
import moml;

extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)


//=============================================================================
// Ptolemy - 2 - KAOM    TRANSFORMATION    
//    @author: haf
//    @author: cds
//=============================================================================
//
// Transforms a Ptolemy2 model to a KAOM model that can be displayed in
// KIELER. The transformation is done in two steps.
// 
// First, all entities, relations and links are transformed. The transformed
// objects are annotated to originate from a Ptolemy2 model. This is fairly
// straightforward, except for the ports of actors. During the transformation,
// actors must be instantiated using the KIELER Ptolemy library to find their
// ports. The problem is that if an actor is not part of the official Ptolemy
// actor library, the instantiation often fails, leaving us without properly
// defined ports. In particular, we then cannot determine if a port is an
// input port or an output port, which leads to problems when the directions
// of links are determined. (in Ptolemy, contrary to KAOM, links are
// undirected)
// 
// The second step is the optimization of the resulting model. In this step,
// link directions are computed, relations that only connect two ports are
// replaced by a single link, special annotations are replaced by entities,
// (the Ptolemy director, text attributes, ...) and links of states are
// changed.
// 
//=============================================================================


//-----------------------------------------------------------------------------
// TRANSFORMATIONS
//-----------------------------------------------------------------------------

/**
 * Start the model transformation here.
 * 
 * @param root the DocumentRoot object to start the transformation on.
 * @return the transformed KAOM entity.
 */
create Entity this transform(DocumentRoot root) :
    // Transform all the root's child entities
    let entity = (root.entity != null ? transform(root.entity) : null) :
    let class = (root.class != null ? transform(root.class) : null) :
    
    // Add the children to our model
    switch {
        case entity != null :
            this.childEntities.add(entity)
        
        case class != null :
            this.childEntities.add(class)
        
        default :
            null
    } ->
    
    // Optimize the resulting model
    this.optimize()
;

/**
 * Transform the given entity.
 * 
 * @param entity the entity to transform.
 * @return the transformed KAOM entity.
 */
create Entity this transform(moml::EntityType entity) :
    let list = {} :
    
    this.setName(entity.name) ->
    
    // Map the new KAOM element to the Ptolemy entity for later use
    createTrace(this, entity, "ptolemy", "kaom") ->
    
    // Add annotations pointing to Ptolemy
    this.addStringAnnotation("language", "ptolemy") ->
    this.addStringAnnotation("ptolemyClass", entity.class1) ->
    
    // Add the entity's properties, ports, entities, relations and links
    addProperties(this, entity.property) ->
    addChildPorts(this) ->
    addChildEntities(this, entity.entity) ->
    addChildRelations(this, entity.relation) ->
    addChildLinks(this, entity.link) 
;

/**
 * Transforms the given class type.
 * 
 * Assumption: a ClassType node can only occur at the top level. If this
 * assumption doesn't hold, we need to overload quite a bunch of methods
 * to cope.
 * 
 * @param entity the class type to transform.
 * @return the transformed KAOM entity.
 */
create Entity this transform(moml::ClassType entity) :
    let list = {} :
    
    this.setName(entity.name) ->
    
    // Map the new KAOM element to the Ptolemy entity for later use
    createTrace(this, entity, "ptolemy", "kaom") ->
    
    // Add annotations pointing to Ptolemy
    this.addStringAnnotation("language", "ptolemy") ->
    this.addStringAnnotation("ptolemyClass", entity.extends) ->
    
    // Add the entity's properties, ports, entities, relations and links
    addProperties(this, entity.property) ->
    addChildPorts(this) ->
    addChildEntities(this, entity.entity) ->
    addChildRelations(this, entity.relation) ->
    addChildLinks(this, entity.link)
;

/**
 * Create a new relation in KAOM from a Ptolemy relation.
 * 
 * @param relation the Ptolemy relation to transform.
 * @return the transformed KAOM relation.
 */
create Relation this transform(moml::RelationType relation) :
    // Map the new KAOM element to the Ptolemy entity for later use
    createTrace(this, relation, "ptolemy", "kaom") ->
    
    // Set name and add Ptolemy annotation
    this.setName(relation.name) ->
    this.addStringAnnotation("language", "ptolemy") ->
    
    // Add the relation's properties
    addProperties(this, relation.property)
;

/**
 * Create a new link in KAOM from a Ptolemy link. The problem is that a
 * Ptolemy link is (1) undirected and (2) has multiple possible attributes
 * for head and tail, because it can connect a port and a relation or two
 * relations, e.g.
 *   <link port="Ramp.output" relation="relation1"/>
 *   <link relation1="relation20" relation2="relation21"/>
 * 
 * @param link the link to transform.
 * @param parent the link's parent entity.
 * @return the transformed KAOM link.
 */
create Link this transform(moml::LinkType link, Entity parent) :
    // Fetch the relations and ports this link connects
    let relation = parent.getRelation(link.relation) :
    let relation1 = parent.getRelation(link.relation1) :
    let relation2 = parent.getRelation(link.relation2) :
    let port = if (link.port == null)
        then null
        else parent.getPort(link.port) :
    let linkables = {} :
    
    // Map the new KAOM element to the Ptolemy entity for later use
    createTrace(this, link, "ptolemy", "kaom") ->
    
    // Add annotations pointing to Ptolemy
    this.addStringAnnotation("language", "ptolemy") ->
    
    (
        if (port != null)
            then (linkables.add(port))
            else (null)
    ) -> (
        if (relation != null)
            then (linkables.add(relation))
            else (null)
    ) -> (
        if (relation1 != null)
            then (linkables.add(relation1))
            else (null)
    ) -> (
        if (relation2 != null)
            then (linkables.add(relation2))
            else (null)
    ) -> (
        if (linkables.size == 2)
            then (
                this.setSource((Linkable) linkables.get(0)) ->
                this.setTarget((Linkable) linkables.get(1))
            )
            else (null)
    ) ->
    
    // Initially, set all relations to be undirected as we cannot derive
    // meaningful directions at this point anyway; the directions will be
    // figured out later
    this.markAsUndirected()
;

/**
 * Create a new KAOM port from a Ptolemy port.
 * 
 * @param ptolemyPort the port to transform.
 * @return the transformed KAOM port.
 */
create Port this transform(moml::PortType ptolemyPort) :
    let language = new StringAnnotation :
    
    // Map the new KAOM element to the Ptolemy entity for later use
    createTrace(this, ptolemyPort, "ptolemy", "kaom") ->
    
    // Set the port name and add the port's properties, which might add
    // "input" / "output" annotations
    this.setName(ptolemyPort.name) ->
    addProperties(this, ptolemyPort.property)
;


//-----------------------------------------------------------------------------
// ADD CHILDREN AND PROPERTIES
//-----------------------------------------------------------------------------

/**
 * Transforms the given list of Ptolemy entities and adds them to the
 * given parent.
 * 
 * @param parent the parent KAOM entity to add the transformed Ptolemy
 *               entities to.
 * @param ptolemyEntities list of Ptolemy entities to transform and add
 *                        to the parent.
 */
Void addChildEntities(Entity parent, List[EntityType] ptolemyEntities) :
    let ptolemyEntity = ptolemyEntities.first() :
    
    // If there are still entities left in the list, transform them, add
    // them to the parent and recursively add the remaining entities
    if (ptolemyEntities.isEmpty)
        then null
        else (
            parent.childEntities.add(transform(ptolemyEntity)) ->
            addChildEntities(parent, ptolemyEntities.withoutFirst())
        )
;

/**
 * Transforms the given list of Ptolemy relations and adds them to the
 * given parent entity.
 * 
 * @param parent KAOM entity to add the transformed relations to.
 * @param ptolemyRelations list of relations to transform and add to
 *                         the parent.
 */
Void addChildRelations(Entity parent, List[RelationType] ptolemyRelations) :
    let ptolemyRelation = ptolemyRelations.first() :
    
    // If there are still relations left in the list, transform them, add
    // them to the parent and recursively add the remaining relations
    if (ptolemyRelations.isEmpty)
        then null
        else (
            parent.childRelations.add(transform(ptolemyRelation)) ->
            addChildRelations(parent, ptolemyRelations.withoutFirst())
        )
;

/**
 * Transforms the given list of Ptolemy links and adds them to the given
 * parent entity.
 * 
 * @param parent KAOM entity to add the transformed links to.
 * @param ptolemyLinks list of links to transform and add to  the parent.
 */
Void addChildLinks(Entity parent, List[LinkType] ptolemyLinks) :
    let ptolemyLink = ptolemyLinks.first() :
    
    // If there are still links left in the list, transform them, add
    // them to the parent and recursively add the remaining links
    if (ptolemyLinks.isEmpty)
        then null
        else (
            parent.childLinks.add(transform(ptolemyLink, parent)) ->
            addChildLinks(parent, ptolemyLinks.withoutFirst())
        )
;

/**
 * Transforms the given list of Ptolemy properties to annotations and adds
 * them to the given annotatable element.
 * 
 * @param annotatable KAOM object to add the properties to.
 * @param properties list of properties to transform and add to the
 *                   annotatable.
 */
Void addProperties(Annotatable annotatable, List[PropertyType] properties) :
    let property = properties.first() :
    let stringAnnotation = new StringAnnotation :
    let classType = new StringAnnotation :
    
    // If there are still properties left in the list, transform them,
    // add them to the annotatable and recursively add the property's
    // properties and the remaining properties in the list
    if(properties.isEmpty)
        then null
        else (
            // Ptolemy properties have types; we annotate the annotation
            // with the Ptolemy class of the original property
            classType.setName("ptolemyClass") ->
            classType.setValue(property.class) ->
            
            // Save the name, value and class of the annotation
            stringAnnotation.setName(property.name) ->
            stringAnnotation.setValue(property.value) ->
            stringAnnotation.annotations.add(classType) ->
            
            // Add the annotation
            annotatable.annotations.add(stringAnnotation)->
            
            // Recursively add the property's properties
            addProperties(stringAnnotation, property.property) ->
            
            // Recursively add the remaining properties in the list
            addProperties(annotatable, properties.withoutFirst())
        )
;

/**
 * Add the entity's child ports to the entity.
 * 
 * Ports are not necessarily explicit objects in a ptolemy model. Usually they
 * are created implicitly in an Actor's Java implementation. Hence to see what
 * ports an entity has, we need to instanciate that actor in Ptolemy. If the
 * actor is not available in KIELER's Ptolemy library, this might fail and will
 * not set up the ports correctly. Then the ports will be added when they are
 * first referenced later on. However, then specific attributes of the ports
 * (e.g. input or output) will be unavailable, which may cause links to have the
 * wrong direction in the transformed model.
 * 
 * @param entity the KAOM entity whose ports to add.
 */
Void addChildPorts(Entity entity) :
    // Find the corresponding Ptolemy entity type (we have mapped that to the
    // given KAOM entity when we created the latter using the Trace facilities)
    let ptolemyEntity = (EntityType) entity.getSingleTraceTarget("ptolemy") :
    let entityList = {ptolemyEntity} :
    
    // Find entity's ports using KIELER's Ptolemy library and any ports
    // explicitly declared in the model
    let javaPorts = getPorts(entityList) :
    let explicitPorts = ptolemyEntity.port.transform() :
    
    // Merge both port lists and annotate them with the language annotation
    let mergedPorts = mergePortAttributes(javaPorts, explicitPorts) :
    let annotatedPorts = addLanguageToPort(mergedPorts) :
    
    // Add all annotated ports to the KAOM entity
    entity.childPorts.addAll(annotatedPorts)
;


//-----------------------------------------------------------------------------
// Helper Methods
//-----------------------------------------------------------------------------

/**
 * Adds an annotation to all ports that identifies them as a Ptolemy port.
 * 
 * @param ports list of KAOM ports.
 * @return the same list, but with the ports annotated.
 */
List[Port] addLanguageToPort(List[Port] ports) :
    ports.addStringAnnotation("language", "ptolemy") ->
    ports
;

/**
 * Returns the relation with the given name from the child relations of the
 * given parent entity.
 * 
 * @param parent the entity whose relations to search.
 * @param relationName name of the relation to find.
 * @return the relation with the given name.
 */
Relation getRelation(Entity parent,String relationName) :
    let relation = parent.childRelations.selectFirst(r | r.name == relationName) :
    
    relation
;

/**
 * Look for a port with a name like "Ramp.output", where the first part is the actor
 * in the given parent and the second is the port name. If such a port does not exist,
 * create it and add it to the model.
 * 
 * The qualified port name is interpreted as follows. If the name consists of two
 * components separated by a dot, the first component is interpreted as the name of
 * an actor in the parent entity, while the second component is interpreted as the
 * name of a port in the actor. If the name consists of only one component, that
 * component is interpreted as the name of a port of the parent entity itself.
 * 
 * @param parent the entity to look for the actor and its port in.
 * @param portName the qualified name of the port to look for.
 * @return the existing port, or a new port added to the model.
 */
Port getPort(Entity parent, String portName) :
    // The newly created port, if needed
    let newPort = new Port :
    
    // Split the qualified name into Actor and Port portions
    let splitName = portName.split("\\.") :
    
    // Try to find the actor and its port
    let actor = splitName.size > 0
        ? parent.childEntities.selectFirst(a | a.name == splitName.get(0))
        : null :
    let port = switch {
        case splitName.size > 1 :
            actor.childPorts.selectFirst(p | p.name == splitName.get(1))
            
        case splitName.size == 1 :
            parent.childPorts.selectFirst(p | p.name == portName)
            
        default :
            null
    } :
    
    switch {
        case portName == null : (
            // Empty port name; we can't find a corresponding port
            reportWarning("Port with no name requested for Entity " + parent.name) ->
            null
        )
            
        case port != null :
            // If we have actually found an existing port, return that
            port
            
        case actor == null : (
            // We haven't found an existing port. If no actor was found or specified
            // either, add a new port with the given name to the parent entity and
            // return that
            reportWarning("Non-Existing Port referenced: "
                + portName + " for Entity " + parent.name) -> 
            newPort.setName(portName) ->
            parent.childPorts.add(newPort) -> 
            newPort
        )
            
        default : (
            // We haven't found an existing port, but an existing actor. Add a new
            // port with the given name to the actor and return that 
            reportWarning("Non-Existing Port referenced: " + portName) -> 
            newPort.setName(splitName.size < 2 ? "null" : splitName.get(1)) -> 
            actor.childPorts.add(newPort) -> 
            newPort
        )
    }
;

/**
 * Merges newPorts into existingPorts. Ports that don't already exist in
 * existingPorts are added. Ports that do exist get their annotations merged.
 * 
 * @param newPorts list of ports.
 * @param existingPorts list of ports.
 * @return the two lists merged.
 */
List[Port] mergePortAttributes(List[Port] newPorts, List[Port] existingPorts) :
    switch {
        case newPorts == null || newPorts.size == 0 :
            // newPorts is empty
            existingPorts
            
        case existingPorts == null || existingPorts.size == 0 :
            // existingPorts is empty
            newPorts
            
        default :
            // Both lists are non-empty, so merge and return the result
            newPorts.mergePortAttributesSingle(existingPorts)  
    }
;

/**
 * Merges the new port into a list of existing ports.
 * 
 * @param newPort the new port.
 * @param the list of existing ports.
 * @return the new port if a port of the same name doesn't already exist,
 *         or the existing port of the same name with the new port's
 *         annotations added.
 */
Port mergePortAttributesSingle(Port newPort, List[Port] existingPorts) :
    // Find the existing port with the same name
    let existingPort = existingPorts.select(p | p.name == newPort.name).first() :
    
    if (existingPort == null)
        then
            // There is no existing port of the same name, so just add the
            // new port to the list
            newPort
        else (
            // There is an existing port of the same name, so add the
            // new port's annotations to the existing port and return
            // that
            existingPort.annotations.addAll(newPort.annotations) ->
            existingPort
        )
;


//-----------------------------------------------------------------------------
// OPTIMIZATION RULES
//-----------------------------------------------------------------------------

/**
 * Optimizes the given entity.
 * 
 * @param entity the entity to optimize.
 */
Void optimize(Entity entity) :
    // TODO Call optimizeStates before inferLinkDirections?
    // optimizeStates determines some link directions in the process that
    // then wouldn't have to be inferred in the first place... right?
    
    // Try to infer the link directions
    inferLinkDirections(entity) ->
    
    // optimizeStates has to be called before relation optimization because
    // it fixes link directions
    optimizeStates(entity) ->
    optimizeSingleRelations(entity) ->
    optimizeAnnotationRepresentation(entity)
;


//-----------------------------------------------------------------------------
// Inference Of Link Directions
//-----------------------------------------------------------------------------

/**
 * Infers the direction of the links in the model tree rooted at the given
 * entity.
 * 
 * First, an attempt is made to infer the type of ports of yet unknown type.
 * This succeeds if the port is connected to a link whose direction is known.
 * 
 * Second, the directions of undirected links connected to ports of known
 * type are inferred.
 * 
 * Third, all relations are traversed, looking for a relation with only
 * incoming or only outgoing links and just one undirected link. If such
 * a relation is found, the direction of its undirected link is inferred.
 * If no such relation is found, a random undirected link's direction is
 * fixed.
 * 
 * Repeat.
 * 
 * At this point, either all link directions have been inferred or there are
 * some links left whose direction cannot be inferred with the information
 * available. These links are left untouched, since we might as well leave
 * them in the direction they currently have.
 * 
 * @param entity root of the tree.
 */
Void inferLinkDirections(Entity entity) :
    let portsChanged = inferPorts(entity) :
    let linksChanged = inferLinks(entity) :
    let relationsChanged = inferRelations(entity) :
    
    if (portsChanged || linksChanged || relationsChanged)
        then inferLinkDirections(entity)
        else null
;


//------------------
// Infer Port Types
//------------------

/**
 * Traverses the ports in the tree rooted at the given element and tries
 * to infer their types, if unknown.
 * 
 * @param entity root of the tree of entities to traverse.
 * @return true if some port's type has changed, false otherwise.
 */
Boolean inferPorts(Entity entity) :
    let ownPortsChanged = _inferPorts(entity.childPorts) :
    let otherPortsChanged = entity.childEntities.inferPorts().exists(e | e == true) :
    
    ownPortsChanged || otherPortsChanged
;

/**
 * Go through the list of ports and try to infer their type.
 * 
 * @param ports list of ports.
 * @return true if some port's type has changed, false otherwise.
 */
Boolean _inferPorts(List[Port] ports) :
    if (ports.size == 0)
        then false
        else (
            _inferPort(ports.first()) || _inferPorts(ports.withoutFirst())
        )
;

/**
 * Tries to infer the type of the given port, if unknown.
 * 
 * @param port the port whose type to infer.
 * @return true if the port's type has changed, false otherwise.
 */
Boolean _inferPort(Port port) :
    // Find any connected undirected links
    let connectedLinks = getConnectedLinks(port).select(l | !isMarkedAsUndirected(l)) :
    
    if (isMarkedAsInputPort(port) || isMarkedAsOutputPort(port))
        then (
            // The port's type is known; our work here is done
            false
        )
        else (
            // The port's type is unknown. Try to find a directed link
            if (hasDirectedIncomingLink(port, connectedLinks))
                then (
                    // There is a directed link going into the port, so
                    // it must be an input port! Heureka!
                    markAsInputPort(port) ->
                    true
                )
                else (
                    if (hasDirectedOutgoingLink(port, connectedLinks))
                        then (
		                    // There is a directed link coming out of the
		                    // port, so it must be an output port! Hurray!
		                    markAsOutputPort(port) ->
		                    true
                        )
                        else (
                            // We could not infer the port's type
                            false
                        )
                )
        )
;

/**
 * Checks if one of the links in the list has the port as its target.
 * 
 * @param port the port.
 * @param links list of directed links to look through.
 * @return true if one of the links has the port as its target.
 */
Boolean hasDirectedIncomingLink(Port port, List[Link] links) :
    let link = links.first() :
    
    // Check if the link is directed and goes into the port
    if (link != null)
        then (
		    if (link.target == port)
		        then true
		        else hasDirectedIncomingLink(port, links.withoutFirst())
        )
        else false
;

/**
 * Checks if one of the links in the list has the port as its source.
 * 
 * @param port the port.
 * @param links list of directed links to look through.
 * @return true if one of the links has the port as its source.
 */
Boolean hasDirectedOutgoingLink(Port port, List[Link] links) :
    let link = links.first() :
    
    // Check if the link is directed and goes out of the port
    if (link != null)
        then (
            if (link.source == port)
                then true
                else hasDirectedOutgoingLink(port, links.withoutFirst())
        )
        else false
;


//-----------------------
// Infer Link Directions
//-----------------------

/**
 * Traverses the links in the tree rooted at the given element and tries
 * to infer their direction, if unknown.
 * 
 * @param entity root of the tree of entities to traverse.
 * @return true if some link's direction has been inferred, false
 *         otherwise.
 */
Boolean inferLinks(Entity entity) :
    let ownLinksChanged = _inferLinks(entity.childLinks) :
    let otherLinksChanged = entity.childEntities.inferLinks().exists(e | e == true) :
    
    ownLinksChanged || otherLinksChanged
;

/**
 * Go through the list of links and try to infer their direction.
 * 
 * @param links list of links.
 * @return true if some link's direction was inferred, false otherwise.
 */
Boolean _inferLinks(List[Link] links) :
    if (links.size == 0)
        then false
        else (
            _inferLink(links.first()) || _inferLinks(links.withoutFirst())
        )
;

/**
 * Tries to infer the given link's direction by looking at the port it
 * is connected to, if any.
 * 
 * @param link the link whose direction to infer.
 * @return true if the link's direction was inferred, false otherwise.
 */
Boolean _inferLink(Link link) :
    // This list will have at most one entry
    let endPorts = {
        link.source,
        link.target
    }.typeSelect(kaom::Port) :
    
    // If the link's direction is unknown and it is connected to a port...
    if (endPorts.size > 0 && isMarkedAsUndirected(link))
        then (
            // If the port type is known, set the link's direction
            if (isPortTypeKnown(endPorts.get(0)))
                then (
                    setLinkDirection(link, endPorts.get(0)) ->
                    true
                )
                else false
        )
        else false
;


//-----------------
// Infer Relations
//-----------------

/**
 * Tries to infer the direction of single undirected links connected to
 * relations with only incoming or only outgoing links.
 * 
 * @param entity root of the tree whose relations to traverse.
 * @return true if at least one previously undirected link is now directed.
 */
Boolean inferRelations(Entity entity) :
    let ownRelationsChanged = _inferRelations(entity.childRelations) :
    let otherRelationsChanged = entity.childEntities.inferRelations().exists(e | e == true) :
    
    ownRelationsChanged || otherRelationsChanged
;

/**
 * Tries to infer the direction of single undirected links connected to
 * the given list of relations.
 * 
 * @param relations the relations to traverse.
 * @return true if at least one previously undirected link is now directed.
 */
Boolean _inferRelations(List[Relation] relations) :
    let relation = relations.first() :
    
    if (relation != null)
        then (
            if (_inferRelation(relation))
                then (
                    _inferRelations(relations.withoutFirst()) ->
                    true
                )
                else _inferRelations(relations.withoutFirst())
        )
        else false
;

/**
 * Tries to infer the direction of single undirected links connected to
 * the given relation.
 * 
 * @param relations the relation.
 * @return true if a previously undirected link is now directed.
 */
Boolean _inferRelation(Relation relation) :
    // Get the incoming and outgoing directed links
    let incoming = relation.incomingLinks.select(e | !isMarkedAsUndirected(e)) :
    let outgoing = relation.outgoingLinks.select(e | !isMarkedAsUndirected(e)) :
    
    // Get the list of connected undirected links
    let undirected = getConnectedLinks(relation).select(e | isMarkedAsUndirected(e)) :
    
    if (undirected.size == 1)
        then (
            // There is exactly one undirected link connected to this relation 
		    switch {
		        case incoming.size == 0 && outgoing.size > 0 : (
		            // There are only outgoing links, so the undirected link
		            // must be incoming
		            swapTargetTo(undirected.first(), relation) ->
		            true
	            )
		            
                case incoming.size > 0 && outgoing.size == 0 : (
                    // There are only incoming links, so the undirected link
                    // must be outgoing
                    swapSourceTo(undirected.first(), relation) ->
                    true
                )
                    
                default :
                    false
            }
        )
        else false
;


//-----------------------------------------------------------------------------
// Optimization Of Single Relations
//-----------------------------------------------------------------------------

/**
 * Optimizes relations that connect only two ports. Such relations have two
 * links, one incoming and one outgoing. The given entity's relations are
 * optimized, then the entity's child entities are recursively treated.
 * 
 * @param entity entity whose child relations to optimize recursively.
 */
Void optimizeSingleRelations(Entity entity) :
    // Optimize the entity's direct child relations; this may leave
    // relations marked for removal
    entity.childRelations.optimizeSingleRelation() ->
    
    // Remove the relations that can be removed (this is done in a
    // second iteration to avoid concurrent modification exceptions)
    entity.childRelations.select(a | a.isMarkedAsRemovable()).remove() ->
    
    // Recursively optimize the relations of the entity's child entities
    entity.childEntities.optimizeSingleRelations()
;

/**
 * Replaces the given relation by a single link, if possible. If that is
 * indeed possible, the relation is marked as being removable, and one of
 * the links is removed.
 * 
 * @param relation the relation to be optimized.
 */
Void optimizeSingleRelation(Relation relation):
    // Find the first of the relation's incoming and outgoing links 
    let inLink  = relation.incomingLinks.first() :
    let outLink = relation.outgoingLinks.first() :
    
    // If the relation has only one incoming and outgoing link, it can be
    // optimized away
    if ((relation.incomingLinks.size == 1) && (relation.outgoingLinks.size == 1))
        then (
            inLink.setTarget(outLink.target) -> 
            relation.markAsRemovable() ->
            remove(outLink)
        )
        else
            null    
;


//-----------------------------------------------------------------------------
// Transform Special Annotations To Visible Entities
//-----------------------------------------------------------------------------

/**
 * Transforms special annotations of the given entity and, recursively, its
 * children to visible entities.
 * 
 * @param the entity whose annotations to transform.
 */
Void optimizeAnnotationRepresentation(Entity entity) :
    // Transform annotations
    entity.annotations.optimizeAnnotationRepresentation() ->
    
    // Remove those annoations that were transformed (this is done in a
    // second iteration to avoid concurrent modification exceptions)
    entity.annotations.removeAll(
        entity.annotations.select(a | a.isMarkedAsRemovable() != null)) ->
    
    // Recursively treat child entities
    entity.childEntities.optimizeAnnotationRepresentation()  
;

/**
 * Try to transform the given annotation into a visible entity. If this is
 * successful, the annotation is annotated as being ready for removal and
 * should be removed after executing this extension. This must be done in a
 * separate step to avoid concurrent modification exceptions. Entities that
 * result from transforming annotations are annotated with "annotationNode".
 * 
 * @param annotation the annotation to be transformed, if possible.
 */
Void optimizeAnnotationRepresentation(Annotation annotation) :
    // Check, 
    let isTopLevel = Entity.isInstance(annotation.eContainer) :
    let topLevel = (Entity) annotation.eContainer :
    
    // If the annotation is transformed into a new entity, this will be it
    let newEntity = new Entity :
    
    // Clone the attribute to avoid concurrent modification (remove while iterating)
    let clonedAnnotation = annotation.clone() :
    
    // Annotations for the new entity and for the old annotation if the
    // transformation is successful
    let annotationNodeAnnotation = new Annotation :
    
    switch {
        case topLevel.getAnnotation("annotationNode") != null :
            // If the entity already is an annotation representation, don't do anything
            null
            
        case isTopLevel && annotation.getAnnotation("ptolemyClass").value.matches(".*Director") : (
            // The director is an annotation of the top level entity. Turn it
            // into its own separate entity 
            newEntity.setName(annotation.getName()) ->
            
            // Add an "annotationNode" annotation to the new entity
            annotationNodeAnnotation.setName("annotationNode") ->
            newEntity.annotations.add(annotationNodeAnnotation) ->
            
            // Annotate the new entity with a copy of the original
            // annotation the new entity is the transformed result of
            newEntity.annotations.add(clonedAnnotation) ->
            
            // Add the new entity to the top level
            topLevel.childEntities.add(newEntity) ->
            
            // Mark the original annotation for removal
            annotation.markAsRemovable()
        )
            
        case isTopLevel && annotation.getAnnotation("ptolemyClass").value.matches(
            "ptolemy.vergil.kernel.attributes.TextAttribute") : (
            // Comments / large text boxes are annotations of the top level
            // entity. (Ptolemy calls these Annotations at the UI level) Turn
            // them into their own entities.
            // TODO We need a better way to display large amounts of text
            newEntity.setName(annotation.getAnnotation("text").value) ->
            
            // Add an "annotationNode" annotation to the new entity
            annotationNodeAnnotation.setName("annotationNode") ->
            newEntity.annotations.add(annotationNodeAnnotation) ->
            
            // Annotate the new entity with a copy of the original
            // annotation the new entity is the transformed result of
            newEntity.annotations.add(clonedAnnotation) ->
            
            // Add the new entity to the top level
            topLevel.childEntities.add(newEntity) ->
            
            // Mark the original annotation for removal
            annotation.markAsRemovable()
        )
            
        default :
            null    
    }
;


//-----------------------------------------------------------------------------
// Transform Links Of States
//-----------------------------------------------------------------------------

/**
 * Transform links of states into transitions that don't use ports. Then
 * does the same recursively with the entity's child entities.
 * 
 * @param the entity whose links of states to transform.
 */
Void optimizeStates(Entity entity) :
    // List of the entity's ports (this is used to iterate over the ports,
    // removing them from the entity in the process -> avoids concurrent
    // modification exception)
    let ports = {} :
    
    // Add the entity's ports to the port list
    ports.addAll(entity.childPorts) ->
    
    if (entity.getAnnotation("ptolemyClass").value == "ptolemy.domains.modal.kernel.State")
        then (
            // The entity is indeed a state, so don't link its links
            // with ports
            reportWarning("state ports=" + ports) ->
            ports.moveLinksUp()
        )
        else
            null ->
    
    // Treat child entities recursively
    entity.childEntities.optimizeStates()
;

/**
 * Moves the links connected to the given port up to connect to the
 * port's entity. (a state)
 * 
 * @param port the port whose links to move up.
 */
Void moveLinksUp(Port port) :
    // Create new temp list to avoid concurrent modification exception
    let list = {} :
    
    reportWarning("moveLinkUp " + port.eContainer.getName() + "." + port.name) ->
    
    // Add all of the ports incoming and outgoing links to the list
    list.addAll(port.outgoingLinks) ->
    list.addAll(port.incomingLinks) ->
    
    // Make sure the port's links point in the correct direction
    ((List[Link]) list).fixLinkDirectionForState(port) ->
    
    // Actually do the work of moving the links up
    ((List[Link]) list).moveLinkUp(port) ->
    
    // Remove the port from its state
    port.remove()
;

/**
 * Makes the link connected to the given port point in the right
 * direction depending on the port's type. A Ptolemy State is an
 * Entity with exactly one input and one output. They carry a name
 * indicating the type of port, so that is used if the attribute
 * cannot be found.
 * 
 * @param link the link whose direction to set.
 * @param port the state's port connected to the link.
 */
Void fixLinkDirectionForState(Link link, Port port) :
    if (port.hasAnnotation("input") || port.name == "incomingPort") 
        then link.swapTargetTo(port)
        else link.swapSourceTo(port)
;

/**
 * Moves the link from its port up to the port's container. (a state)
 * 
 * @param link the link to move up.
 * @param port the port the link is currently connected to.
 */
Void moveLinkUp(Link link, Port port) :
    if (link.source == port) 
        then link.setSource(port.eContainer)
        else link.setTarget(port.eContainer)
;


//-----------------------------------------------------------------------------
// HELPER FUNCTIONS
//-----------------------------------------------------------------------------

/**
 * Returns the given object's name if it's a NamedObject, or the empty string
 * otherwise.
 * 
 * @param o the object whose name to return.
 * @return the object's name or the empty string.
 */
String getName(Object o) :
    if (NamedObject.isInstance(o))
        then ((NamedObject)o).name
        else ""
;

/**
 * Removes the given relation from its container.
 * 
 * @param relation the relation to be removed.
 */
Void remove(Relation relation) :
    ((Entity) relation.eContainer).childRelations.remove(relation)
;

/**
 * Removes the given link from its container.
 * 
 * @param link the link to be removed.
 */
Void remove(Link link) :
    link.setSource(null) -> 
    link.setTarget(null) ->
    ((Entity) link.eContainer).childLinks.remove(link) 
;

/**
 * Remove the given port from its container.
 * 
 * @param port the port to be removed.
 */
Void remove(Port port) :
    ((Entity) port.eContainer).childPorts.remove(port)
;

/**
 * Sets the direction of a link connected to a given port according to that
 * port's type. If the port type is unknown, nothing is done.
 * 
 * @param link the link whose direction to set.
 * @param port the port connected to the link.
 */
Void setLinkDirection(Link link, Port port) :
    let isPortTypeKnown = isPortTypeKnown(port) :
    let isInputPort = isMarkedAsInputPort(port) :
    
    if (!isPortTypeKnown)
        then null
        else (
		    switch {
		        case isInputPort == true  && link.eContainer == port.eContainer :
		            link.swapSourceTo(port)
		            
		        case isInputPort == false && link.eContainer == port.eContainer :
		            link.swapTargetTo(port)
		            
		        case isInputPort == true  && link.eContainer != port.eContainer :
		            link.swapTargetTo(port)
		            
		        case isInputPort == false && link.eContainer != port.eContainer :
		            link.swapSourceTo(port)
		            
		        default :
		            null
		    }
        )
;

/**
 * Swaps the link if the given linkable is its target. Otherwise, the link's source is
 * just set to the given linkable.
 * 
 * @param link the link to swap.
 * @param linkable the link's new source.
 */
Void swapSourceTo(Link link, Linkable linkable) :
    let source = link.source :
    let target = link.target :
    
    // Swap the link if the new source is the old target
    switch {
        case source == target :
            null
            
        case target == linkable :
            link.setTarget(source)
            
        default :
            null
    } ->
    
    // Set the source
    link.setSource(linkable) ->
    link.unmarkAsUndirected()
;

/**
 * Swaps the link if the given linkable is its source. Otherwise, the link's target is
 * just set to the given linkable.
 * 
 * @param link the link to swap.
 * @param linkable the link's new target.
 */
Void swapTargetTo(Link link, Linkable linkable):
    let source = link.source :
    let target = link.target :
    
    // Swap the link if the new target is the old source
    switch {
        case source == target :
            null
            
        case source == linkable :
            link.setSource(target)
            
        default :
            null
    } ->
    
    // Set the target
    link.setTarget(linkable) ->
    link.unmarkAsUndirected()
;

/**
 * Returns all links connected to the given linkable object.
 * 
 * @param linkable the linkable whose connected links to return.
 * @return list of links connected to the port.
 */
List[Link] getConnectedLinks(Linkable linkable) :
    let links = {} :
    
    links.addAll(linkable.incomingLinks) ->
    links.addAll(linkable.outgoingLinks) ->
    
    links
;


//-----------------------------------------------------------------------------
// Annotations
//-----------------------------------------------------------------------------

/**
 * Checks if the given element has an annotation with the given key.
 * 
 * @param annotatable element whose annotations to check.
 * @param key the key of the annotation to look for.
 * @return true if an annotation with the given key exists in the given
 *         element, false otherwise.
 */
Boolean hasAnnotation(Annotatable annotatable, String key) :
    (annotatable.getAnnotation(key) !=  null)
;

/**
 * Returns the value of the annotation with the given key if it is a
 * boolean annotation.
 * 
 * @param annotatable the element to search for the annotation in.
 * @param key key of the annotation to look for.
 * @return the annotation's value if it exists and is a boolean annotation,
 *         false otherwise.
 */
Boolean isBooleanAnnotation(Annotatable annotatable, String key) :
    let annotation = annotatable.getAnnotation(key) :
    
    switch {
        case annotation == null :
            false
            
        case BooleanAnnotation.isInstance(annotation) :
            ((BooleanAnnotation)annotation).value
            
        default :
            false
    }
;

/**
 * Add an annotation with the given key to the given element, if an annotation
 * with that key doesn't already exist.
 * 
 * @param annotatable element to annotate.
 * @param key the new annotation's key.
 */
Void addAnnotation(Annotatable annotatable, String key) :
    let annotation = new Annotation :
    
    if (hasAnnotation(annotatable, key) == false)
        then (
		    annotation.setName(key) ->
		    
		    annotatable.annotations.add(annotation)
        )
        else null
;

/**
 * Add an annotation with the given key-value pair to the given element, if
 * an annotation with that key doesn't already exist.
 * 
 * @param annotatable element to annotate.
 * @param key the new annotation's key.
 * @param value the new annotation's value.
 */
Void addStringAnnotation(Annotatable annotatable, String key, String value) :
    let annotation = new StringAnnotation :
    
    if (hasAnnotation(annotatable, key) == false)
        then (
		    annotation.setName(key) ->
		    annotation.setValue(value) ->
		    
		    annotatable.annotations.add(annotation)
        )
        else null
;

/**
 * Adds a boolean annotation to the given element, if an annotation
 * with that key doesn't already exist.
 * 
 * @param annotatable element to annotate.
 * @param key key of the new annotation.
 * @param value boolean value of the new annotation.
 */
Void addBooleanAnnotation(Annotatable annotatable, String key, Boolean value) :
    let annotation = new BooleanAnnotation :
    
    if (hasAnnotation(annotatable, key) == false)
        then (
		    annotation.setName(key) ->
		    annotation.setValue(value) ->
		    
		    annotatable.annotations.add(annotation)
        )
        else null
;

/**
 * Removes the annotation with the given key, if any.
 * 
 * @param annotatable element to remove the annotation from.
 * @param key key of the annotation.
 */
Void removeAnnotation(Annotatable annotatable, String key) :
    let annotation = annotatable.getAnnotation(key) :
    
    if (annotation != null)
        then annotatable.annotations.remove(annotation)
        else null
;


//-----------------------------------------------------------------------------
// Markings
//-----------------------------------------------------------------------------

/**
 * Marks the given link as being undirected. This is used to keep in mind the links
 * whose direction hasn't been determined yet.
 * 
 * @param link the link to mark.
 */
Void markAsUndirected(Link link) :
    addAnnotation(link, "undirected")
;

/**
 * Marks the given link as being directed.
 * 
 * @param link the link to mark.
 */
Void unmarkAsUndirected(Link link) :
    removeAnnotation(link, "undirected")
;

/**
 * Checks whether the given link is marked as being undirected.
 * 
 * @param link the link to check.
 * @return true if the link is marked as being undirected, false otherwise.
 */
Boolean isMarkedAsUndirected(Link link) :
    hasAnnotation(link, "undirected")
;

/**
 * Marks the given port as being an input port. Although it shouldn't be
 * necessary, any output port markings are removed.
 * 
 * @param port the port to be marked as input port.
 */
Void markAsInputPort(Port port) :
    removeAnnotation(port, "output") ->
    addAnnotation(port, "input")
;

/**
 * Checks whether the given port is marked as being an input port.
 * 
 * @param port the port to check.
 * @return true if the port is an input port, false otherwise.
 */
Boolean isMarkedAsInputPort(Port port) :
    hasAnnotation(port, "input")
;


/**
 * Marks the given port as being an output port. Although it shouldn't be
 * necessary, any input port markings are removed.
 * 
 * @param port the port to be marked as output port.
 */
Void markAsOutputPort(Port port) :
    removeAnnotation(port, "input") ->
    addAnnotation(port, "output")
;

/**
 * Checks whether the given port is marked as being an output port.
 * 
 * @param port the port to check.
 * @return true if the port is an output port, false otherwise.
 */
Boolean isMarkedAsOutputPort(Port port) :
    hasAnnotation(port, "output")
;

/**
 * Checks if the port's type is known.
 * 
 * @param port the port to check.
 * @return true if the port is marked as being either an input port or
 *         an output port.
 */
Boolean isPortTypeKnown(Port port) :
    isMarkedAsInputPort(port) || isMarkedAsOutputPort(port)
;

/**
 * Marks the given object as being ready for removal.
 * 
 * @param annotatable the object to mark.
 */
Void markAsRemovable(Annotatable annotatable) :
    addAnnotation(annotatable, "toBeRemoved")
;

/**
 * Checks whether the given object is marked as being ready for removal.
 * 
 * @param annotatable the object to check.
 * @return true if the object is marked as being ready for removal, false
 *         otherwise.
 */
Boolean isMarkedAsRemovable(Annotatable annotatable) :
    hasAnnotation(annotatable, "toBeRemoved")
;


//-----------------------------------------------------------------------------
// Logging
//-----------------------------------------------------------------------------

/**
 * Logs the given list at the INFO level and returns it.
 * 
 * @param input the list to print out.
 * @return the list.
 */
List infoAndReturn(List input) :
    info(input) ->
    input
;

/**
 * Reports the given list as a WARNING to the workflow and returns the list.
 * 
 * @param input the list to report.
 * @return the list.
 */
List reportWarningAndReturn(List input) :
    reportWarning("" + input) ->
    input
;


//-----------------------------------------------------------------------------
// JAVA ESCAPE DECLARATIONS
//-----------------------------------------------------------------------------

/**
 * Returns a list of all the ports of the given entity types.
 * 
 * @param entities list of Ptolemy entity types whose ports to return.
 * @return list of KAOM ports.
 */
List getPorts(List[EntityType] entities) :
    JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.getPorts(java.util.List) 
;
