import kaom;
import annotations;
import Moml;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

//-----------------------------------------------------------------------------
//     Ptolemy - 2 - KAOM    TRANSFORMATION    
//     @author: haf
//-----------------------------------------------------------------------------
  
//Start Model Transformation here.
create Entity this transform(DocumentRoot root):
 	let entity = transform(root.entity) :
 	this.childEntities.add(entity) ->
 	this.optimize()
;   
 
create Entity this transform(Moml::EntityType entity):
	let list = {}:
	this.setName(entity.name) ->
	createTrace(this,entity,"ptolemy","kaom") ->
	this.addAnnotation("ptolemyClass",entity.class1) ->
	addProperties(this, entity.property) ->
	addChildPorts(this) ->
	addChildEntities(this, entity.entity) ->
	addChildRelations(this, entity.relation) ->
	addChildLinks(this, entity.link) 
;

create Relation this transform(Moml::RelationType relation):
	this.setName(relation.name) ->
	createTrace(this,relation,"ptolemy","kaom") ->
	addProperties(this, relation.property)
;

// create a new link in kaom from a Ptolemy link. The problem is that a ptolemy link
// is (1) undirected and (2) has multiple possible attributes for head and tail, because
// it can connect a port and a relation or two relations, e.g.
// <link port="Ramp.output" relation="relation1"/>
// <link relation1="relation20" relation2="relation21"/>
create Link this transform(Moml::LinkType link, Entity parent):
	let relation = parent.getRelation(link.relation):
	let relation1 = parent.getRelation(link.relation1):
	let relation2 = parent.getRelation(link.relation2):
	let port = if(link.port == null) then null else parent.getPort(link.port):
	let linkables = {}:
	createTrace(this,link,"ptolemy","kaom") ->
	(if(port != null) then (linkables.add(port)) else (null)) ->
	(if(relation != null) then (linkables.add(relation)) else (null)) ->
	(if(relation1 != null) then (linkables.add(relation1)) else (null)) ->
	(if(relation2 != null) then (linkables.add(relation2)) else (null)) ->
	(if(linkables.size == 2) then (this.setSource(linkables.get(0)) -> this.setTarget(linkables.get(1)))	else (null)) ->
	// initially set all relations to be undirected
	this.addUndirectedAnnotation()
;

Void addChildEntities(Entity parent, List[EntityType] ptolemyEntities):
	let ptolemyEntity = ptolemyEntities.first():
	if(ptolemyEntities.isEmpty) then null else
		parent.childEntities.add(transform(ptolemyEntity)) ->
		addChildEntities(parent, ptolemyEntities.withoutFirst())
;

Void addChildRelations(Entity parent, List[RelationType] ptolemyRelations):
	let ptolemyRelation = ptolemyRelations.first():
	if(ptolemyRelations.isEmpty) then null else
		parent.childRelations.add(transform(ptolemyRelation)) ->
		addChildRelations(parent, ptolemyRelations.withoutFirst())
;

Void addChildLinks(Entity parent, List[LinkType] ptolemyLinks):
	let ptolemyLink = ptolemyLinks.first():
	if(ptolemyLinks.isEmpty) then null else
		parent.childLinks.add(transform(ptolemyLink, parent)) ->
		addChildLinks(parent, ptolemyLinks.withoutFirst())
;

Void addProperties(Annotatable annotatable, List[PropertyType] properties):
	let property = properties.first():
	let stringAnnotation = new StringAnnotation:
	let classType = new StringAnnotation:
	if(properties.isEmpty) then null else
		stringAnnotation.setName(property.name) ->
		stringAnnotation.setValue(property.value) ->
		classType.setName("ptolemyClass") ->
		classType.setValue(property.class) ->
		stringAnnotation.annotations.add(classType) ->
		annotatable.annotations.add(stringAnnotation)->
		// recursively add nested annotations
		stringAnnotation.addProperties(property.property) ->
		// now add remaining properties
		addProperties(annotatable, properties.withoutFirst())
;



// Ports are not necessarily explicit objects in a ptolemy model. Usually they are
// created implicitly in an Actor's Java implementation. Hence to see what ports
// an entity has, we need to instanciate that actor in Ptolemy. If the actor is not available
// in KIELER's Ptolemy library, this might fail and will not set up the ports
// correctly. Then the ports will be added when they are first referenced later on. However, then
// specific attributes of the ports (e.g. input or output) will be unavailable.
Void addChildPorts(Entity entity):
	let ptolemyEntity = (EntityType)entity.getSingleTraceTarget("ptolemy"):
	let entityList = {ptolemyEntity}:
	let javaPorts = getPorts(entityList):
	let explicitPorts = ptolemyEntity.port.transform():
	let mergedPorts = mergePortAttributes(javaPorts,explicitPorts):
	entity.childPorts.addAll(mergedPorts)
;

create Port this transform(Moml::PortType ptolemyPort):
	this.setName(ptolemyPort.name) -> 
	createTrace(this,ptolemyPort,"ptolemy","kaom") ->
	addProperties(this,ptolemyPort.property) // this might add "input"/"output" annotations
;

Relation getRelation(Entity parent,String relationName):
	let relation = parent.childRelations.selectFirst(r|r.name == relationName):
	relation
;

// get a port with a name like "Ramp.output", where the first part is the actor in the
// given parent and the second is the port name
// search for such existing port. If it does not exist, create it and add it to the model.
Port getPort(Entity parent, String portName):
	let newPort = new Port:
	let splitName = portName.split("\\."):
	let actor = splitName.size > 0 ? parent.childEntities.selectFirst(a|a.name == splitName.get(0)): null:
	let port = switch{
		case splitName.size > 1 : actor.childPorts.selectFirst(p|p.name == splitName.get(1))
		case splitName.size == 1: parent.childPorts.selectFirst(p|p.name == portName)
		default: null
	}:
	switch{
		case portName == null :  
			(reportWarning("Port with no name requested for Entity "+parent.name)->
			null)
		case port != null : port
		case actor == null :( 
			reportWarning("Non-Existing Port referenced: "+portName+" for Entity "+parent.name) 
			-> newPort.setName(portName)
			-> parent.childPorts.add(newPort) 
			-> newPort)
		default: 
			(reportWarning("Non-Existing Port referenced: "+portName) 
			-> newPort.setName(splitName.size < 2? "null" : splitName.get(1)) 
			-> actor.childPorts.add(newPort) 
			-> newPort)
	}
;

List[Port] mergePortAttributes(List[Port] newPorts, List[Port] existingPorts):
	switch{
		case newPorts == null || newPorts.size == 0: existingPorts
		case existingPorts == null || existingPorts.size == 0: newPorts
		default: newPorts.mergePortAttributesSingle(existingPorts)  
	}
;

Port mergePortAttributesSingle(Port newPort, List[Port] existingPorts):
	let samePort = existingPorts.select(p|p.name == newPort.name).first():
	if(samePort == null) then newPort else (samePort.annotations.addAll(newPort.annotations) -> samePort)
;

String getName(Object o):
	if(NamedObject.isInstance(o)) then ((NamedObject)o).name else ""
;

List getPorts(List[EntityType] entities) :
  JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.getPorts(java.util.List) 
;

// --------------------------------------------------------------------------------------------
//    OPTIMIZATION RULES
// --------------------------------------------------------------------------------------------

// entry points for optimizations
Void optimize(Entity entity):
	analyzeLinkDirections(entity) ->
	// optimizeStates has to be before relation optimization because it fixes link directions
	optimizeStates(entity) ->
	optimizeSingleRelations(entity) ->
	optimizeAnnotationRepresentation(entity)
	
;

// --------------------------------------------------------------------------------------------
//    Analysis of Link directions (Ptolemy Links are undirected)
// --------------------------------------------------------------------------------------------

Void analyzeLinkDirections(Entity entity):
	entity.childEntities.analyzeLinkDirections() -> // depth first 
	// set directions for links connected directly to inputs/outputs
	analyzeLinkDirectionsForPorts(entity.childPorts) ->
	// then analyze other links from the neighbor information
	analyzeLinkDirectionsForLinksFixpoint(entity.childLinks)
;

// Set Link directions for all connected Links to a List of Ports 
// using the port input/output information
Void analyzeLinkDirectionsForPorts(List[Port] ports):
	if(ports.size <= 0) then null else ( 
		analyzeLinkDirections(ports.first()) ->
		analyzeLinkDirectionsForPorts(ports.withoutFirst()))
;

// Set Link directions for all connected Links to a Port 
// using the port input/output information
Void analyzeLinkDirections(Port port):
	let isInput = port.hasAnnotation("input"):
	let isOutput = port.hasAnnotation("output"):
	switch{
		case isInput && isOutput : null
		case isInput : 	port.getConnectedLinks().setLinkDirection(port, true)
		case isOutput:  port.getConnectedLinks().setLinkDirection(port, false)
		default: null
	}
;

// Set directions of all links to a port which is known to be an input or output
Void setLinkDirection(Link link, Port port, Boolean isInput):
	switch{
		case isInput == true  && link.eContainer == port.eContainer : link.swapSourceTo(port)
		case isInput == false && link.eContainer == port.eContainer : link.swapTargetTo(port)
		case isInput == true  && link.eContainer != port.eContainer : link.swapTargetTo(port)
		case isInput == false && link.eContainer != port.eContainer : link.swapSourceTo(port)
		default: null
	}
;

// Do a fixpoint iteration on a set of Links and try to deduce link directions from
// neighbor edges
Void analyzeLinkDirectionsForLinksFixpoint(List[Link] links):
	let hasChanged = links.analyzeLinkDirectionForLink().exists(b|b==true):
	if(hasChanged) then analyzeLinkDirectionsForLinksFixpoint(links) else null
;

// Given a link and up to two relations, deduce from neighbor links the link's direction
Boolean analyzeLinkDirectionForLink(Link link):
	let relations = {link.source, link.target}.typeSelect(kaom::Relation):
	let switchedAtRel1 = if(relations.size <1) then false else analyzeLinkDirectionForLink(link,relations.get(0)):
	let switchedAtRel2 = if(relations.size <2) then false else analyzeLinkDirectionForLink(link,relations.get(1)):
	switchedAtRel1 || switchedAtRel2
;

// Given a link and one relation, deduce from neighbor links the link's direction
Boolean analyzeLinkDirectionForLink(Link link, Relation relation):
	let neighborLinks = {} : 
	if(link.isUndirected()) 
		then  (neighborLinks.addAll(relation.outgoingLinks)
		    -> neighborLinks.addAll(relation.incomingLinks) 
			-> neighborLinks.analyzeLinkDirection(relation,link).exists(b|b==true))
		else false
;

Boolean analyzeLinkDirection(Link neighborLink, Relation relation, Link link):
	switch{
		case (link.source == link.target) : false
		case ( (neighborLink.target == relation) && (neighborLink.isUndirected())):
			(link.swapSourceTo(relation) -> true)
		case ( (neighborLink.source == relation) && (neighborLink.isUndirected())):
			(link.swapTargetTo(relation) -> true)
		default : false
	}
;

Void swapSourceTo(Link link, Linkable linkable):
	let source = link.source:
	let target = link.target:
	switch{
		case source == target: null // check for selfloop
		case target == linkable: link.setTarget(source)
		default: null
	}->
	link.setSource(linkable) ->
	link.removeUndirectedAnnotation()
;

Void swapTargetTo(Link link, Linkable linkable):
	let source = link.source:
	let target = link.target:
	switch{
		case source == target: null // check for selfloop
		case source == linkable: link.setSource(target)
		default: null
	}->
	link.setTarget(linkable) ->
	link.removeUndirectedAnnotation()
;


// --------------------------------------------------------------------------------------------
//    Optimization of single Relations (Ptolemy has always one relation)
// --------------------------------------------------------------------------------------------

Void optimizeSingleRelations(Entity entity):
	entity.childRelations.optimizeSingleRelation() ->
	// remove in a second iteration to avoid concurrent modification exceptions
	entity.childLinks.select(a|a.getAnnotation("toBeRemoved")!=null).remove() ->
	entity.childRelations.select(a|a.getAnnotation("toBeRemoved")!=null).remove() ->
	entity.childEntities.optimizeSingleRelations()
;

Void optimizeSingleRelation(Relation relation):
	let inLink  = relation.incomingLinks.first():
	let outLink = relation.outgoingLinks.first():
	if( (relation.incomingLinks.size == 1) && (relation.outgoingLinks.size == 1) ) then(
		inLink.setTarget(outLink.target) -> 
		outLink.addAnnotation("toBeRemoved") ->
		relation.addAnnotation("toBeRemoved")
	) else null	
;

Void remove(Relation relation):
	((Entity)relation.eContainer).childRelations.remove(relation)
;

Void remove(Link link):
	link.setSource(null) 
	-> link.setTarget(null)
	-> ((Entity)link.eContainer).childLinks.remove(link) 
;

Void remove(Port port):
	((Entity)port.eContainer).childPorts.remove(port)
;

// --------------------------------------------------------------------------------------------
//    Transform some special Annotations to visible Entities
// --------------------------------------------------------------------------------------------

Void optimizeAnnotationRepresentation(Entity entity):
	entity.annotations.optimizeAnnotationRepresentation() ->
	entity.annotations.removeAll(entity.annotations.select(a|a.getAnnotation("toBeRemoved")!=null)) ->
	entity.childEntities.optimizeAnnotationRepresentation()  
;

// Marks an Annotation as "toBeRemoved". In another iteration it may be removed. This is
// necessary to avoid concurrent modification exceptions during iteration of an annotation list.
Void optimizeAnnotationRepresentation(Annotation annotation):
	let isTopLevel = Entity.isInstance(annotation.eContainer) :
	let topLevel = (Entity)annotation.eContainer :
	let newEntity = new Entity: 
	// need to clone the attribute to avoid concurrent modification (remove while iterating)
	let clonedAnnotation = annotation.clone():
	let marker = new Annotation:
	let annoMarker = new Annotation:
	switch{
		// if the entity already is an annotation representation, don't do anything
		case topLevel.getAnnotation("annotationNode") != null : null
		case isTopLevel && annotation.getAnnotation("ptolemyClass").value.matches(".*Director") : (
			newEntity.setName(annotation.getName()) ->
			marker.setName("annotationNode") ->
			newEntity.annotations.add(marker) ->
			newEntity.annotations.add(clonedAnnotation) -> // move annotation to the new Entity
			topLevel.childEntities.add(newEntity) ->
			annoMarker.setName("toBeRemoved") ->
			annotation.annotations.add(annoMarker)
		) 
		case isTopLevel && annotation.getAnnotation("ptolemyClass").value.matches("ptolemy.vergil.kernel.attributes.TextAttribute") : (
			// TODO: stupid way to display a big text
			newEntity.setName(annotation.getAnnotation("text").value) ->
			marker.setName("annotationNode") ->
			newEntity.annotations.add(marker) ->
			newEntity.annotations.add(clonedAnnotation) -> // move annotation to the new Entity
			topLevel.childEntities.add(newEntity) ->
			annoMarker.setName("toBeRemoved") ->
			annotation.annotations.add(annoMarker)
		)
		default: null	
	}
;

// --------------------------------------------------------------------------------------------
//    Transform links of states into transitions that dont use ports
// --------------------------------------------------------------------------------------------

Void optimizeStates(Entity entity):
	// temp list for iteration
	let ports = {}:
	ports.addAll(entity.childPorts) ->
	if(entity.getAnnotation("ptolemyClass").value == "ptolemy.domains.modal.kernel.State") then
			(reportWarning("size="+ports)->ports.moveLinksUp())
	else null ->
	entity.childEntities.optimizeStates()
;

Void moveLinksUp(Port port):
	// create new temp list to avoid concurrent modification exception
	let list = {}:
	reportWarning("moveLinkUp "+port.eContainer.getName() + "." + port.name) ->
	list.addAll(port.outgoingLinks) ->
	list.addAll(port.incomingLinks) ->
	((List[Link])list).fixLinkDirectionForState(port) ->
	((List[Link])list).moveLinkUp(port) ->
	port.remove()
;

Void moveLinkUp(Link link, Port port):
	//reportWarning("moveLinkUp "+port.eContainer.getName() + "." + port.name) ->
	if(link.source == port) 
	then link.setSource(port.eContainer)
	else link.setTarget(port.eContainer)
;

// a Ptolemy State is an Entity with exactly one input and one output
// they carry a name indicating the type of port, so use that if the attribute cannot
// be found
Void fixLinkDirectionForState(Link link, Port port):
	if(port.hasAnnotation("input") || port.name == "incomingPort") 
	then link.swapTargetTo(port)
	else link.swapSourceTo(port)
;

// --------------------------------------------------------------------------------------------
//    Helper functions
// --------------------------------------------------------------------------------------------

Boolean isBooleanAnnotation(Annotatable annotatable, String key):
	let annotation = annotatable.getAnnotation(key):
	switch {
		case annotation == null: false
		case BooleanAnnotation.isInstance(annotation) : ((BooleanAnnotation)annotation).value
		default: false
	}
;

Void addBooleanAnnotation(Annotatable annotatable, String key, Boolean value):
	let annotation = new BooleanAnnotation:
	annotation.setName(key) ->
	annotation.setValue(value) ->
	annotatable.annotations.add(annotation)
;

Boolean hasAnnotation(Annotatable annotatable, String key):
	(annotatable.getAnnotation(key) !=  null)
;

Void addAnnotation(Annotatable annotatable, String key, String value):
	let annotation = new StringAnnotation:
	annotation.setName(key) ->
	annotation.setValue(value) ->
	annotatable.annotations.add(annotation)
;

Void addAnnotation(Annotatable annotatable, String key):
	let annotation = new Annotation:
	annotation.setName(key) ->
	annotatable.annotations.add(annotation)
;

List[Link] getConnectedLinks(Port port):
	let links = {}:
	links.addAll(port.incomingLinks) ->
	links.addAll(port.outgoingLinks) ->
	links
;

Void addUndirectedAnnotation(Link link):
	let annotation = new Annotation:
	annotation.setName("undirected") ->
	link.annotations.add(annotation)
;

Boolean isUndirected(Link link):
	(link.getAnnotation("undirected") != null)
;

Void removeUndirectedAnnotation(Link link):
	let annotation = link.getAnnotation("undirected"):
	if(annotation != null) then link.annotations.remove(annotation) else null 
;

List infoAndReturn(List input):
	info(input) -> input
;

List reportWarningAndReturn(List input):
	reportWarning(""+input) -> input
;

