import kaom;
import Moml;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
//extension org::eclipse::xtend::util::stdlib::crossref;  // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

//-----------------------------------------------------------------------------
//     Ptolemy - 2 - KAOM    TRANSFORMATION    
//     @author: haf
//-----------------------------------------------------------------------------
  
//Start Model Transformation here.
create State this transform(DocumentRoot root):
 	this.childEntities.add(transform(root.entity))
;   

create Actor this transform(Moml::EntityType entity):
	let list = {}:
	this.setName(entity.name) ->
	createTrace(this,entity,"ptolemy","kaom") ->
	info("Created entity "+entity.name) ->
//	test(entity,"bla",list) ->
	addProperties(this, entity.property) ->
	addChildPorts(this) ->
	addChildEntities(this, entity.entity) ->
	addChildRelations(this, entity.relation) ->
	addChildLinks(this, entity.link) 
;

create Relation this transform(Moml::RelationType relation):
	this.setName(relation.name) ->
	createTrace(this,relation,"ptolemy","kaom") ->
	addProperties(this, relation.property)
;

// create a new link in kaom from a Ptolemy link. The problem is that a ptolemy link
// is (1) undirected and (2) has multiple possible attributes for head and tail, because
// it can connect a port and a relation or two relations, e.g.
// <link port="Ramp.output" relation="relation1"/>
// <link relation1="relation20" relation2="relation21"/>
create Link this transform(Moml::LinkType link, Entity parent):
	let relation = parent.getRelation(link.relation):
	let relation1 = parent.getRelation(link.relation1):
	let relation2 = parent.getRelation(link.relation2):
	let port = parent.getPort(link.port):
	let linkables = {}:
	createTrace(this,link,"ptolemy","kaom") ->
	(if(port != null) then (linkables.add(port)) else (null)) ->
	(if(relation != null) then (linkables.add(relation)) else (null)) ->
	(if(relation1 != null) then (linkables.add(relation1)) else (null)) ->
	(if(relation2 != null) then (linkables.add(relation2)) else (null)) ->
	(if(linkables.size == 2) then (this.setSource(linkables.get(0)) -> this.setTarget(linkables.get(1)))	else (null)) ->
	this.setName("link")
;

Void addChildEntities(Entity parent, List[EntityType] ptolemyEntities):
	let ptolemyEntity = ptolemyEntities.first():
	if(ptolemyEntities.isEmpty) then null else
		parent.childEntities.add(transform(ptolemyEntity)) ->
		addChildEntities(parent, ptolemyEntities.withoutFirst())
;

Void addChildRelations(Entity parent, List[RelationType] ptolemyRelations):
	let ptolemyRelation = ptolemyRelations.first():
	if(ptolemyRelations.isEmpty) then null else
		parent.childRelations.add(transform(ptolemyRelation)) ->
		addChildRelations(parent, ptolemyRelations.withoutFirst())
;

Void addChildLinks(Entity parent, List[LinkType] ptolemyLinks):
	let ptolemyLink = ptolemyLinks.first():
	if(ptolemyLinks.isEmpty) then null else
		parent.childLinks.add(transform(ptolemyLink, parent)) ->
		addChildLinks(parent, ptolemyLinks.withoutFirst())
;

Void addProperties(Annotatable annotatable, List[PropertyType] properties):
	let property = properties.first():
	if(properties.isEmpty) then null else
		annotatable.addAnnotation(property.name, property.value)->
		addProperties(annotatable, properties.withoutFirst())
;

Void addAnnotation(Annotatable annotatable, String key, String value):
	let entry = new AnnotationMapEntry:
	let annotation = new StringAnnotation:
	entry.setKey(key) ->
	annotation.setValue(value) ->
	entry.setValue(annotation) ->
	annotatable.annotationMap.add(entry)
;

// Ports are not necessarily explicit objects in a ptolemy model. Usually they are
// created implicitly in an Actor's Java implementation. Hence to see what ports
// an entity has, we need to instanciate that actor in Ptolemy. If the actor is not available
// in KIELER's Ptolemy library, this might fail and will not set up the ports
// correctly. Then the ports will be added when they are first referenced later on. However, then
// specific attributes of the ports (e.g. input or output) will be unavailable.
Void addChildPorts(Entity entity):
	let ptolemyEntity = (EntityType)entity.getSingleTraceTarget("ptolemy"):
//	let ports = ptolemyEntity.getPorts(): // this will instanciate the Entity in Ptolemy
//	info(entity.getName() + " yields " + ports.size() + " ports.") -> 
//	entity.childPorts.addAll(ports)
	let entityList = {ptolemyEntity}:
	let portList = getPorts(entityList):
	entity.childPorts.addAll(portList)
;

Relation getRelation(Entity parent,String relationName):
	let relation = parent.childRelations.selectFirst(r|r.name == relationName):
	relation
;

// get a port with a name like "Ramp.output", where the first part is the actor in the
// given parent and the second is the port name
// search for such existing port. If it does not exist, create it and add it to the model.
Port getPort(Entity parent, String portName):
	let newPort = new Port:
	let splitName = portName.split("\\."):
	let actor = splitName.size > 0 ? parent.childEntities.selectFirst(a|a.name == splitName.get(0)): null:
	let port = splitName.size > 1 ? actor.childPorts.selectFirst(p|p.name == splitName.get(1)): null:
	
	if(portName == null || splitName.size < 2) then(
		//newPort.setName("Invalid:"+portName) ->
		//parent.childPorts.add(newPort) ->
		//newPort
		reportWarning("A port with name "+portName+" was requested but was neither found nor created")->
		null
	)	
	else
		if(port != null) then
			port
		else
			(newPort.setName(splitName.get(1)) ->
			actor.childPorts.add(newPort) ->
			newPort)
;

String getName(Object o):
	if(NamedObject.isInstance(o)) then ((NamedObject)o).name else ""
;

// have to call get Ports indirectly with an empty list parameter because Java extensions
// may not have a return value
//List[Port] getPorts(EntityType entity) :
//   let ports = {}:
//   entity.getPorts(ports) -> 
//   ports
//;

List getPorts(List[EntityType] entities) :
  JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.getPorts(java.util.List) // org.eclipse.emf.common.util.EList)
;

// does not work
//Void getPorts(EntityType entity, List ports) :
//  JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.getPorts(ptolemy.Moml.EntityType,java.util.List) // org.eclipse.emf.common.util.EList)
//;

List[Port] getPorts(EntityType entity):
	let ports = {}:
	getPort(entity, 0, ports)
;

// recursive function to retrieve all ports of an entity
List[kaom::Port] getPort(EntityType entity, Integer index, List[kaom::Port] inputList):
	let nextPort = {}: // entity.getPort(index):
	if(nextPort != null) then
		(
		inputList.add(nextPort) ->
		getPort(entity, index+1, inputList)	
		)
	else inputList
;

kaom::Port getPort(EntityType entity, Integer index):
	JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.getPort(ptolemy.Moml.EntityType, java.lang.Integer)
;

Void test(EntityType entity, String msg, List[Port] ports) :
 	 JAVA de.cau.cs.kieler.kaom.importer.ptolemy.PtolemyHelper.test(ptolemy.Moml.EntityType, java.lang.String, java.util.List)
;
