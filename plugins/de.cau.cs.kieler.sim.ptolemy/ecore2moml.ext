import synccharts;
import Moml;

//-----------------------------------------------------------------------------
//--            S S M - 2 - P T O       T R A N S F O R M A T I O N          --
//-----------------------------------------------------------------------------

//Start Model Transformation here
create DocumentRoot this transform(synccharts::Region sc):
 	this.setEntity(createBaseEntity(sc))
;   
	
	
//-----------------------------------------------------------------------------
//--       B A S I C   M O M L - E N T I T I E S   C R E A T I O N           --
//-----------------------------------------------------------------------------

//create basic / outer most enclosing entity	
create EntityType this createBaseEntity(synccharts::Region mainRegion):
   	this.setName(mainRegion.innerStates.get(0).name + "_simulation") ->
  	this.setClass1("ptolemy.actor.TypedCompositeActor") ->
   	this.property.add(createMainSRDirector()) ->
   	//mainRegion has exactly ONE top most state
   	//iterate over all regions within this top most state
   	//the name of this containing Entity is derived from this
   	//   top most state, w/ " simulation" added
    IterateRegions(mainRegion.innerStates.get(0).regions, this, mainRegion.innerStates.get(0).signals)
    //add "this" EntityType so that IterateRegions is able to add 
    //new entities or properties
;


//create ModalModel == Region-Component 
create EntityType this createModalModelEntity(synccharts::Region region, 
											  int number, 
											  List[synccharts::Signal] signalList):
	let p1 = new PropertyType:
		p1.setName("_tableauFactory") ->
		p1.setClass("ptolemy.vergil.fsm.modal.ModalTableauFactory") ->
	this.property.add(p1) ->
   	this.setName(region.parentState.name + "_region_" + number) ->
  	this.setClass1("ptolemy.domains.fsm.modal.ModalModel") ->
  	//first add signals
  	addSignalsToModalModel(this,signalList) ->
  	//then create simple states and macro state declarations
   	this.entity.add(createModalControllerEntity(region)) ->
   	//then add macro state refinements (for all macro states)
   	IterateStatesRefinement(region.innerStates, this, signalList)
;
//create ModalController == Region-Declaration (simple states and macro states declarations)
create EntityType this createModalControllerEntity(synccharts::Region region):
   	this.setName("_Controller") ->
  	this.setClass1("ptolemy.domains.fsm.modal.ModalController") ->
  	//first add signals
	addSignalsToModalController(this,signalList) ->  	
  	//then iterated all states
	IterateStates(region.innerStates, this)
;


//create MacroState == State-Component (of a macro state)
create EntityType this createMacroStateEntity(synccharts::State state):
	let p1 = new PropertyType:
		p1.setName("refinementName") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p1.setValue(state.name) ->
   	this.setName(state.name) ->
  	this.setClass1("ptolemy.domains.fsm.kernel.State") ->
	this.property.add(p1) ->
  	SetStateInitialFinalFlag(state, this)
;
//create ModalRefinement == State-Definition (of a macro state /w regions)
create EntityType this createMacroStateRefinementEntity(synccharts::State state,
														List[synccharts::Signal] signalList):
   	this.setName(state.name) ->
  	this.setClass1("ptolemy.domains.fsm.modal.Refinement") ->
   	this.property.add(createSRDirector()) ->
   	signalList.addAll(state.signals) ->
   	IterateRegions(state.regions, this, signalList)
;
//create SimpleState == State-Component 
create EntityType this createSimpleStateEntity(synccharts::State state):
   	this.setName(state.name) ->
  	this.setClass1("ptolemy.domains.fsm.kernel.State") ->
  	SetStateInitialFinalFlag(state, this)
;


//-----------------------------------------------------------------------------
//--                   H E L P E R    F U N C T I O N S                      --
//-----------------------------------------------------------------------------

//do some java console output for debugging purpose 
Void dump(String s) :
	JAVA de.cau.cs.kieler.sim.ptolemy.XtendJavaSystemOutput.dump(java.lang.String)
;

//decide whether a states is initial or final and add the appropriate
//property to the entity
void SetStateInitialFinalFlag(synccharts::State state, EntityType entity) :
	let p1 = new PropertyType:
	let p2 = new PropertyType:
		p1.setName("isInitialState") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("true") ->
		p2.setName("isFinalState") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
  	state.stateFlag.toString().matches("INITIAL") ? entity.property.add(p1) : null
  	//do not set it to final, otherwise it can't even being reset! 
  	//state.stateFlag.toString().matches("FINAL") ? entity.property.add(p2) : null
;

//test whether a state is a macro state or a simple state
boolean IsMacroState(synccharts::State state) :
 	state.regions.size > 0
; 


//-----------------------------------------------------------------------------
//--                       I T E R A T I O N S                               --
//-----------------------------------------------------------------------------

//iteratate over all states (in a region)
//for  macro states : add states entity AND list them as a refinement property
//for simple states : add states
void IterateTransitions(List[synccharts::Transition] transitionList,
							 EntityType entity):
 	let transition = transitionList.last():
 	(transitionList.size > 0) ? dump(transition.sourceState.name + " -> " + transition.targetState.name) : null ->
	(transitionList.size > 0) ? addTransition(transition,
				  							  entity,
				  							  transition.sourceState.name + "_transition_" + transitionList.size) :null -> 	
    (transitionList.size > 1) ? IterateTransitions(transitionList.withoutLast(), entity) : null
;


//iteratate over all states (in a region)
//for  macro states : add states entity AND list them as a refinement property
//for simple states : add states
void IterateStates(List[synccharts::State] stateList, 
						EntityType entity):
 	let state = stateList.last():
 	IsMacroState(state) ? entity.entity.add(createMacroStateEntity(state)) 
 					    : entity.entity.add(createSimpleStateEntity(state)) ->
 	IterateTransitions(state.outgoingTransitions, entity) ->
    (stateList.size > 1) ? IterateStates(stateList.withoutLast(), entity) : null
;

//iteratate over all states (in a region)
//for  macro states : define the refinement (and recursively add regions!)
//for simple states : do nothing
void IterateStatesRefinement(List[synccharts::State] stateList, 
								  EntityType entity, 
								  List[synccharts::Signal] signalList):
 	let state = stateList.last():
 	IsMacroState(state) ? entity.entity.add(
 							createMacroStateRefinementEntity(state, signalList)) 
 						: null ->
    (stateList.size > 1) ? IterateStatesRefinement(stateList.withoutLast(), entity, signalList) : null
;


//iterate over all regions (in a state)
//add an own modal model for each region
//define all signals that are defined until now!
void IterateRegions(List[synccharts::Region] regionList, 
						EntityType entity, 
						List[synccharts::Signal] signalList):
 	let region = regionList.last():
 	entity.entity.add(createModalModelEntity(region, regionList.size, signalList)) ->
    (regionList.size > 1) ? IterateRegions(regionList.withoutLast(), entity, signalList) : null 
; 


//-----------------------------------------------------------------------------
//--                 C R E A T E     D I R E C T O R S                       --
//-----------------------------------------------------------------------------

//create a "SR Director" (for macro state definition)
create PropertyType this createSRDirector():
    this.setName("SR Director") ->
	this.setClass("ptolemy.domains.sr.kernel.SRDirector")
;

//create outer most "SR Director" (ticks every seconds)
create PropertyType this createMainSRDirector():
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4 = new PropertyType:
		p1.setName("iterations") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("Infinity") ->
		p2.setName("synchronizeToRealTime") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
		p3.setName("timeResolution") ->
		p3.setClass("ptolemy.data.expr.Parameter") ->
		p3.setValue("1.0E-10") ->
		p4.setName("period") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		p4.setValue("1") ->
    this.setName("SR Director") ->
	this.setClass("ptolemy.domains.sr.kernel.SRDirector") ->
	this.property.add(p1) ->
	this.property.add(p2) ->
	this.property.add(p3) ->
	this.property.add(p4)
;


//create a "FSM Director" (for a region component)
create PropertyType this createFSMDirector():
    this.setName("directorClass") ->
    this.setValue("ptolemy.domains.fsm.kernel.FSMDirector") ->
	this.setClass("ptolemy.data.expr.StringParameter")
;

//create a "DE Director" (for the outer most entity)
create PropertyType this createDEDirector():
	let p1 = new PropertyType:
	let p2 = new PropertyType:
		p1.setName("stopTime") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("Infinity") ->
		p2.setName("synchronizeToRealTime") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
    this.setName("DE Director") ->
	this.setClass("ptolemy.domains.de.kernel.DEDirector") ->
	this.property.add(p1) ->
	this.property.add(p2)
;

//-----------------------------------------------------------------------------
//--         C R E A T E     R E L A T I O N S   &   L I N K S               --
//-----------------------------------------------------------------------------

void addTransition(	synccharts::Transition transition, 
					EntityType entity,
					String name) :
	let link1 = new LinkType:
	let link2 = new LinkType:
	link1.setPort(transition.sourceState.name + ".outgoingPort") ->
	link1.setRelation(name) ->
	link2.setPort(transition.targetState.name + ".incomingPort") ->
	link2.setRelation(name) ->
	entity.relation.add(createRelation(name, transition)) ->
	entity.link.add(link1) ->
	entity.link.add(link2) 
;

//create a Relation Type
create RelationType this createRelation(String name,
										synccharts::Transition transition):
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4 = new PropertyType:
	let p5 = new PropertyType:
	let p6 = new PropertyType:
	let p7 = new PropertyType:
	let p8 = new PropertyType:
		p1.setName("guardExpression") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p2.setName("outputActions") ->
		p2.setClass("ptolemy.domains.fsm.kernel.OutputActionsAttribute") ->
		p3.setName("setActions") ->
		p3.setClass("ptolemy.domains.fsm.kernel.CommitActionsAttribute") ->
		p4.setName("reset") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		//by default in SyncCharts we have a reset behavior unless its 
		//a history transition
		(!transition.history) ? p4.setValue("true") : p4.setValue("false") ->
		p5.setName("preemptive") ->
		p5.setClass("ptolemy.data.expr.Parameter") ->
		transition.transitionKind.toString().matches("STRONGABORT") ? 
								p5.setValue("true") : p5.setValue("false") ->
		p6.setName("defaultTransition") ->
		p6.setClass("ptolemy.data.expr.Parameter") ->
		p6.setValue("false") -> //defaultTransition is NOT "normal termination" !!!
		//transition.transitionKind.toString().matches("NORMALTERMINATION") ? 
		//						p6.setValue("true") : p6.setValue("false") ->
		p7.setName("nondeterministic") ->
		p7.setClass("ptolemy.data.expr.Parameter") ->
		p7.setValue("false") ->
		p8.setName("refinementName") ->
		p8.setClass("ptolemy.kernel.util.StringAttribute") ->
    this.setName(name) ->
	this.property.add(p1) ->
	this.property.add(p2) ->
	this.property.add(p3) ->
	this.property.add(p4) ->
	this.property.add(p5) ->
	this.property.add(p6) ->
	this.property.add(p7) ->
	this.property.add(p8) ->
	addTrigger(this, transition) ->
	addEmission(this, transition)
;

//-----------------------------------------------------------------------------
//--                    C R E A T E     S I G N A L S                        --
//-----------------------------------------------------------------------------

void addSignalsToModalModel(EntityType entity, 
							List[synccharts::Signal] signalList) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let signal = signalList.last():
	port.setClass("ptolemy.domains.fsm.modal.ModalPort") ->
	port.setName(signal.name) ->
	p1.setName("input") ->
	p2.setName("output") ->
	(signal.isInput) ? port.property.add(p1) : null ->
	(signal.isLocal || signal.isOutput) ? port.property.add(p2) : null ->
	entity.port.add(port) ->
	(signalList.size > 1) ? addSignalsToModalModel(entity,signalList.withoutLast()) : null
;

void addSignalsToModalController(EntityType entity,
								 List[synccharts::Signal] signalList) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let signal = signalList.last():
	port.setClass("ptolemy.domains.fsm.modal.RefinementPort") ->
	port.setName(signal.name) ->
	p1.setName("input") ->
	p2.setName("output") ->
	(signal.isInput) ? port.property.add(p1) : null ->
	(signal.isLocal || signal.isOutput) ? port.property.add(p2) : null ->
	entity.port.add(port) ->
	(signalList.size > 1) ? addSignalsToModalController(entity,signalList.withoutLast()) : null	
;


//-----------------------------------------------------------------------------
//--         C R E A T E     T R I G G E R   /   E M I S S I O N S           --
//-----------------------------------------------------------------------------

//create guardExpression
void addTrigger(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	p1.setName("guardExpression") ->
	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	p1.setValue(buildTrigger(transition.trigger)) ->
	relation.property.add(p1)
;

//create outputActions
void addEmission(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	p1.setName("outputActions") ->
	p1.setClass("ptolemy.domains.fsm.kernel.OutputActionsAttribute") ->
	p1.setValue(buildEmission(transition.emissions)) ->
	relation.property.add(p1) 
;


String buildTrigger(synccharts::Expression expression) :
 switch (expression.metaType.toString()) {
 	case "synccharts::SignalReference" : ((synccharts::SignalReference)expression).signal.name + "_isPresent"
    case "synccharts::ComplexExpression" : buildComplexExpression((synccharts::ComplexExpression)expression)
    default : ""
 } 		 
;

String buildComplexExpression(synccharts::ComplexExpression complexExpression) :
	let operator = complexExpression.operator:
	(complexExpression.subExpressions.size > 0) ? buildComplexExpression(complexExpression.subExpressions.withoutFirst()) : null ->
	buildTrigger(complexExpression.subExpressions.first()) + getOperator(operator) + buildTrigger(complexExpression)
;

String getOperator(synccharts::Operator operator) :
    switch (operator.operatorKind.toString()) {
		case "NOT" : "!"
		case "EQ" : "=="
		case "LT" : "<" 
		case "LEQ" : "<="
		case "AND" : "&&"
		case "OR" : "||"
		case "ADD" : "+"
		case "SUB" : "-"
		case "MULT" : "*"
		case "DIV" : "/"
		//case "VAL" : "!"
		default : ""
	}
;


String buildEmission(List[synccharts::Emission] emissions) :
 ""
;
