import synccharts;
import utilities;

//Adds a successor to the given state 
Void addSuccessorState(State source):
 let target = new State:
 connectStates(source, target) ->
 source.parentRegion.innerStates.add(target) ->
 setSelection(target)
;

Void addSuccessorStates(List[State] states):
 states.addSuccessorState()
;

//Adds a predecessor to the given state
Void addPredecessorState(State target):
let source = new State:
connectStates(source,target) ->
target.parentRegion.innerStates.add(source) ->
(target.isInitial == true) ?
    (target.setIsInitial(false) ->
    source.setIsInitial(true)) : 
setSelection(source)
;

//Adds a choice to the given state
//by adding a conditional with two
//targets.
Void addChoice(State source):
let choice = new State:
let opt1 = new State:
let opt2 = new State:
let t1 = new Transition:
let t2 = new Transition:
choice.setLabel("C1") ->
choice.setType(StateType::CONDITIONAL) ->
opt1.setLabel("S0") ->
opt2.setLabel("S1") ->
connectStates(source,choice) ->
t1.setSourceState(choice) ->
t1.setTargetState(opt1) ->
t1.setPriority(1) ->
t2.setSourceState(choice) ->
t2.setTargetState(opt2) ->
t2.setPriority(2) ->
source.parentRegion.innerStates.add(choice) ->
source.parentRegion.innerStates.add(opt1) ->
source.parentRegion.innerStates.add(opt2)
;

//Flips source and target of the 
//given transition.
Void flipTransition(Transition t):
 let source = t.sourceState:
 let target = t.targetState: 
 t.setSourceState(target) ->
 t.setTargetState(source) ->
 setSelection(t) 
;

//Connects two states
Void connectStates(State source, State target):
let transition = new Transition:
transition.setSourceState(source) ->
transition.setTargetState(target) ->
setSelection(transition)
;

// create a self loop of one state
Void addSelfLoop(State state):
  connectStates(state, state)
;

//Reroutes the target of the given transition
//to the given state
Void rerouteTransitionTarget(Transition t, State target):
t.setTargetState(target)
;

//Reroutes the source of the given transition
//to the given state
Void rerouteTransitionSource(Transition t, State source):
t.sourceState.outgoingTransitions.remove(t) ->
t.setSourceState(source) ->
source.outgoingTransitions.add(t)
;

//Adds a parallel region to the given state
Void upgradeState(State parentState):
let region = new Region:
let state = new State:
state.setIsInitial(true) ->
state.setLabel("Initial") ->
region.innerStates.add(state) ->
parentState.regions.add(region) ->
setSelection(state)
;

Void downgradeState(State parentState):
if parentState.regions.size > 0 then
 parentState.regions.removeAll(parentState.regions) ->
 parentState.signals.removeAll(parentState.signals)
;

//Returns true if the state is a complex state, 
//i.e. it has at least one inner region
Boolean isRegionState(State state):
    state.regions.size > 0
;

//Sets the object that should be selected after the transformation is executed
Void setSelection(Object object):
 JAVA de.cau.cs.kieler.ksbase.ui.utils.TransformationUtils.setPostTransformationSelection(java.lang.Object)
;

//Checks if the state is the root state.
Boolean isNoRootState(State state): 
    state.parentRegion.parentState != null
;

Boolean isNoRootState(State s1, State s2):
	s1.isNoRootState() && s2.isNoRootState()
;

Boolean isNoRootState(List[State] states):
    states.notExists(e|e.parentRegion.parentState == null)
;
// Add a state to the parent state and add all Regions
// to that new State
Void encapsulateRegions(State parentState):
  let regions = parentState.regions:
  let newRegion = new Region:
  let newState = new State:
  (parentState.regions.size > 0) ? 
    (newState.regions.addAll(regions) ->
    parentState.regions.add(newRegion) ->
    newRegion.innerStates.add(newState)) : 
   null
;

// Delete the state and move all its regions to the
// parent state 
Void flattenState(State state):
let parentRegion = state.parentRegion:
let parentState = parentRegion.parentState:
let stateSize = parentRegion.innerStates.size:
parentState.regions.addAll(state.regions) ->
state.setParentRegion(null) ->
(stateSize <= 1) ?
   parentState.regions.remove(parentRegion) : 
null
;

/////////////////////////
// Copy, cut and Paste //
/////////////////////////

// Java escapes
// copy methods
Void copyStateToClipboard(State state):
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.stateToClipboard(de.cau.cs.kieler.synccharts.State)
;

Void copyRegionToClipboard(Region region):
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.regionToClipboard(de.cau.cs.kieler.synccharts.Region)
;

Void copyTransitionToClipboard(Transition trans):
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.transitionToClipboard(de.cau.cs.kieler.synccharts.Transition)
;

Void copyStatesToClipboard(List[State] states):
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.statesToClipboard(java.util.List)
;
 
Void copyRegionsToClipboard(List[Region] regions):
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.regionsToClipboard(java.util.List)
;

// paste methods
State getStateFromClipboard():
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.getStateFromClipboard()
;

Region getRegionFromClipboard():
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.getRegionFromClipboard()
;

Transition getTransitionFromClipboard():
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.getTransitionFromClipboard()
;

List[State] getStatesFromClipboard():
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.getStatesFromClipboard()
;

List[Region] getRegionsFromClipboard():
JAVA de.cau.cs.kieler.synccharts.ksbase.Utils.getRegionsFromClipboard()
;

// Cut
Void cut(Transition trans):
 copyTransitionToClipboard(trans) ->
 trans.sourceState.outgoingTransitions.remove(trans)
 ;

Void cut(State state):
 copyStateToClipboard(state) ->
 state.removeFromParent()
;

Void cut(Region region):
 copyRegionToClipboard(region) ->
 region.removeFromParent()
;

Void cut(List[State] states):
 copyStatesToClipboard(states) ->
 states.removeFromParent()
;

Void removeFromParent(State state):
 state.parentRegion.innerStates.remove(state)
;

Void removeFromParent(Region region):
 (region.parentState != null) ?
 region.parentState.regions.remove(region) : null
;

Void cut(List[Region] regions):
 copyRegionsToClipboard(regions) ->
 regions.removeFromParent()
;

// Copy
Void copy(Transition trans):
 copyTransitionToClipboard(trans)
;

Void copy(State state):
 copyStateToClipboard(state)
;

Void copy(Region region):
 copyRegionToClipboard(region)
;

Void copy(List[Region] regions):
 copyRegionsToClipboard(regions)
;

Void copy(List[State] states):
 copyStatesToClipboard(states)
;


// Paste
Void paste(Region target):
 let region = getRegionFromClipboard():
 let state = getStateFromClipboard():
 let regions = getRegionsFromClipboard():
 let states = getStatesFromClipboard():
 ((state != null) ? target.innerStates.add(state) : null) ->
 ((region != null) ? addStatesToRegion(target, region.innerStates) : null) ->
 ((states != null) ? addStatesToRegion(target, states) : null) ->
 ((regions != null) ? pasteInternal(target, regions) : null)
;

Void pasteInternal(Region target, List[Region] regions): 
 let dummy = new State :
 (target.parentState != null) ?
 (target.parentState.regions.addAll(regions)) :
 (dummy.regions.addAll(regions) ->
  target.innerStates.add(dummy) ->
  dummy.setLabel(getFileNameOfActiveEditor()))
;

Void addStatesToRegion(Region target, List[State] states):
 let dummy = new State :
 let dummy2 = new Region :
 (target.parentState != null) ?
 target.innerStates.addAll(states) :
 (dummy.setLabel(getFileNameOfActiveEditor()) ->
 target.innerStates.add(dummy) ->
 dummy.regions.add(dummy2) ->
 dummy2.innerStates.addAll(states))
;

Void paste(State target):
 let region = getRegionFromClipboard():
 let state = getStateFromClipboard():
 let regions = getRegionsFromClipboard():
 let states = getStatesFromClipboard():
 let dummy = new Region:
 ((state != null) ? 
   (dummy.innerStates.add(state) ->
    target.regions.add(dummy)) : 
  null) ->
 ((region != null) ? 
   (target.regions.add(region)) : 
  null) ->
 ((states != null) ?
   (dummy.innerStates.addAll(states) ->
    target.regions.add(dummy)) :
  null) ->
  ((regions != null) ?
   (target.regions.addAll(regions)) :
  null)
;

Void paste(State source, State target):
 let trans = getTransitionFromClipboard():
 (trans != null) ?
 (source.outgoingTransitions.add(trans) ->
 trans.setTargetState(target)) :
 null
;

/////////////////////////
//     Templates      ///
/////////////////////////

//Creates a default StateChart
Void createDefault(Region rootRegion):
let state = new State:
let innerState = new State:
let region = new Region:
state.setLabel(getFileNameOfActiveEditor()) ->
state.regions.add(region) ->
innerState.setLabel("Initial") ->
innerState.setIsInitial(true) -> 
region.innerStates.add(innerState) ->
rootRegion.innerStates.add(state) ->
setSelection(innerState)
;

String getFileNameOfActiveEditor():
JAVA de.cau.cs.kieler.ksbase.ui.utils.TransformationUtils.getFileNameOfActiveEditor()
;

//Adds an initial state to a region
Void addInitialState(Region target):
 let parent = target.parentState :
 let state = new State:
 (parent != null) ?
 (state.setLabel("Initial") ->
 state.setIsInitial(true) ->
 target.innerStates.add(state) ->
 setSelection(state)) :
 createDefault(target)
;

//Good ol' ABRO
Void addABRO(Region rootRegion):
let waitABToFinal = new Transition:
let reset = new Transition:
let ABOFinal = new State:
let wATrans = new Transition:
let wBTrans = new Transition:
let wAInitial = new State:
let wAFinal = new State:
let wBInitial = new State:
let wBFinal = new State:
let wA = new Region:
let wB = new Region:
let waitAB = new State:
let ABORegion = new Region:
let ABO = new State:
let innerRootRegion = new Region:
let sigA = new Signal:
let sigB = new Signal:
let sigR = new Signal:
let sigO = new Signal:
let root = new State:
//ABRO Root State
root.setLabel("ABRO") ->
//ABRO Signal definition:
sigA.setName("A") ->
sigA.setIsInput(true) ->
sigB.setName("B") ->
sigB.setIsInput(true) ->
sigR.setName("R") ->
sigR.setIsInput(true) ->
sigO.setName("O") ->
sigO.setIsOutput(true) ->
root.signals.add(sigA) ->
root.signals.add(sigB) ->
root.signals.add(sigR) ->
root.signals.add(sigO) ->
//Inner State ABO
ABO.setLabel("ABO") ->
ABO.setIsInitial(true) ->
//Inner state Wait A and B
waitAB.setLabel("WaitAB") ->
waitAB.setIsInitial(true) ->
//Region for 'wait for a' 
wAInitial.setLabel("wA") ->
wAInitial.setIsInitial(true) ->
wA.innerStates.add(wAInitial) ->
wAFinal.setLabel("dA") ->
wAFinal.setIsFinal(true) ->
wA.innerStates.add(wAFinal) ->
wATrans.setSourceState(wAInitial) ->
wATrans.setTargetState(wAFinal) ->
wATrans.setTriggersAndEffects("A") ->
waitAB.regions.add(wA) ->
//Region for 'wait for b'
wBInitial.setLabel("wB") ->
wBInitial.setIsInitial(true) ->
wB.innerStates.add(wBInitial) ->
wBFinal.setLabel("dB") ->
wBFinal.setIsFinal(true) ->
wB.innerStates.add(wBFinal) ->
wBTrans.setSourceState(wBInitial) ->
wBTrans.setTargetState(wBFinal) ->
wBTrans.setTriggersAndEffects("B") ->
waitAB.regions.add(wB) ->
//ABO final state
ABOFinal.setLabel("done") ->
waitABToFinal.setSourceState(waitAB) ->
waitABToFinal.setTargetState(ABOFinal) ->
waitABToFinal.setType(TransitionType::NORMALTERMINATION) ->
waitABToFinal.setTriggersAndEffects("/O") ->
ABORegion.innerStates.add(waitAB) ->
ABORegion.innerStates.add(ABOFinal) ->
ABO.regions.add(ABORegion)->
reset.setSourceState(ABO) ->
reset.setTargetState(ABO) ->
reset.setType(TransitionType::STRONGABORT) ->
reset.setTriggersAndEffects("R") ->
innerRootRegion.innerStates.add(ABO) ->
root.regions.add(innerRootRegion) ->
rootRegion.innerStates.add(root)
;