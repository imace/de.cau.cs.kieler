import synccharts;

///////////////////////////////////////
// Optimization and fixing of issues //
///////////////////////////////////////
// This is just a copy, changing the transformations must be done in feature.ext

// Java escapes.
Void generateStateId(State state):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.generateStateId(de.cau.cs.kieler.synccharts.State)
;

Void generateRegionId(Region region):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.generateRegionId(de.cau.cs.kieler.synccharts.Region)
;

Void clearIDCache():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.clearCache()
;

List[State] getStateList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getStateList()
;

Void debug(Object object):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.debug(java.lang.Object)
;

Boolean isEnabled(String key):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.isEnabled(java.lang.String)
;

// runs all optimizations
Void fixAllBugs(State state):
 fixAllBugs(state.parentRegion)
;

// runs all optimizations
Void fixAllBugs(Region rootRegion):
 fixIDs(rootRegion) ->
 fixTransitionPriorities(rootRegion) ->
 fixConditionalOutgoingImmediate(rootRegion) ->
 fixDummyStates(rootRegion) ->
 fixWhiteSpaces(rootRegion) ->
 removeRedundantRegions(rootRegion)
;

// runs only selected optimizations
Void optimizeSelected(State state):
 optimizeSelected(state.parentRegion)
;

// runs only selected optimizations
Void optimizeSelected(Region rootRegion):
 (if (isEnabled("fixIDs")) then
   fixIDs(rootRegion)) ->
 (if (isEnabled("fixTransitionPriorities")) then 
   fixTransitionPriorities(rootRegion)) ->
 (if (isEnabled("fixConditionalOutgoingImmediate")) then
   fixConditionalOutgoingImmediate(rootRegion)) ->
 (if (isEnabled("removeDummyStates")) then
   fixDummyStates(rootRegion)) ->
 (if (isEnabled("removeWhiteSpaces")) then
   fixWhiteSpaces(rootRegion)) ->
 (if (isEnabled("removeDummyRegions")) then
   removeRedundantRegions(rootRegion))
;

// === begin fix priorities ===
// fix the transition priorities:
// current convention is priorities starting with 1
// older synccharts may have 0 as lowest priority


Void fixTransitionPriorities(Region rootRegion):
 rootRegion.innerStates.fixTransitionPriorities()
;

Void fixTransitionPriorities(State state):
 state.outgoingTransitions.fixPriority() ->
 state.regions.fixTransitionPriorities()
;

Void fixPriority(Transition trans):
 (trans.priority == 0 ?
  trans.sourceState.outgoingTransitions.incrementPriority()
 :
  null
 )
;

Void incrementPriority(Transition trans):
 let prio = trans.priority:
 trans.setPriority(prio + 1)
;

// === end fix priorities ===


// === begin conditional outgoing immediate ===
// transitions leaving a conditional state must be immediate

Void fixConditionalOutgoingImmediate(Region rootRegion):
 rootRegion.innerStates.fixConditionalOutgoingImmediate()
;

Void fixConditionalOutgoingImmediate(State state):
 (state.type == StateType::CONDITIONAL ?
  state.outgoingTransitions.setIsImmediate(true)
 :
  null
 ) ->
 state.regions.fixConditionalOutgoingImmediate()
;

// === end conditional outgoing immediate ===

// === begin dummy states ===
// removes redundant states

Void fixDummyStates(Region rootRegion):
 let list = getStateList():
 rootRegion.innerStates.fixDummyStatesRec(list) ->
 list.removeStateFromRegion()
;

Void fixDummyStates(State state):
 fixDummyStates(state.parentRegion)
;

Void removeStateFromRegion(State state):
 state.parentRegion.innerStates.remove(state)
;

Void fixDummyStatesRec(Region rootRegion, List[State] list):
 rootRegion.innerStates.fixDummyStatesRec(list)
;

Void fixDummyStatesRec(State state, List[State] list):
 let trans = state.outgoingTransitions:
 
 (trans.size == 1 &&
  (trans.get(0).triggersAndEffects == null || 
  trans.get(0).triggersAndEffects.matches("")) &&
  trans.get(0).isImmediate &&
  state.regions.isEmpty &&
  state.suspensionTrigger == null &&
  state.entryActions.isEmpty &&
  state.exitActions.isEmpty &&
  state.innerActions.isEmpty ?
  (replaceState(state, trans.get(0).targetState) ->
  list.add(state)) 
 :
   state.regions.fixDummyStatesRec(list)
 )
;

Void replaceState(State old, State replacement):
 let incoming = getIncomingTransitions(old):
 replacement.setIsInitial(old.isInitial) ->
 incoming.setTargetState(replacement)
;

List[Transition] getIncomingTransitions(State state):
 let parent = state.parentRegion:
 parent.innerStates.outgoingTransitions.select(e|e.targetState == state)
;

// === end dummy states ===

// === begin IDs ===
// each state and region must have a unique ID

Void fixIDs(Region rootRegion):
 fixIDsRec(rootRegion) ->
 clearIDCache()
;

Void fixIDs(State state):
 fixIDs(state.parentRegion)
;

Void fixIDsRec(Region region):
 generateRegionId(region) ->
 region.innerStates.fixIDsRec()
;

Void fixIDsRec(State state):
 state.setId(state.label) ->
 generateStateId(state) ->
 state.regions.fixIDsRec()
;

// === end IDs ===

// === begin WhiteSpaces ===
// Transition Triggers and effects should not contain whitespaces

Void fixWhiteSpaces(Region region):
 region.innerStates.fixWhiteSpaces() ->
 region
;

Void fixWhiteSpaces(State state):
 state.outgoingTransitions.fixWhiteSpacesInAction() ->
 state.entryActions.fixWhiteSpacesInAction() ->
 state.exitActions.fixWhiteSpacesInAction() ->
 state.suspensionTrigger.fixWhiteSpacesInAction() ->
 state.innerActions.fixWhiteSpacesInAction() ->
 state.regions.fixWhiteSpaces() ->
 state
;

Void fixWhiteSpacesInAction(Action action):
 action.triggersAndEffects.replaceAll(" " , "")
;

Void fixNormalTerminations(Region region):
 region.innerStates.fixNormalTerminations()
;

Void fixNormalTerminations(State state):
 state.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION).fixTransitionType() ->
 state.regions.fixNormalTerminations()
;

Void fixTransitionType(Transition trans):
 (trans.sourceState.regions.isEmpty ?
  trans.setType(TransitionType::WEAKABORT)
 : 
  (removeTriggerFromString(trans) ->
  trans.setTrigger(null))
 )
;

Void removeTriggerFromString(Transition trans):
 (trans.triggersAndEffects != null ?
  ((trans.effects.isEmpty ?
   trans.setTriggersAndEffects(null)
  :
   trans.setTriggersAndEffects("/" + trans.triggersAndEffects.split("/").get(1)) 
  ))
 :
  null
 )
;

// === end WhiteSpaces ===

// === begin Dummy Regions ===
// removes redundant regions

Void removeRedundantRegions(Region rootRegion):
 rootRegion.innerStates.recRemoveRedundantRegions()
;

Void recRemoveRedundantRegions(State state):
 state.regions.recRemoveRedundantRegions()
;

Void recRemoveRedundantRegions(Region region):
 if (region.innerStates.isEmpty) then
   (if (region.signals.isEmpty &&
       region.variables.isEmpty) then
       region.parentState.regions.remove(region))
   else
     region.innerStates.recRemoveRedundantRegions()
;

// === end Dummy Regions ===
