import synccharts;
import kexpressions;
import utilities;

// Helper method to set the label on a transition
//  chsch: casting to Object avoids false positive error marker, see line 216
Void setLabel(Action action, Object label):
 JAVA de.cau.cs.kieler.synccharts.ksbase.SyncchartsKsbasePlugin.setLabel(de.cau.cs.kieler.synccharts.Action, java.lang.String)
;

///////////////////////////////////////
// Optimization and fixing of issues //
///////////////////////////////////////

// generate IDs
Void generateStateId(State state):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.generateStateId(de.cau.cs.kieler.synccharts.State)
;
Void generateRegionId(Region region):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.generateRegionId(de.cau.cs.kieler.synccharts.Region)
;

// clear the cache for region and state ids
Void clearIDCache():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.clearCache()
;

// get empty lists
List[State] getStateList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getStateList()
;
List[Region] getRegionList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getRegionList()
;
 
// used for debug output
// FIXME: haf: a function "debug" is already defined by the io stdlib
Void myDebug(Object object):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.debug(java.lang.Object)
;

// determine whether or not an optimization is enabled
Boolean isEnabled(String key):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.isEnabled(java.lang.String)
;

String getChoice(String key):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getChoice(java.lang.String)
;

// check for simple state
Boolean isSimpleState(State state):
  state.regions.isEmpty &&
  state.suspensionTrigger == null &&
  state.entryActions.isEmpty &&
  state.exitActions.isEmpty &&
  state.innerActions.isEmpty
;

// start from selected state
Void optimize(State state):
 optimize(state.parentRegion)
;

// start from selected region (root region is usually best)
Void optimize(Region rootRegion):
 let statesToRemove = getStateList():
 let regionsToRemove = getRegionList():
 clearIDCache() ->
 statesToRemove.removeAll(statesToRemove) ->
 regionsToRemove.removeAll(regionsToRemove) ->
 optimizeRec(rootRegion,
             statesToRemove,
             regionsToRemove) ->
 // remove redundant regions and states after optimization to avoid
 // concurrent modification of lists
 (if isEnabled("removeDummyStates") then
   statesToRemove.removeStateFromRegion()) ->
 (if isEnabled("removeDummyRegions") then 
   regionsToRemove.removeRegionFromState())
;

// remove methods
Void removeStateFromRegion(State state):
let inc = state.incomingTransitions:
let out = state.outgoingTransitions:
inc.setSourceState(state) ->
out.setTargetState(state) ->
 state.parentRegion.states.remove(state)
;
Void removeRegionFromState(Region region):
 if region.parentState != null then
   region.parentState.regions.remove(region)
;

// optimize recursively
Void optimizeRec(Region region,
                 List[State] statesToRemove,
                 List[Region] regionsToRemove):
 optimizeScope(region) ->
 (if isEnabled("fixIDs") then
    generateRegionId(region)) ->
 (if region.states.isEmpty 
   // region empty, maybe remove it
   then (if (isEnabled("removeDummyRegions") &&
       region.signals.isEmpty &&
       region.variables.isEmpty) then
       regionsToRemove.add(region))
   else
   // region not empty, go through states recursively
    region.states.optimizeRec(statesToRemove,
                                   regionsToRemove)
 )
;

// check if one of the transition fixes is enabled
Boolean isFixTransitionsEnabled():
 isEnabled("removeTriggerFromNormalTermination") ||
 isEnabled("fixTransitionTypeLeavingSimpleState") ||
 isEnabled("fixTransitionPriorityBasedOnType") ||
 isEnabled("fixTransitionPriorityIsZero")
;

// check if one of the state removal options is enabled
Boolean isRemoveStatesEnabled():
 (isEnabled("removeDummyStates") || isEnabled("removeDeadEndConditionals"))
;

// optimize state recursively
Void optimizeRec(State state,
                 List[State] statesToRemove,
                 List[Region] regionsToRemove):
 optimizeScope(state) ->
 (if isFixTransitionsEnabled() then 
   // fix transitions sorted by priority
   state.outgoingTransitions.sortBy(e|e.priority).fixTransitions()) ->
 (if (isEnabled("fixConditionalOutgoingImmediate")
       && state.type == StateType::CONDITIONAL) then
       // transitions leaving a conditional state must be immediate
       state.outgoingTransitions.setIsImmediate(true)) ->
 (if isEnabled("fixIDs") then
    state.setId(state.label) ->
    generateStateId(state)) ->
 (if isEnabled("removeWhiteSpaces") then
  // remove redundant white spaces from all actions
  (state.outgoingTransitions.fixWhiteSpacesInAction() ->
   state.entryActions.fixWhiteSpacesInAction() ->
   state.exitActions.fixWhiteSpacesInAction() ->
   state.suspensionTrigger.fixWhiteSpacesInAction() ->
   state.innerActions.fixWhiteSpacesInAction())
  ) ->
 (if isRemoveStatesEnabled() then
   state.fixDummyState(statesToRemove)) ->
 // recursion
 state.regions.optimizeRec(statesToRemove,
                           regionsToRemove)
;

Boolean signalNotRead(Signal signal, Scope scope):
 scope.eAllContents.typeSelect(ValuedObjectReference).select(reference|reference.valuedObject.name.matches(signal.name)).isEmpty
;

Boolean signalNotEmitted(Signal signal, Scope scope):
 scope.eAllContents.typeSelect(Emission).select(emission|emission.signal.name.matches(signal.name)).isEmpty
;

List[Signal] getUnReferencedSignals(Scope scope):
 scope.signals.select(e|e.signalNotRead(scope) && e.signalNotEmitted(scope))
;

Boolean variableNotRead(kexpressions::Variable var, Scope scope):
 scope.eAllContents.typeSelect(ValuedObjectReference).select(reference|reference.valuedObject.name == var.name).isEmpty
;

Boolean variableNotWritten(kexpressions::Variable var, Scope scope):
 scope.eAllContents.typeSelect(Assignment).select(assignment|assignment.variable.name == var.name).isEmpty
;

List[Variable] getUnusedVariables(Scope scope):
 scope.variables.select(e|variableNotRead(e, scope) && (e.const || variableNotWritten(e, scope)))
;

Void optimizeScope(Scope scope):
 (if (isEnabled("removeUnusedSignalsAndVariables")) then 
   (
    scope.removeSignalsFromScope(scope.getUnReferencedSignals()) ->
    scope.removeVariablesFromScope(scope.getUnusedVariables())
   )
 )
;

Void removeSignalsFromScope(Scope scope, List[Signal] signals):
 if (signals != null && !signals.isEmpty) then signals.removeFromScope(scope)
;

Void removeFromScope(Signal signal, Scope scope):
 scope.signals.remove(signal)
;

Void removeFromScope(Variable variable, Scope scope):
 scope.variables.remove(variable)
;

Void removeVariablesFromScope(Scope scope, List[Variable] variables):
 if (variables != null && !variables.isEmpty) then variables.removeFromScope(scope)
;

// === begin WhiteSpaces ===
// action Triggers and effects should not contain whitespaces
// FIXME: Disabled for now as more complex syntax analysis would be necessary

Void fixWhiteSpacesInAction(Action action):
// chsch: cast to Object aboids false positive error marker
 //if (action != null) then setLabel(action, action.label.replaceAll(" " , ""))
 if (action != null) then setLabel(action, (Object) action.label)
;

// === end WhiteSpaces ===

// === begin fix transitions ===
// transitions leaving simple states have to be weak aborts
// normal terminations may not have a trigger
// fix the transition priorities:
// current convention is priorities starting with 1
// older synccharts may have 0 as lowest priority

Void fixTransitions(List[Transition] trans):
 trans.fixTransitionPriorityBasedOnType() ->
 trans.fixTransitionPriorityIsZero() ->
 trans.fixTransitionType()
;

Void fixTransitionPriorityBasedOnType(List[Transition] list):
(if isEnabled("fixTransitionPriorityBasedOnType") then
 (
 // normal termination must have the lowest priority
 list.select(e|e.type == TransitionType::NORMALTERMINATION).setPriority(list.size) ->
 // fix rest of the priorities in JAVA
 fixTransList(list)
 )
)
;

// order the priorities by type, keeps order within the types as list was sorted earlier
Void fixTransList(Object obj):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.fixTransList(java.lang.Object)
;
 
// increment all priorities if one has priority zero
Void fixTransitionPriorityIsZero(Transition trans):
 (if (isEnabled("fixTransitionPriorityIsZero") && trans.priority == 0) then
  trans.sourceState.outgoingTransitions.incrementPriority())
;

Void incrementPriority(Transition trans):
 let prio = trans.priority:
 trans.setPriority(prio + 1)
;

Void fixTransitionType(Transition trans):
 let choice1 = getChoice("fixNormalTerminationLeavingComplexState"):
 if trans.sourceState.isSimpleState() 
 then
 (
  if isEnabled("fixTransitionTypeLeavingSimpleState") 
   // transitions leaving simple states should be weakabort
   then trans.setType(TransitionType::WEAKABORT)
 ) 
 else
 (
  if (trans.type == TransitionType::NORMALTERMINATION) then
  (
  // normal termination transitions can not have triggers
  // normal termination transitions leaving simple states were
  // already fixed earlier and will not be touched here
   (if choice1.matches("removeTriggerFromNormalTermination") then
    (removeTriggerFromString(trans) ->
         trans.setTrigger(null))) ->
   (if choice1.matches("turnNormalTerminationIntoWeakAbort") then 
    trans.setType(TransitionType::WEAKABORT))
  )
 )
;

Void removeTriggerFromString(Transition trans):
 let str = trans.label.split("/"):
 
 if (trans.label != null) then
  (if (trans.effects.isEmpty) then
     setLabel(trans, null)
   else (
        if (str.size > 1) then
            setLabel(trans, "/" + trans.label.split("/").get(1))
     )
  )
;

// === end fix transitions ===

// === begin dummy states ===
// removes redundant states

Void fixDummyState(State state, List[State] list):
 let trans = state.outgoingTransitions:
 (if (isEnabled("removeDummyStates") &&
   trans.size == 1 &&
  (trans.get(0).label == null || 
  trans.get(0).label.trim() == null ||
  trans.get(0).label.trim().matches("") ||
  trans.get(0).label.trim().matches("# /") ||
  trans.get(0).label.trim().matches("#")) &&
  trans.get(0).isImmediate &&
  state.isSimpleState()) then
  (replaceState(state, trans.get(0).targetState) ->
  list.add(state))) ->
 (if (isEnabled("removeDeadEndConditionals") &&
      state.type == StateType::CONDITIONAL &&
      trans.size == 0) then
     (state.removeState() ->
     list.add(state)))
;

Void removeState(State state):
 let incoming = state.incomingTransitions:
 let outgoing = state.outgoingTransitions:
 incoming.removeTransition() ->
 outgoing.removeTransition()
;

Void removeTransition(Transition trans):
 trans.setSourceState(null) ->
 trans.setTargetState(null)
;

Void replaceState(State old, State replacement):
 let incoming = old.incomingTransitions:
 let outgoing = old.outgoingTransitions:
 replacement.setIsInitial(old.isInitial) ->
 incoming.setTargetState(replacement) ->
 (if (replacement.isInitial && replacement.type == StateType::CONDITIONAL) then
   replacement.setType(StateType::NORMAL)) 
;

// === end dummy states ===
