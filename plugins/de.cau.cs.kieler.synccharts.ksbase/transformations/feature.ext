import synccharts;
import expressions;
import utilities;

extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension de::cau::cs::kieler::ksbase::util::userdialogs; // functions to request values from user

//Adds a successor to the given state 
Void addSuccessorState(State source):
 let target = new State:
 connectStates(source, target) ->
 source.parentRegion.innerStates.add(target) ->
 setSelection(target)
;
 
Void addSuccessorStates(List[State] states):
 states.addSuccessorState()
;

//Adds a predecessor to the given state
Void addPredecessorState(State target):
let source = new State:
connectStates(source,target) ->
target.parentRegion.innerStates.add(source) ->
(target.isInitial == true) ?
    (target.setIsInitial(false) ->
    source.setIsInitial(true)) : 
setSelection(source)
;

//Adds a choice to the given state
//by adding a conditional with two
//targets.
Void addChoice(State source):
let choice = new State:
let opt1 = new State:
let opt2 = new State:
let t1 = new Transition:
let t2 = new Transition:
choice.setLabel("C1") ->
choice.setType(StateType::CONDITIONAL) ->
opt1.setLabel("S0") ->
opt2.setLabel("S1") ->
connectStates(source,choice) ->
t1.setSourceState(choice) ->
t1.setTargetState(opt1) ->
t1.setPriority(1) ->
t2.setSourceState(choice) ->
t2.setTargetState(opt2) ->
t2.setPriority(2) ->
source.parentRegion.innerStates.add(choice) ->
source.parentRegion.innerStates.add(opt1) ->
source.parentRegion.innerStates.add(opt2)
;

//Flips source and target of the 
//given transition.
Void flipTransition(Transition t):
 let source = t.sourceState:
 let target = t.targetState: 
 t.setSourceState(target) ->
 t.setTargetState(source) ->
 setSelection(t) 
;
//Inserts a state in a transition
Void insertState(Transition t):
 let source = t.sourceState:
 let target = t.targetState:
 let newState = new State:
 t.setTargetState(newState) ->
 connectStates(newState, target) ->
 source.parentRegion.innerStates.add(newState) ->
 setSelection(newState)
;
//Connects two states
Void connectStates(State source, State target):
let transition = new Transition:
transition.setSourceState(source) ->
transition.setTargetState(target) ->
setSelection(transition)
;

// create a self loop of one state
Void addSelfLoop(State state):
  connectStates(state, state)
;

//Reroutes the target of the given transition
//to the given state
Void rerouteTransitionTarget(Transition t, State target):
t.setTargetState(target)
;

//Reroutes the source of the given transition
//to the given state
Void rerouteTransitionSource(Transition t, State source):
t.sourceState.outgoingTransitions.remove(t) ->
t.setSourceState(source) ->
source.outgoingTransitions.add(t)
;

//Adds a parallel region to the given state
Void upgradeState(State parentState):
let region = new Region:
let state = new State:
state.setIsInitial(true) ->
state.setLabel("Initial") ->
region.innerStates.add(state) ->
parentState.regions.add(region) ->
setSelection(state)
;

Void downgradeState(State parentState):
if parentState.regions.size > 0 then
 parentState.regions.removeAll(parentState.regions) ->
 parentState.signals.removeAll(parentState.signals)
;

//Returns true if the state is a complex state, 
//i.e. it has at least one inner region
Boolean isRegionState(State state):
    state.regions.size > 0
;

//Sets the object that should be selected after the transformation is executed
Void setSelection(Object object):
 JAVA de.cau.cs.kieler.ksbase.ui.utils.TransformationUtils.setPostTransformationSelection(java.lang.Object)
;

//Checks if the state is the root state.
Boolean isNoRootState(State state): 
    state.parentRegion.parentState != null
;

Boolean isNoRootState(State s1, State s2):
	s1.isNoRootState() && s2.isNoRootState()
;

Boolean statesOnSameHierarchy(State s1, State s2):
	s1.parentRegion == s2.parentRegion
;

Boolean isNoRootState(List[State] states):
    states.notExists(e|e.parentRegion.parentState == null)
;
// Add a state to the parent state and add all Regions
// to that new State
Void encapsulateRegions(State parentState):
  let regions = parentState.regions:
  let newRegion = new Region:
  let newState = new State:
  (parentState.regions.size > 0) ? 
    (newState.regions.addAll(regions) ->
    parentState.regions.add(newRegion) ->
    newRegion.innerStates.add(newState)) : 
   null
;

// Delete the state and move all its regions to the
// parent state 
Void flattenState(State state):
let parentRegion = state.parentRegion:
let parentState = parentRegion.parentState:
let stateSize = parentRegion.innerStates.size:
parentState.regions.addAll(state.regions) ->
state.setParentRegion(null) ->
(stateSize <= 1) ?
   parentState.regions.remove(parentRegion) : 
null
;

/////////////////////////
//     Templates      ///
/////////////////////////

//Creates a default StateChart
Void createDefault(Region rootRegion):
let state = new State:
let innerState = new State:
let region = new Region:
state.setLabel(getFileNameOfActiveEditor()) ->
state.regions.add(region) ->
innerState.setLabel("Initial") ->
innerState.setIsInitial(true) -> 
region.innerStates.add(innerState) ->
rootRegion.innerStates.add(state) ->
setSelection(innerState)
;

String getFileNameOfActiveEditor():
JAVA de.cau.cs.kieler.ksbase.ui.utils.TransformationUtils.getFileNameOfActiveEditor()
;

//Adds an initial state to a region
Void addInitialState(Region target):
 let parent = target.parentState :
 let state = new State:
 (parent != null) ?
 (state.setLabel("Initial") ->
 state.setIsInitial(true) ->
 target.innerStates.add(state) ->
 setSelection(state)) :
 createDefault(target)
;

// Helper method to set the label on a transition
Void setLabel(Action action, String label):
 JAVA de.cau.cs.kieler.synccharts.ksbase.SyncchartsKsbasePlugin.setLabel(de.cau.cs.kieler.synccharts.Action, java.lang.String)
;
 
//Good ol' ABRO
Void addABRO(Region rootRegion):
let waitABToFinal = new Transition:
let reset = new Transition:
let ABOFinal = new State:
let wATrans = new Transition:
let wBTrans = new Transition:
let wAInitial = new State:
let wAFinal = new State:
let wBInitial = new State:
let wBFinal = new State:
let wA = new Region:
let wB = new Region:
let waitAB = new State:
let ABORegion = new Region:
let ABO = new State:
let innerRootRegion = new Region:
let sigA = new Signal:
let sigB = new Signal:
let sigR = new Signal:
let sigO = new Signal:
let sigAExpr = new SignalReference:
let sigBExpr = new SignalReference:
let sigOExpr = new Emission:
let sigRExpr = new SignalReference:
let root = new State:
//ABRO Root State
root.setLabel("ABRO") ->
//ABRO Signal definition:
sigA.setName("A") ->
sigA.setIsInput(true) ->
sigAExpr.setSignal(sigA) ->
sigB.setName("B") ->
sigB.setIsInput(true) ->
sigBExpr.setSignal(sigB) ->
sigR.setName("R") ->
sigR.setIsInput(true) ->
sigRExpr.setSignal(sigR) ->
sigO.setName("O") ->
sigO.setIsOutput(true) ->
sigOExpr.setSignal(sigO) ->
root.signals.add(sigA) ->
root.signals.add(sigB) ->
root.signals.add(sigR) ->
root.signals.add(sigO) ->
//Inner State ABO
ABO.setLabel("ABO") ->
ABO.setIsInitial(true) ->
//Inner state Wait A and B
waitAB.setLabel("WaitAB") ->
waitAB.setIsInitial(true) ->
//Region for 'wait for a' 
wAInitial.setLabel("wA") ->
wAInitial.setIsInitial(true) ->
wA.innerStates.add(wAInitial) ->
wAFinal.setLabel("dA") ->
wAFinal.setIsFinal(true) ->
wA.innerStates.add(wAFinal) ->
wATrans.setSourceState(wAInitial) ->
wATrans.setTargetState(wAFinal) ->
//wATrans.setTrigger(sigAExpr) ->
setLabel(wATrans, "A") ->
waitAB.regions.add(wA) ->
//Region for 'wait for b'
wBInitial.setLabel("wB") ->
wBInitial.setIsInitial(true) ->
wB.innerStates.add(wBInitial) ->
wBFinal.setLabel("dB") ->
wBFinal.setIsFinal(true) ->
wB.innerStates.add(wBFinal) ->
wBTrans.setSourceState(wBInitial) ->
wBTrans.setTargetState(wBFinal) ->
//wBTrans.setTrigger(sigBExpr) ->
setLabel(wBTrans, "B") ->
waitAB.regions.add(wB) ->
//ABO final state
ABOFinal.setLabel("done") ->
waitABToFinal.setSourceState(waitAB) ->
waitABToFinal.setTargetState(ABOFinal) ->
waitABToFinal.setType(TransitionType::NORMALTERMINATION) ->
//waitABToFinal.effects.add(sigOExpr) ->
setLabel(waitABToFinal, "/O") ->
ABORegion.innerStates.add(waitAB) ->
ABORegion.innerStates.add(ABOFinal) ->
ABO.regions.add(ABORegion)->
reset.setSourceState(ABO) ->
reset.setTargetState(ABO) ->
reset.setType(TransitionType::STRONGABORT) ->
//reset.setTrigger(sigRExpr) ->
setLabel(reset, "R") ->
innerRootRegion.innerStates.add(ABO) ->
root.regions.add(innerRootRegion) ->
rootRegion.innerStates.add(root)
;

///////////////////////////////////////
// Optimization and fixing of issues //
///////////////////////////////////////

// generate IDs
Void generateStateId(State state):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.generateStateId(de.cau.cs.kieler.synccharts.State)
;
Void generateRegionId(Region region):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.generateRegionId(de.cau.cs.kieler.synccharts.Region)
;

// clear the cache for region and state ids
Void clearIDCache():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.clearCache()
;

// get empty lists
List[State] getStateList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getStateList()
;
List[Region] getRegionList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getRegionList()
;
 
// used for debug output
// FIXME: haf: a function "debug" is already defined by the io stdlib
Void myDebug(Object object):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.debug(java.lang.Object)
;

// determine whether or not an optimization is enabled
Boolean isEnabled(String key):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.isEnabled(java.lang.String)
;

String getChoice(String key):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.getChoice(java.lang.String)
;

// check for simple state
Boolean isSimpleState(State state):
  state.regions.isEmpty &&
  state.suspensionTrigger == null &&
  state.entryActions.isEmpty &&
  state.exitActions.isEmpty &&
  state.innerActions.isEmpty
;

// start from selected state
Void optimizeSelected(State state):
 optimizeSelected(state.parentRegion)
;

// start from selected region (root region is usually best)
Void optimizeSelected(Region rootRegion):
 let statesToRemove = getStateList():
 let regionsToRemove = getRegionList():
 clearIDCache() ->
 optimizeRec(rootRegion,
             statesToRemove,
             regionsToRemove) ->
 // remove redundant regions and states after optimization to avoid
 // concurrent modification of lists
 (if isEnabled("removeDummyStates") then
   statesToRemove.removeStateFromRegion()) ->
 (if isEnabled("removeDummyRegions") then 
   regionsToRemove.removeRegionFromState())
;

// remove methods
Void removeStateFromRegion(State state):
 state.parentRegion.innerStates.remove(state)
;
Void removeRegionFromState(Region region):
 if region.parentState != null then
   region.parentState.regions.remove(region)
;

// optimize recursively
Void optimizeRec(Region region,
                 List[State] statesToRemove,
                 List[Region] regionsToRemove):
 optimizeScope(region) ->
 (if isEnabled("fixIDs") then
    generateRegionId(region)) ->
 (if region.innerStates.isEmpty 
   // region empty, maybe remove it
   then (if (isEnabled("removeDummyRegions") &&
       region.signals.isEmpty &&
       region.variables.isEmpty) then
       regionsToRemove.add(region))
   else
   // region not empty, go through states recursively
    region.innerStates.optimizeRec(statesToRemove,
                                   regionsToRemove)
 )
;

// check if one of the transition fixes is enabled
Boolean isFixTransitionsEnabled():
 isEnabled("removeTriggerFromNormalTermination") ||
 isEnabled("fixTransitionTypeLeavingSimpleState") ||
 isEnabled("fixTransitionPriorityBasedOnType") ||
 isEnabled("fixTransitionPriorityIsZero")
;

// check if one of the state removal options is enabled
Boolean isRemoveStatesEnabled():
 (isEnabled("removeDummyStates") || isEnabled("removeDeadEndConditionals"))
;

// optimize state recursively
Void optimizeRec(State state,
                 List[State] statesToRemove,
                 List[Region] regionsToRemove):
 optimizeScope(state) ->
 (if isFixTransitionsEnabled() then 
   // fix transitions sorted by priority
   state.outgoingTransitions.sortBy(e|e.priority).fixTransitions()) ->
 (if (isEnabled("fixConditionalOutgoingImmediate")
       && state.type == StateType::CONDITIONAL) then
       // transitions leaving a conditional state must be immediate
       state.outgoingTransitions.setIsImmediate(true)) ->
 (if isEnabled("fixIDs") then
    state.setId(state.label) ->
    generateStateId(state)) ->
 (if isEnabled("removeWhiteSpaces") then
  // remove redundant white spaces from all actions
  (state.outgoingTransitions.fixWhiteSpacesInAction() ->
   state.entryActions.fixWhiteSpacesInAction() ->
   state.exitActions.fixWhiteSpacesInAction() ->
   state.suspensionTrigger.fixWhiteSpacesInAction() ->
   state.innerActions.fixWhiteSpacesInAction())
  ) ->
 (if isRemoveStatesEnabled() then
   state.fixDummyState(statesToRemove)) ->
 // recursion
 state.regions.optimizeRec(statesToRemove,
                           regionsToRemove)
;

Boolean signalNotRead(Signal signal, Scope scope):
 scope.eAllContents.typeSelect(SignalReference).select(reference|reference.signal.name.matches(signal.name)).isEmpty
;

Boolean signalNotEmitted(Signal signal, Scope scope):
 scope.eAllContents.typeSelect(Emission).select(emission|emission.signal.name.matches(signal.name)).isEmpty
;

List[Signal] getUnReferencedSignals(Scope scope):
 scope.signals.select(e|e.signalNotRead(scope) && e.signalNotEmitted(scope))
;

Boolean variableNotRead(Variable var, Scope scope):
 scope.eAllContents.typeSelect(VariableReference).select(reference|reference.variable.name == var.name).isEmpty
;

Boolean variableNotWritten(Variable var, Scope scope):
 scope.eAllContents.typeSelect(Assignment).select(assignment|assignment.variable.name == var.name).isEmpty
;

List[Variable] getUnusedVariables(Scope scope):
 scope.variables.select(e|e.variableNotRead(scope) && (e.const || e.variableNotWritten(scope)))
;

Void optimizeScope(Scope scope):
 (if (isEnabled("removeUnusedSignalsAndVariables")) then 
   (
    scope.removeSignalsFromScope(scope.getUnReferencedSignals()) ->
    scope.removeVariablesFromScope(scope.getUnusedVariables())
   )
 )
;

Void removeSignalsFromScope(Scope scope, List[Signal] signals):
 if (signals != null && !signals.isEmpty) then signals.removeFromScope(scope)
;

Void removeFromScope(Signal signal, Scope scope):
 scope.signals.remove(signal)
;

Void removeFromScope(Variable variable, Scope scope):
 scope.variables.remove(variable)
;

Void removeVariablesFromScope(Scope scope, List[Variable] variables):
 if (variables != null && !variables.isEmpty) then variables.removeFromScope(scope)
;

// === begin WhiteSpaces ===
// action Triggers and effects should not contain whitespaces

Void fixWhiteSpacesInAction(Action action):
 if (action != null) then setLabel(action, action.label.replaceAll(" " , ""))
;

// === end WhiteSpaces ===

// === begin fix transitions ===
// transitions leaving simple states have to be weak aborts
// normal terminations may not have a trigger
// fix the transition priorities:
// current convention is priorities starting with 1
// older synccharts may have 0 as lowest priority

Void fixTransitions(List[Transition] trans):
 trans.fixTransitionPriorityBasedOnType() ->
 trans.fixTransitionPriorityIsZero() ->
 trans.fixTransitionType()
;

Void fixTransitionPriorityBasedOnType(List[Transition] list):
(if isEnabled("fixTransitionPriorityBasedOnType") then
 (
 // normal termination must have the lowest priority
 list.select(e|e.type == TransitionType::NORMALTERMINATION).setPriority(list.size) ->
 // fix rest of the priorities in JAVA
 fixTransList(list)
 )
)
;

// order the priorities by type, keeps order within the types as list was sorted earlier
Void fixTransList(Object obj):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.OptimizeUtils.fixTransList(java.lang.Object)
;
 
// increment all priorities if one has priority zero
Void fixTransitionPriorityIsZero(Transition trans):
 (if (isEnabled("fixTransitionPriorityIsZero") && trans.priority == 0) then
  trans.sourceState.outgoingTransitions.incrementPriority())
;

Void incrementPriority(Transition trans):
 let prio = trans.priority:
 trans.setPriority(prio + 1)
;

Void fixTransitionType(Transition trans):
 let choice1 = getChoice("fixNormalTerminationLeavingComplexState"):
 if trans.sourceState.isSimpleState() 
 then
 (
  if isEnabled("fixTransitionTypeLeavingSimpleState") 
   // transitions leaving simple states should be weakabort
   then trans.setType(TransitionType::WEAKABORT)
 ) 
 else
 (
  if (trans.type == TransitionType::NORMALTERMINATION) then
  (
  // normal termination transitions can not have triggers
  // normal termination transitions leaving simple states were
  // already fixed earlier and will not be touched here
   (if choice1.matches("removeTriggerFromNormalTermination") then
    (removeTriggerFromString(trans) ->
         trans.setTrigger(null))) ->
   (if choice1.matches("turnNormalTerminationIntoWeakAbort") then 
    trans.setType(TransitionType::WEAKABORT))
  )
 )
;

Void removeTriggerFromString(Transition trans):
 if (trans.label != null) then
  (if (trans.effects.isEmpty) then
     setLabel(trans, null)
   else 
     setLabel(trans, "/" + trans.label.split("/").get(1))
  )
;

// === end fix transitions ===

// === begin dummy states ===
// removes redundant states

Void fixDummyState(State state, List[State] list):
 let trans = state.outgoingTransitions:
 (if (isEnabled("removeDummyStates") &&
   trans.size == 1 &&
  (trans.get(0).label == null || 
  trans.get(0).label.trim() == null ||
  trans.get(0).label.trim().matches("") ||
  trans.get(0).label.trim().matches("# /") ||
  trans.get(0).label.trim().matches("#")) &&
  trans.get(0).isImmediate &&
  state.isSimpleState()) then
  (replaceState(state, trans.get(0).targetState) ->
  list.add(state))) ->
 (if (isEnabled("removeDeadEndConditionals") &&
      state.type == StateType::CONDITIONAL &&
      trans.size == 0) then
     (state.removeState() ->
     list.add(state)))
;

Void removeState(State state):
 let transList = state.getIncomingTransitions():
 transList.removeTransition()
;

Void removeTransition(Transition trans):
 trans.sourceState.outgoingTransitions.remove(trans)
;

Void replaceState(State old, State replacement):
 let incoming = getIncomingTransitions(old):
 replacement.setIsInitial(old.isInitial) ->
 (if (replacement.isInitial && replacement.type == StateType::CONDITIONAL) then
   replacement.setType(StateType::NORMAL)) ->
 incoming.setTargetState(replacement)
;

List[Transition] getIncomingTransitions(State state):
 let parent = state.parentRegion:
 parent.innerStates.outgoingTransitions.select(e|e.targetState == state)
;

// === end dummy states ===



// === Refactoring functions ===
// @author haf

Void renameSignalVariable(State state):
	let newName = getStringFromUser("Renaming Signal or Variable","A"):
	let newInt = getIntFromUser("Enter Integer please!",5):
	let newFloat = getRealFromUser("Enter Float please!",5.3):
	let newBool = getBooleanFromUser("Enter Boolean please!"):
	let list = getObjectFromListFromUser("Select one item please!",{"One","Two","Three"}):
	info("renaming")
;

Boolean hasSignalsVariables(State scope):
	(scope.signals.size > 0 || scope.variables.size > 0)
;

