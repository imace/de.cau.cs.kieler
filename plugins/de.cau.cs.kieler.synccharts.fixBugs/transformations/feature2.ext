import synccharts;

Void generateStateId(State state):
 JAVA de.cau.cs.kieler.synccharts.fixBugs.Activator.generateStateId(de.cau.cs.kieler.synccharts.State)
;

Void generateRegionId(Region region):
 JAVA de.cau.cs.kieler.synccharts.fixBugs.Activator.generateRegionId(de.cau.cs.kieler.synccharts.Region)
;

Void clearIDCache():
 JAVA de.cau.cs.kieler.synccharts.fixBugs.Activator.clearCache()
;

List[State] getStateList():
 JAVA de.cau.cs.kieler.synccharts.fixBugs.Activator.getStateList()
;

Void debug(Object object):
 JAVA de.cau.cs.kieler.synccharts.fixBugs.Activator.debug(java.lang.Object)
; 

Void fixAllBugs(State state):
 fixAllBugs(state.parentRegion)
;

Void fixAllBugs(Region rootRegion):
 fixIDs(rootRegion) ->
 fixTransitionPriorities(rootRegion) ->
 fixConditionalOutgoingImmediate(rootRegion) ->
 fixDummyStates(rootRegion) ->
 fixWhiteSpaces(rootRegion)
;

Void fixTransitionPriorities(Region rootRegion):
 rootRegion.innerStates.fixTransitionPriorities()
;

Void fixTransitionPriorities(State state):
 state.outgoingTransitions.fixPriority() ->
 state.regions.fixTransitionPriorities()
;

Void fixPriority(Transition trans):
 (trans.priority == 0 ?
  trans.sourceState.outgoingTransitions.incrementPriority()
 :
  null
 )
;

Void incrementPriority(Transition trans):
 let prio = trans.priority:
 trans.setPriority(prio + 1)
;

Void fixConditionalOutgoingImmediate(Region rootRegion):
 rootRegion.innerStates.fixConditionalOutgoingImmediate()
;

Void fixConditionalOutgoingImmediate(State state):
 (state.type == StateType::CONDITIONAL ?
  state.outgoingTransitions.setIsImmediate(true)
 :
  null
 ) ->
 state.regions.fixConditionalOutgoingImmediate()
;

Void fixDummyStates(Region rootRegion):
 let list = getStateList():
 rootRegion.innerStates.fixDummyStatesRec(list) ->
 list.removeStateFromRegion()
;

Void fixDummyStates(State state):
 fixDummyStates(state.parentRegion)
;

Void removeStateFromRegion(State state):
 state.parentRegion.innerStates.remove(state)
;

Void fixDummyStatesRec(Region rootRegion, List[State] list):
 rootRegion.innerStates.fixDummyStatesRec(list)
;

Void fixDummyStatesRec(State state, List[State] list):
 let trans = state.outgoingTransitions:
 
 (trans.size == 1 &&
  (trans.get(0).triggersAndEffects == null || 
  trans.get(0).triggersAndEffects.matches("")) &&
  trans.get(0).isImmediate &&
  state.regions.isEmpty &&
  state.suspensionTrigger == null &&
  state.entryActions.isEmpty &&
  state.exitActions.isEmpty &&
  state.innerActions.isEmpty ?
  (replaceState(state, trans.get(0).targetState) ->
  list.add(state)) 
 :
   state.regions.fixDummyStatesRec(list)
 )
;

Void replaceState(State old, State replacement):
 let incoming = getIncomingTransitions(old):
 replacement.setIsInitial(old.isInitial) ->
 incoming.setTargetState(replacement)
;

List[Transition] getIncomingTransitions(State state):
 let parent = state.parentRegion:
 parent.innerStates.outgoingTransitions.select(e|e.targetState == state)
;

Void fixIDs(Region rootRegion):
 fixIDsRec(rootRegion) ->
 clearIDCache()
;

Void fixIDs(State state):
 fixIDs(state.parentRegion)
;

Void fixIDsRec(Region region):
 generateRegionId(region) ->
 region.innerStates.fixIDsRec()
;

Void fixIDsRec(State state):
 state.setId(state.label) ->
 generateStateId(state) ->
 state.regions.fixIDsRec()
;

Void fixWhiteSpaces(Region region):
 region.innerStates.fixWhiteSpaces() ->
 region
;

Void fixWhiteSpaces(State state):
 state.outgoingTransitions.fixWhiteSpacesInAction() ->
 state.entryActions.fixWhiteSpacesInAction() ->
 state.exitActions.fixWhiteSpacesInAction() ->
 state.suspensionTrigger.fixWhiteSpacesInAction() ->
 state.innerActions.fixWhiteSpacesInAction() ->
 state.regions.fixWhiteSpaces() ->
 state
;

Void fixWhiteSpacesInAction(Action action):
 action.triggersAndEffects.replaceAll(" " , "")
;