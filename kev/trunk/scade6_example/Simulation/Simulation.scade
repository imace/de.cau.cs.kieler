package simulation
node Simulation(
   controlData : elevator::ControlDataType)
returns (
   displayData : elevator::DisplayDataType)
var
   _L2 : elevator::ControlDataType;
   _L3 : elevator::DisplayDataType;
let
   _L2 = controlData;
   displayData = _L3;
   _L3 = elevator::elevator(_L2);
tel

   end;

package elevator
   const
      POSITION_DOWN : int = 0;
      DIR_DOWN : int = -1;
      DIR_UP : int = 1;
      DIR_NONE : int = 0;
      POSITION_UP : int = 100;

   type
      ControlDataType = {buttonUp : bool, buttonDown : bool, buttonAlarm : bool};
      DisplayDataType = {direction : int, alarm : bool, position : int, doorClosed : bool};

node elevator(
   controlData : ControlDataType)
returns (
   out_displayData : DisplayDataType)
var
   buttonUp : bool;
   buttonDown : bool;
   direction : int;
   alarm : bool;
   _L1 : ControlDataType;
   _L2 : DisplayDataType;
   _L4 : bool;
   _L6 : int;
   _L7 : int;
   _L8 : int;
   _L10 : int;
   _L11 : int;
   _L12 : int;
   _L13 : int;
   _L14 : int;
   _L15 : int;
   _L16 : int;
   _L17 : bool;
   _L18 : bool;
   _L19 : int;
   _L20 : int;
   _L22 : bool;
   _L27 : bool;
   _L28 : bool;
   _L29 : bool;
   _L30 : bool;
   _L31 : bool;
   _L32 : int;
   _L33 : int;
   _L34 : int;
   _L39 : bool;
   _L40 : bool;
let
   _L1 = controlData;
   out_displayData = _L2;
   _L2 = (make DisplayDataType)(_L16, _L22, _L8, _L40);
   buttonUp, buttonDown, _L4 = (flatten ControlDataType)(_L1);
   _L6 = POSITION_DOWN;
   _L7 = DIR_DOWN;
   _L8 = pwlinear::Counter(_L15, false);
   _L10 = if buttonUp then (_L11) else (_L12);
   _L11 = DIR_UP;
   _L12 = if buttonDown then (_L7) else (_L15);
   _L13 = fby(_L16; 1; DIR_NONE);
   _L14 = if _L28 then (_L20) else (_L10);
   direction = _L13;
   _L15 = direction;
   _L16 = if _L29 then (_L20) else (_L14);
   _L17 = _L8 <= _L6;
   _L18 = _L8 >= _L19;
   _L19 = POSITION_UP;
   _L20 = DIR_NONE;
   alarm = _L27;
   _L22 = alarm;
   _L27 = digital::RisingEdgeRetrigger(_L4, 10);
   _L28 = _L30 and _L17;
   _L29 = _L31 and _L18;
   _L30 = _L32 = _L33;
   _L31 = _L32 = _L34;
   _L32 = direction;
   _L33 = DIR_DOWN;
   _L34 = DIR_UP;
   _L39 = _L17 or _L18;
   _L40 =  not (_L39);
tel

   end;

package pwlinear
-- The output is incremented at each cycle with Incr.
-- At the initialization or if Reset equals "true", the output is set to Incr.
node Counter(
   Incr : 'T; 
   Reset : bool)
returns (
   Count : 'T) where 'T numeric
var
   _L2 : 'T;
   _L3 : bool;
   _L4 : 'T;
   _L9 : 'T;
   _L18 : 'T;
   _L46 : 'T;
let
   _L2 = Incr;
   _L3 = Reset;
   Count = _L9;
   _L4 = if _L3 then (_L46) else (_L18);
   _L9 = _L4 + _L2;
   _L18 = fby(_L9; 1; _L46);
   _L46 = (0 : 'T);
tel

   end;

package digital
-- Detects a rising edge (false to true transition ).
-- If a rising edge occurs while the output is true it is detected.
-- The output becomes true as soon as transition has been detected and remains unchanged during NumberOfCycle cycle.
-- The output is initialized to false. 
node RisingEdgeRetrigger(
   RER_Input : bool; 
   NumberOfCycle : int)
returns (
   RER_Output : bool)
var
   _L13 : bool;
   _L14 : bool;
   _L16 : bool;
   _L31 : bool;
   _L44 : int;
   _L43 : bool;
   _L41 : int;
   _L39 : bool;
   _L38 : bool;
   _L36 : bool;
   _L35 : bool;
   _L46 : bool;
   _L47 : bool;
   _L48 : int;
   _L50 : int;
let
   RER_Output = _L43;
   _L13 = RER_Input;
   _L14 = pre (_L31);
   _L16 = _L13 and _L14;
   _L31 =  not (_L13);
   _L44 = 0;
   _L43 = _L38 and _L35;
   _L41 = NumberOfCycle;
   _L39 = fby(_L43; 1; _L36);
   _L38 = _L39 or _L46;
   _L36 = false;
   _L35 = _L44 < _L48;
   _L46 = (_L47) -> (_L16);
   _L47 = false;
   _L48 = (activate count_down every _L38 initial default (_L50))(_L46, _L41);
   _L50 = 0;
tel

-- Outputs input N when reset is true.
-- Count down by step of 1 from value set on input N as long as reset is false.
node count_down(
   Reset : bool; 
   N : int)
returns (
   cpt : int)
var
   _L1 : bool;
   _L2 : int;
   _L3 : int;
   _L4 : int;
   _L7 : int;
   _L8 : int;
   _L13 : int;
let
   _L1 = Reset;
   _L2 = N;
   cpt = _L3;
   _L3 = if _L1 then (_L2) else (_L8);
   _L4 = _L3 - _L7;
   _L7 = 1;
   _L8 = (_L2) -> (_L13);
   _L13 = pre (_L4);
tel

   end;

