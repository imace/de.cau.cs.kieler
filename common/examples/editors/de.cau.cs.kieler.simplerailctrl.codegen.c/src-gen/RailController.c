
/* ==========================================================================
   
    RailController.c

    This code is generated by oAw code generation from a SimpleRailCtrl
    EMF metamodel instance.

    Copyright 2008 Christian Motika, cmot@delphino.de

    This is free software, released under the terms of the GNU General
    Public License.

 ========================================================================== */

#include "railway.h"							  
#include "kicking.h"							  
#include <stdio.h>							  
#include <unistd.h>							  
#include <stdlib.h>		
#include <pthread.h>

#define DEBUGCONTROLLER 1

//define point constants
#define POINT_0 0   
#define POINT_1 1   
#define POINT_2 2   
#define POINT_3 3   
#define POINT_4 4   
#define POINT_5 5   
#define POINT_6 6   
#define POINT_7 7   
#define POINT_8 8   
#define POINT_9 9   
#define POINT_10 10   
#define POINT_11 11   
#define POINT_12 12   
#define POINT_13 13   
#define POINT_14 14   
#define POINT_15 15   
#define POINT_16 16   
#define POINT_17 17   
#define POINT_18 18   
#define POINT_19 19   
#define POINT_20 20  
#define POINT_21 21  
#define POINT_22 22  
#define POINT_23 23  
#define POINT_24 24  
#define POINT_25 25  
#define POINT_26 26  
#define POINT_27 27  
#define POINT_28 28  
#define POINT_29 29   

//define FIRST and SECOND
#define FIRST 0
#define SECOND 1

#define STOP 0
#define FWD 1
#define REV 2
#define BRAKE 3

int GLOBSEM = 0; 			// a global semaphore to rail API (released)

int MasterShutdown;			// master shutdown initialization
int TICK = 0; 				// globally increased (MACRO)TICK

struct railway_system *railway;

//hash function for state-ids
int HASH (const char *str_param) {
	unsigned long int hashvalue, test;
	const char *str = str_param;
	hashvalue = 0;
	while (*str != '\0') {
		hashvalue <<= 4;
		hashvalue += (unsigned char) *str++;
		test = hashvalue & ((unsigned long int) 0xf << (32 - 4));
		if (test) {
			hashvalue ^= test >> (32 - 8);
			hashvalue ^= test;
		}//end if
	}
	return (int)hashvalue;
}


int P(int ThreadId){
	while (1) {
      if (!railway_alive(railway)) {
	      if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
	      exit(EXIT_FAILURE);
      }//end if
	  usleep(1000); // sleep for 1ms
      //if (DEBUGCONTROLLER) printf("Thread %d waiting for global lock.\n",ThreadId);
	  //if global semaphore is free
	  if (GLOBSEM == 0) {
	  	//try to grabb it
	  	GLOBSEM = ThreadId;
	  	//if succeeded return!
		if (GLOBSEM == ThreadId) return 1;
	  }
	}
}
void V(int ThreadId){
   //if (DEBUGCONTROLLER) printf("Thread %d released global lock.\n",ThreadId);
   GLOBSEM = 0;
}


// The Master Thread implements an idea of synchrony. Its task
// is to use barrier synchronization and let every thread run its
// main loop OR event loop just once before not every other thread
// has also proceeded in doing so
// this ensures the "eventually entry" of any railway API code that is 
// sequentialized due to the use of simple binary semaphore mutex
// variables
// Every thread has its own localLOCK variable, that is increased in
// every loop step, the thread must wait 
// if its own localLOCK is > 0. It is reset to 0 if ALL threads have
// set their localLOCKs to > 0 and hence have done a step
void* ThreadFunctionMaster(void* port)
{
  while (!MasterShutdown) {
  		//wait for all localTicks to be increased
  		if ((1)) {
  			//increase a tick counter (useless)
  			TICK++;
			//if (DEBUGCONTROLLER) printf("TICK %d\n",TICK);
  		}//end if
		usleep(1000); // sleep for 1ms
  }
  return (void *)1;
}
 
 


int main() {
	//initialize railway system 
  	if ((railway=railway_initsystem(&kicking))==NULL) {
    	perror("railway_initsystem");
    	exit(EXIT_FAILURE);
  	}
  	if (railway_openlinks_udp(railway,"node%02i","/dev/ttyS0")<0) {
    	railway_donesystem(railway);
    	exit(EXIT_FAILURE);
  	}
  	if (railway_startcontrol(railway,0,0)<0) {
	    perror("railway_startcontrol");
	    railway_closelinks(railway);
    	railway_donesystem(railway);
	    exit(EXIT_FAILURE);
  	}
  	
  	//start the master thread
  	MasterShutdown = 0;
    pthread_t ThreadMaster;
    pthread_create (&ThreadMaster, NULL, &ThreadFunctionMaster, NULL);
    
    //start concurrent threads of controllers
 
    //wait for concurrent controller threads
	
	//shutdown master thread
	MasterShutdown = 1;
	
    if (DEBUGCONTROLLER) printf("Waiting for GUI thread or railway system shutdown.\n");
    
    //shutdown the railway
    if (railway_stopcontrol(railway,1)<0) {
      perror("railway_stopcontrol");
      exit(EXIT_FAILURE);
    }
    if (railway_closelinks(railway)<0) {
      perror("railway_closelinks");
      exit(EXIT_FAILURE);
    }
    if (railway_donesystem(railway)<0) {
      perror("railway_donesystem");
      exit(EXIT_FAILURE);
    }
    
    if (DEBUGCONTROLLER) printf("All threads joined - terminating program.\n");
    return 1;
}

